<?php
/**
 * ViolationReport
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * xServer
 *
 * PTV xServer 2.26.0 - 2.26 API document
 *
 * OpenAPI spec version: 2.26
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.34
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;
use \Swagger\Client\ObjectSerializer;

/**
 * ViolationReport Class Doc Comment
 *
 * @category Class
 * @description Violation related information describing tours or trips. The violation report contains violation summaries of its parent object, which is either a tour report or a trip report. Hint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.ViolationReport
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ViolationReport implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = '$type';

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'ViolationReport';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'maximum_opening_interval_exceedance' => '\Swagger\Client\Model\Duration',
'maximum_quantity_scenario_exceedance' => '\Swagger\Client\Model\TransportQuantityUnit[]',
'vehicle_equipment_violations' => 'string[]',
'rest_position_violated' => 'bool',
'customer_stop_position_in_trip_violated' => 'bool',
'trip_section_violated' => 'bool',
'mixed_loading_prohibitions_violations' => '\Swagger\Client\Model\MixedLoadingProhibition[]',
'route_violated' => 'bool',
'reachability_violated' => 'bool',
'type' => 'string'    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'maximum_opening_interval_exceedance' => null,
'maximum_quantity_scenario_exceedance' => null,
'vehicle_equipment_violations' => null,
'rest_position_violated' => null,
'customer_stop_position_in_trip_violated' => null,
'trip_section_violated' => null,
'mixed_loading_prohibitions_violations' => null,
'route_violated' => null,
'reachability_violated' => null,
'type' => null    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'maximum_opening_interval_exceedance' => 'maximumOpeningIntervalExceedance',
'maximum_quantity_scenario_exceedance' => 'maximumQuantityScenarioExceedance',
'vehicle_equipment_violations' => 'vehicleEquipmentViolations',
'rest_position_violated' => 'restPositionViolated',
'customer_stop_position_in_trip_violated' => 'customerStopPositionInTripViolated',
'trip_section_violated' => 'tripSectionViolated',
'mixed_loading_prohibitions_violations' => 'mixedLoadingProhibitionsViolations',
'route_violated' => 'routeViolated',
'reachability_violated' => 'reachabilityViolated',
'type' => '$type'    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'maximum_opening_interval_exceedance' => 'setMaximumOpeningIntervalExceedance',
'maximum_quantity_scenario_exceedance' => 'setMaximumQuantityScenarioExceedance',
'vehicle_equipment_violations' => 'setVehicleEquipmentViolations',
'rest_position_violated' => 'setRestPositionViolated',
'customer_stop_position_in_trip_violated' => 'setCustomerStopPositionInTripViolated',
'trip_section_violated' => 'setTripSectionViolated',
'mixed_loading_prohibitions_violations' => 'setMixedLoadingProhibitionsViolations',
'route_violated' => 'setRouteViolated',
'reachability_violated' => 'setReachabilityViolated',
'type' => 'setType'    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'maximum_opening_interval_exceedance' => 'getMaximumOpeningIntervalExceedance',
'maximum_quantity_scenario_exceedance' => 'getMaximumQuantityScenarioExceedance',
'vehicle_equipment_violations' => 'getVehicleEquipmentViolations',
'rest_position_violated' => 'getRestPositionViolated',
'customer_stop_position_in_trip_violated' => 'getCustomerStopPositionInTripViolated',
'trip_section_violated' => 'getTripSectionViolated',
'mixed_loading_prohibitions_violations' => 'getMixedLoadingProhibitionsViolations',
'route_violated' => 'getRouteViolated',
'reachability_violated' => 'getReachabilityViolated',
'type' => 'getType'    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['maximum_opening_interval_exceedance'] = isset($data['maximum_opening_interval_exceedance']) ? $data['maximum_opening_interval_exceedance'] : null;
        $this->container['maximum_quantity_scenario_exceedance'] = isset($data['maximum_quantity_scenario_exceedance']) ? $data['maximum_quantity_scenario_exceedance'] : null;
        $this->container['vehicle_equipment_violations'] = isset($data['vehicle_equipment_violations']) ? $data['vehicle_equipment_violations'] : null;
        $this->container['rest_position_violated'] = isset($data['rest_position_violated']) ? $data['rest_position_violated'] : null;
        $this->container['customer_stop_position_in_trip_violated'] = isset($data['customer_stop_position_in_trip_violated']) ? $data['customer_stop_position_in_trip_violated'] : null;
        $this->container['trip_section_violated'] = isset($data['trip_section_violated']) ? $data['trip_section_violated'] : null;
        $this->container['mixed_loading_prohibitions_violations'] = isset($data['mixed_loading_prohibitions_violations']) ? $data['mixed_loading_prohibitions_violations'] : null;
        $this->container['route_violated'] = isset($data['route_violated']) ? $data['route_violated'] : null;
        $this->container['reachability_violated'] = isset($data['reachability_violated']) ? $data['reachability_violated'] : null;
        $this->container['type'] = isset($data['type']) ? $data['type'] : null;

        // Initialize discriminator property with the model name.
        $discriminator = array_search('$type', self::$attributeMap);
        $this->container[$discriminator] = static::$swaggerModelName;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['type'] === null) {
            $invalidProperties[] = "'type' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets maximum_opening_interval_exceedance
     *
     * @return \Swagger\Client\Model\Duration
     */
    public function getMaximumOpeningIntervalExceedance()
    {
        return $this->container['maximum_opening_interval_exceedance'];
    }

    /**
     * Sets maximum_opening_interval_exceedance
     *
     * @param \Swagger\Client\Model\Duration $maximum_opening_interval_exceedance maximum_opening_interval_exceedance
     *
     * @return $this
     */
    public function setMaximumOpeningIntervalExceedance($maximum_opening_interval_exceedance)
    {
        $this->container['maximum_opening_interval_exceedance'] = $maximum_opening_interval_exceedance;

        return $this;
    }

    /**
     * Gets maximum_quantity_scenario_exceedance
     *
     * @return \Swagger\Client\Model\TransportQuantityUnit[]
     */
    public function getMaximumQuantityScenarioExceedance()
    {
        return $this->container['maximum_quantity_scenario_exceedance'];
    }

    /**
     * Sets maximum_quantity_scenario_exceedance
     *
     * @param \Swagger\Client\Model\TransportQuantityUnit[] $maximum_quantity_scenario_exceedance maximum_quantity_scenario_exceedance
     *
     * @return $this
     */
    public function setMaximumQuantityScenarioExceedance($maximum_quantity_scenario_exceedance)
    {
        $this->container['maximum_quantity_scenario_exceedance'] = $maximum_quantity_scenario_exceedance;

        return $this;
    }

    /**
     * Gets vehicle_equipment_violations
     *
     * @return string[]
     */
    public function getVehicleEquipmentViolations()
    {
        return $this->container['vehicle_equipment_violations'];
    }

    /**
     * Sets vehicle_equipment_violations
     *
     * @param string[] $vehicle_equipment_violations vehicle_equipment_violations
     *
     * @return $this
     */
    public function setVehicleEquipmentViolations($vehicle_equipment_violations)
    {
        $this->container['vehicle_equipment_violations'] = $vehicle_equipment_violations;

        return $this;
    }

    /**
     * Gets rest_position_violated
     *
     * @return bool
     */
    public function getRestPositionViolated()
    {
        return $this->container['rest_position_violated'];
    }

    /**
     * Sets rest_position_violated
     *
     * @param bool $rest_position_violated Indicates if any daily rest is scheduled at an unexpected position according to possible rest positions that can for example be defined by multi day drivers' working hours.
     *
     * @return $this
     */
    public function setRestPositionViolated($rest_position_violated)
    {
        $this->container['rest_position_violated'] = $rest_position_violated;

        return $this;
    }

    /**
     * Gets customer_stop_position_in_trip_violated
     *
     * @return bool
     */
    public function getCustomerStopPositionInTripViolated()
    {
        return $this->container['customer_stop_position_in_trip_violated'];
    }

    /**
     * Sets customer_stop_position_in_trip_violated
     *
     * @param bool $customer_stop_position_in_trip_violated Indicates if any service is scheduled at an unexpected position according to the position in trip. Corresponds to tour events with violation type CUSTOMER\\_STOP\\_POSITION\\_IN\\_TRIP.
     *
     * @return $this
     */
    public function setCustomerStopPositionInTripViolated($customer_stop_position_in_trip_violated)
    {
        $this->container['customer_stop_position_in_trip_violated'] = $customer_stop_position_in_trip_violated;

        return $this;
    }

    /**
     * Gets trip_section_violated
     *
     * @return bool
     */
    public function getTripSectionViolated()
    {
        return $this->container['trip_section_violated'];
    }

    /**
     * Sets trip_section_violated
     *
     * @param bool $trip_section_violated Indicates if any service is scheduled at an unexpected position according to the trip section number. Corresponds to tour events with violation type TRIP\\_SECTION.
     *
     * @return $this
     */
    public function setTripSectionViolated($trip_section_violated)
    {
        $this->container['trip_section_violated'] = $trip_section_violated;

        return $this;
    }

    /**
     * Gets mixed_loading_prohibitions_violations
     *
     * @return \Swagger\Client\Model\MixedLoadingProhibition[]
     */
    public function getMixedLoadingProhibitionsViolations()
    {
        return $this->container['mixed_loading_prohibitions_violations'];
    }

    /**
     * Sets mixed_loading_prohibitions_violations
     *
     * @param \Swagger\Client\Model\MixedLoadingProhibition[] $mixed_loading_prohibitions_violations mixed_loading_prohibitions_violations
     *
     * @return $this
     */
    public function setMixedLoadingProhibitionsViolations($mixed_loading_prohibitions_violations)
    {
        $this->container['mixed_loading_prohibitions_violations'] = $mixed_loading_prohibitions_violations;

        return $this;
    }

    /**
     * Gets route_violated
     *
     * @return bool
     */
    public function getRouteViolated()
    {
        return $this->container['route_violated'];
    }

    /**
     * Sets route_violated
     *
     * @param bool $route_violated Indicates if at least one of the routes between two locations is violated. This violation does not occur if ignore route violations is set to true. Corresponds to tour events with violation type ROUTE.
     *
     * @return $this
     */
    public function setRouteViolated($route_violated)
    {
        $this->container['route_violated'] = $route_violated;

        return $this;
    }

    /**
     * Gets reachability_violated
     *
     * @return bool
     */
    public function getReachabilityViolated()
    {
        return $this->container['reachability_violated'];
    }

    /**
     * Sets reachability_violated
     *
     * @param bool $reachability_violated Indicates if at least one of the routes between two locations was calculated by direct distance instead of the road network. This violation does not occur if ignore reachability violations is set to false and if distance mode is not set to direct distance. Corresponds to tour events with violation type REACHABILITY.
     *
     * @return $this
     */
    public function setReachabilityViolated($reachability_violated)
    {
        $this->container['reachability_violated'] = $reachability_violated;

        return $this;
    }

    /**
     * Gets type
     *
     * @return string
     */
    public function getType()
    {
        return $this->container['type'];
    }

    /**
     * Sets type
     *
     * @param string $type type
     *
     * @return $this
     */
    public function setType($type)
    {
        $this->container['type'] = $type;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}
