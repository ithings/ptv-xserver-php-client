<?php
/**
 * PlanClustersOptions
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * xServer
 *
 * PTV xServer 2.26.0 - 2.26 API document
 *
 * OpenAPI spec version: 2.26
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.34
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;
use \Swagger\Client\ObjectSerializer;

/**
 * PlanClustersOptions Class Doc Comment
 *
 * @category Class
 * @description Input parameters for the planning algorithm. Hint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.PlanClustersOptions
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class PlanClustersOptions implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'PlanClustersOptions';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'number_of_clusters' => '\Swagger\Client\Model\PositiveInteger',
'ignore_imbalance_tolerance' => 'bool',
'imbalance_tolerance' => '\Swagger\Client\Model\Tolerance',
'optional_cluster_ids' => 'string[]',
'reduce_overlapping_in_clusters' => 'bool',
'consider_activities_as_service_times' => 'bool',
'activity_capacities' => '\Swagger\Client\Model\ActivityCapacity[]',
'activity_capacities_are_absolute' => 'bool',
'calculation_mode' => '\Swagger\Client\Model\ClusterPlanningCalculationMode',
'use_travel_distance' => 'bool'    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'number_of_clusters' => null,
'ignore_imbalance_tolerance' => null,
'imbalance_tolerance' => null,
'optional_cluster_ids' => null,
'reduce_overlapping_in_clusters' => null,
'consider_activities_as_service_times' => null,
'activity_capacities' => null,
'activity_capacities_are_absolute' => null,
'calculation_mode' => null,
'use_travel_distance' => null    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'number_of_clusters' => 'numberOfClusters',
'ignore_imbalance_tolerance' => 'ignoreImbalanceTolerance',
'imbalance_tolerance' => 'imbalanceTolerance',
'optional_cluster_ids' => 'optionalClusterIds',
'reduce_overlapping_in_clusters' => 'reduceOverlappingInClusters',
'consider_activities_as_service_times' => 'considerActivitiesAsServiceTimes',
'activity_capacities' => 'activityCapacities',
'activity_capacities_are_absolute' => 'activityCapacitiesAreAbsolute',
'calculation_mode' => 'calculationMode',
'use_travel_distance' => 'useTravelDistance'    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'number_of_clusters' => 'setNumberOfClusters',
'ignore_imbalance_tolerance' => 'setIgnoreImbalanceTolerance',
'imbalance_tolerance' => 'setImbalanceTolerance',
'optional_cluster_ids' => 'setOptionalClusterIds',
'reduce_overlapping_in_clusters' => 'setReduceOverlappingInClusters',
'consider_activities_as_service_times' => 'setConsiderActivitiesAsServiceTimes',
'activity_capacities' => 'setActivityCapacities',
'activity_capacities_are_absolute' => 'setActivityCapacitiesAreAbsolute',
'calculation_mode' => 'setCalculationMode',
'use_travel_distance' => 'setUseTravelDistance'    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'number_of_clusters' => 'getNumberOfClusters',
'ignore_imbalance_tolerance' => 'getIgnoreImbalanceTolerance',
'imbalance_tolerance' => 'getImbalanceTolerance',
'optional_cluster_ids' => 'getOptionalClusterIds',
'reduce_overlapping_in_clusters' => 'getReduceOverlappingInClusters',
'consider_activities_as_service_times' => 'getConsiderActivitiesAsServiceTimes',
'activity_capacities' => 'getActivityCapacities',
'activity_capacities_are_absolute' => 'getActivityCapacitiesAreAbsolute',
'calculation_mode' => 'getCalculationMode',
'use_travel_distance' => 'getUseTravelDistance'    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['number_of_clusters'] = isset($data['number_of_clusters']) ? $data['number_of_clusters'] : null;
        $this->container['ignore_imbalance_tolerance'] = isset($data['ignore_imbalance_tolerance']) ? $data['ignore_imbalance_tolerance'] : null;
        $this->container['imbalance_tolerance'] = isset($data['imbalance_tolerance']) ? $data['imbalance_tolerance'] : null;
        $this->container['optional_cluster_ids'] = isset($data['optional_cluster_ids']) ? $data['optional_cluster_ids'] : null;
        $this->container['reduce_overlapping_in_clusters'] = isset($data['reduce_overlapping_in_clusters']) ? $data['reduce_overlapping_in_clusters'] : null;
        $this->container['consider_activities_as_service_times'] = isset($data['consider_activities_as_service_times']) ? $data['consider_activities_as_service_times'] : null;
        $this->container['activity_capacities'] = isset($data['activity_capacities']) ? $data['activity_capacities'] : null;
        $this->container['activity_capacities_are_absolute'] = isset($data['activity_capacities_are_absolute']) ? $data['activity_capacities_are_absolute'] : null;
        $this->container['calculation_mode'] = isset($data['calculation_mode']) ? $data['calculation_mode'] : null;
        $this->container['use_travel_distance'] = isset($data['use_travel_distance']) ? $data['use_travel_distance'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['number_of_clusters'] === null) {
            $invalidProperties[] = "'number_of_clusters' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets number_of_clusters
     *
     * @return \Swagger\Client\Model\PositiveInteger
     */
    public function getNumberOfClusters()
    {
        return $this->container['number_of_clusters'];
    }

    /**
     * Sets number_of_clusters
     *
     * @param \Swagger\Client\Model\PositiveInteger $number_of_clusters number_of_clusters
     *
     * @return $this
     */
    public function setNumberOfClusters($number_of_clusters)
    {
        $this->container['number_of_clusters'] = $number_of_clusters;

        return $this;
    }

    /**
     * Gets ignore_imbalance_tolerance
     *
     * @return bool
     */
    public function getIgnoreImbalanceTolerance()
    {
        return $this->container['ignore_imbalance_tolerance'];
    }

    /**
     * Sets ignore_imbalance_tolerance
     *
     * @param bool $ignore_imbalance_tolerance If false, the imbalanceTolerance parameter will be considered by the planning algorithm. If true, the imbalanceTolerance will be ignored and a probably imbalanced solution is returned.
     *
     * @return $this
     */
    public function setIgnoreImbalanceTolerance($ignore_imbalance_tolerance)
    {
        $this->container['ignore_imbalance_tolerance'] = $ignore_imbalance_tolerance;

        return $this;
    }

    /**
     * Gets imbalance_tolerance
     *
     * @return \Swagger\Client\Model\Tolerance
     */
    public function getImbalanceTolerance()
    {
        return $this->container['imbalance_tolerance'];
    }

    /**
     * Sets imbalance_tolerance
     *
     * @param \Swagger\Client\Model\Tolerance $imbalance_tolerance imbalance_tolerance
     *
     * @return $this
     */
    public function setImbalanceTolerance($imbalance_tolerance)
    {
        $this->container['imbalance_tolerance'] = $imbalance_tolerance;

        return $this;
    }

    /**
     * Gets optional_cluster_ids
     *
     * @return string[]
     */
    public function getOptionalClusterIds()
    {
        return $this->container['optional_cluster_ids'];
    }

    /**
     * Sets optional_cluster_ids
     *
     * @param string[] $optional_cluster_ids optional_cluster_ids
     *
     * @return $this
     */
    public function setOptionalClusterIds($optional_cluster_ids)
    {
        $this->container['optional_cluster_ids'] = $optional_cluster_ids;

        return $this;
    }

    /**
     * Gets reduce_overlapping_in_clusters
     *
     * @return bool
     */
    public function getReduceOverlappingInClusters()
    {
        return $this->container['reduce_overlapping_in_clusters'];
    }

    /**
     * Sets reduce_overlapping_in_clusters
     *
     * @param bool $reduce_overlapping_in_clusters Clusters are always optimized towards compactness and towards minimal driving times from the reference point to each location. Depending on the routing profile used for driving time calculation, clusters may be stretched along major roads and it is possible that two clusters visually overlap. Furthermore, a high variance among activities might also lead to overlaps. If reduceOverlappingInClusters is set to true, the algorithm tries to reduce overlapping among clusters. If there is no valid solution that avoids overlapping clusters, a valid solution with overlapping clusters is returned. Setting this parameter to true usually increases runtime because additional steps have to be executed. In addition, the activity-imbalance among clusters and the overall driving time per cluster may increase.
     *
     * @return $this
     */
    public function setReduceOverlappingInClusters($reduce_overlapping_in_clusters)
    {
        $this->container['reduce_overlapping_in_clusters'] = $reduce_overlapping_in_clusters;

        return $this;
    }

    /**
     * Gets consider_activities_as_service_times
     *
     * @return bool
     */
    public function getConsiderActivitiesAsServiceTimes()
    {
        return $this->container['consider_activities_as_service_times'];
    }

    /**
     * Sets consider_activities_as_service_times
     *
     * @param bool $consider_activities_as_service_times If this parameter is set to true, all activity values set at a location are considered to be service times in seconds. Using service periods as activity means that estimated tour durations are balanced for each cluster instead of the total sum of activity. Therefore the value of ClusterReport.totalActivity represents the estimated tour duration for the corresponding cluster.
     *
     * @return $this
     */
    public function setConsiderActivitiesAsServiceTimes($consider_activities_as_service_times)
    {
        $this->container['consider_activities_as_service_times'] = $consider_activities_as_service_times;

        return $this;
    }

    /**
     * Gets activity_capacities
     *
     * @return \Swagger\Client\Model\ActivityCapacity[]
     */
    public function getActivityCapacities()
    {
        return $this->container['activity_capacities'];
    }

    /**
     * Sets activity_capacities
     *
     * @param \Swagger\Client\Model\ActivityCapacity[] $activity_capacities activity_capacities
     *
     * @return $this
     */
    public function setActivityCapacities($activity_capacities)
    {
        $this->container['activity_capacities'] = $activity_capacities;

        return $this;
    }

    /**
     * Gets activity_capacities_are_absolute
     *
     * @return bool
     */
    public function getActivityCapacitiesAreAbsolute()
    {
        return $this->container['activity_capacities_are_absolute'];
    }

    /**
     * Sets activity_capacities_are_absolute
     *
     * @param bool $activity_capacities_are_absolute This feature can be used only when clusters are specified. If set to true, activity capacities are taken as absolute upper bounds for specified clusters according to their input sequence. The parameter imbalanceTolerance does not play any role. This means, it could happen, that a planning location remains unplanned in the end. Furthermore, it could happen, that a cluster facility is not allocated to any planning location, i.e. the respective ClusterReport.numberOfLocations is zero and the respective ClusteredLocations.locationIds is empty.
     *
     * @return $this
     */
    public function setActivityCapacitiesAreAbsolute($activity_capacities_are_absolute)
    {
        $this->container['activity_capacities_are_absolute'] = $activity_capacities_are_absolute;

        return $this;
    }

    /**
     * Gets calculation_mode
     *
     * @return \Swagger\Client\Model\ClusterPlanningCalculationMode
     */
    public function getCalculationMode()
    {
        return $this->container['calculation_mode'];
    }

    /**
     * Sets calculation_mode
     *
     * @param \Swagger\Client\Model\ClusterPlanningCalculationMode $calculation_mode calculation_mode
     *
     * @return $this
     */
    public function setCalculationMode($calculation_mode)
    {
        $this->container['calculation_mode'] = $calculation_mode;

        return $this;
    }

    /**
     * Gets use_travel_distance
     *
     * @return bool
     */
    public function getUseTravelDistance()
    {
        return $this->container['use_travel_distance'];
    }

    /**
     * Sets use_travel_distance
     *
     * @param bool $use_travel_distance If set to true, travel distances and not travel times are used for calculations. The value of this parameter coupled with the choice of DistanceMode in PlanClustersRequest affects the result obtained in response.
     *
     * @return $this
     */
    public function setUseTravelDistance($use_travel_distance)
    {
        $this->container['use_travel_distance'] = $use_travel_distance;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}
