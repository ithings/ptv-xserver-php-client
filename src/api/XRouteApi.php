<?php
/**
 * XRouteApi
 * PHP version 5
 *
 * @category Class
 * @package  ithings\ptvxserver
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * xServer
 *
 * PTV xServer 2.26.1 - 2.26 API document
 *
 * OpenAPI spec version: 2.26
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.34
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace ithings\ptvxserver\api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use ithings\ptvxserver\ApiException;
use ithings\ptvxserver\Configuration;
use ithings\ptvxserver\HeaderSelector;
use ithings\ptvxserver\ObjectSerializer;

/**
 * XRouteApi Class Doc Comment
 *
 * @category Class
 * @package  ithings\ptvxserver
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class XRouteApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation calculateReachableAreas
     *
     * @param  \ithings\ptvxserver\model\ReachableAreasRequest $body body (required)
     *
     * @throws \ithings\ptvxserver\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ithings\ptvxserver\model\ReachableAreasResponse
     */
    public function calculateReachableAreas($body)
    {
        list($response) = $this->calculateReachableAreasWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation calculateReachableAreasWithHttpInfo
     *
     * @param  \ithings\ptvxserver\model\ReachableAreasRequest $body (required)
     *
     * @throws \ithings\ptvxserver\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ithings\ptvxserver\model\ReachableAreasResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function calculateReachableAreasWithHttpInfo($body)
    {
        $returnType = '\ithings\ptvxserver\model\ReachableAreasResponse';
        $request = $this->calculateReachableAreasRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ithings\ptvxserver\model\ReachableAreasResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ithings\ptvxserver\model\XServerError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation calculateReachableAreasAsync
     *
     * 
     *
     * @param  \ithings\ptvxserver\model\ReachableAreasRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function calculateReachableAreasAsync($body)
    {
        return $this->calculateReachableAreasAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation calculateReachableAreasAsyncWithHttpInfo
     *
     * 
     *
     * @param  \ithings\ptvxserver\model\ReachableAreasRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function calculateReachableAreasAsyncWithHttpInfo($body)
    {
        $returnType = '\ithings\ptvxserver\model\ReachableAreasResponse';
        $request = $this->calculateReachableAreasRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'calculateReachableAreas'
     *
     * @param  \ithings\ptvxserver\model\ReachableAreasRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function calculateReachableAreasRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling calculateReachableAreas'
            );
        }

        $resourcePath = '/services/rs/XRoute/2.26/calculateReachableAreas';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation calculateReachableLocations
     *
     * @param  \ithings\ptvxserver\model\ReachableLocationsRequest $body body (required)
     *
     * @throws \ithings\ptvxserver\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ithings\ptvxserver\model\ReachableLocationsResponse
     */
    public function calculateReachableLocations($body)
    {
        list($response) = $this->calculateReachableLocationsWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation calculateReachableLocationsWithHttpInfo
     *
     * @param  \ithings\ptvxserver\model\ReachableLocationsRequest $body (required)
     *
     * @throws \ithings\ptvxserver\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ithings\ptvxserver\model\ReachableLocationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function calculateReachableLocationsWithHttpInfo($body)
    {
        $returnType = '\ithings\ptvxserver\model\ReachableLocationsResponse';
        $request = $this->calculateReachableLocationsRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ithings\ptvxserver\model\ReachableLocationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ithings\ptvxserver\model\XServerError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation calculateReachableLocationsAsync
     *
     * 
     *
     * @param  \ithings\ptvxserver\model\ReachableLocationsRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function calculateReachableLocationsAsync($body)
    {
        return $this->calculateReachableLocationsAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation calculateReachableLocationsAsyncWithHttpInfo
     *
     * 
     *
     * @param  \ithings\ptvxserver\model\ReachableLocationsRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function calculateReachableLocationsAsyncWithHttpInfo($body)
    {
        $returnType = '\ithings\ptvxserver\model\ReachableLocationsResponse';
        $request = $this->calculateReachableLocationsRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'calculateReachableLocations'
     *
     * @param  \ithings\ptvxserver\model\ReachableLocationsRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function calculateReachableLocationsRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling calculateReachableLocations'
            );
        }

        $resourcePath = '/services/rs/XRoute/2.26/calculateReachableLocations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation calculateRoute
     *
     * @param  \ithings\ptvxserver\model\RouteRequest $body body (required)
     *
     * @throws \ithings\ptvxserver\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ithings\ptvxserver\model\RouteResponse
     */
    public function calculateRoute($body)
    {
        list($response) = $this->calculateRouteWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation calculateRouteWithHttpInfo
     *
     * @param  \ithings\ptvxserver\model\RouteRequest $body (required)
     *
     * @throws \ithings\ptvxserver\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ithings\ptvxserver\model\RouteResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function calculateRouteWithHttpInfo($body)
    {
        $returnType = '\ithings\ptvxserver\model\RouteResponse';
        $request = $this->calculateRouteRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ithings\ptvxserver\model\RouteResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ithings\ptvxserver\model\XServerError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation calculateRouteAsync
     *
     * 
     *
     * @param  \ithings\ptvxserver\model\RouteRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function calculateRouteAsync($body)
    {
        return $this->calculateRouteAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation calculateRouteAsyncWithHttpInfo
     *
     * 
     *
     * @param  \ithings\ptvxserver\model\RouteRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function calculateRouteAsyncWithHttpInfo($body)
    {
        $returnType = '\ithings\ptvxserver\model\RouteResponse';
        $request = $this->calculateRouteRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'calculateRoute'
     *
     * @param  \ithings\ptvxserver\model\RouteRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function calculateRouteRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling calculateRoute'
            );
        }

        $resourcePath = '/services/rs/XRoute/2.26/calculateRoute';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation fetchReachableAreasResponse
     *
     * @param  \ithings\ptvxserver\model\JobRequest $body body (required)
     *
     * @throws \ithings\ptvxserver\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ithings\ptvxserver\model\ReachableAreasResponse
     */
    public function fetchReachableAreasResponse($body)
    {
        list($response) = $this->fetchReachableAreasResponseWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation fetchReachableAreasResponseWithHttpInfo
     *
     * @param  \ithings\ptvxserver\model\JobRequest $body (required)
     *
     * @throws \ithings\ptvxserver\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ithings\ptvxserver\model\ReachableAreasResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function fetchReachableAreasResponseWithHttpInfo($body)
    {
        $returnType = '\ithings\ptvxserver\model\ReachableAreasResponse';
        $request = $this->fetchReachableAreasResponseRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ithings\ptvxserver\model\ReachableAreasResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ithings\ptvxserver\model\XServerError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation fetchReachableAreasResponseAsync
     *
     * 
     *
     * @param  \ithings\ptvxserver\model\JobRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fetchReachableAreasResponseAsync($body)
    {
        return $this->fetchReachableAreasResponseAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation fetchReachableAreasResponseAsyncWithHttpInfo
     *
     * 
     *
     * @param  \ithings\ptvxserver\model\JobRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fetchReachableAreasResponseAsyncWithHttpInfo($body)
    {
        $returnType = '\ithings\ptvxserver\model\ReachableAreasResponse';
        $request = $this->fetchReachableAreasResponseRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fetchReachableAreasResponse'
     *
     * @param  \ithings\ptvxserver\model\JobRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function fetchReachableAreasResponseRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling fetchReachableAreasResponse'
            );
        }

        $resourcePath = '/services/rs/XRoute/2.26/fetchReachableAreasResponse';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation fetchReachableLocationsResponse
     *
     * @param  \ithings\ptvxserver\model\JobRequest $body body (required)
     *
     * @throws \ithings\ptvxserver\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ithings\ptvxserver\model\ReachableLocationsResponse
     */
    public function fetchReachableLocationsResponse($body)
    {
        list($response) = $this->fetchReachableLocationsResponseWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation fetchReachableLocationsResponseWithHttpInfo
     *
     * @param  \ithings\ptvxserver\model\JobRequest $body (required)
     *
     * @throws \ithings\ptvxserver\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ithings\ptvxserver\model\ReachableLocationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function fetchReachableLocationsResponseWithHttpInfo($body)
    {
        $returnType = '\ithings\ptvxserver\model\ReachableLocationsResponse';
        $request = $this->fetchReachableLocationsResponseRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ithings\ptvxserver\model\ReachableLocationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ithings\ptvxserver\model\XServerError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation fetchReachableLocationsResponseAsync
     *
     * 
     *
     * @param  \ithings\ptvxserver\model\JobRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fetchReachableLocationsResponseAsync($body)
    {
        return $this->fetchReachableLocationsResponseAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation fetchReachableLocationsResponseAsyncWithHttpInfo
     *
     * 
     *
     * @param  \ithings\ptvxserver\model\JobRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fetchReachableLocationsResponseAsyncWithHttpInfo($body)
    {
        $returnType = '\ithings\ptvxserver\model\ReachableLocationsResponse';
        $request = $this->fetchReachableLocationsResponseRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fetchReachableLocationsResponse'
     *
     * @param  \ithings\ptvxserver\model\JobRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function fetchReachableLocationsResponseRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling fetchReachableLocationsResponse'
            );
        }

        $resourcePath = '/services/rs/XRoute/2.26/fetchReachableLocationsResponse';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation fetchRouteResponse
     *
     * @param  \ithings\ptvxserver\model\JobRequest $body body (required)
     *
     * @throws \ithings\ptvxserver\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ithings\ptvxserver\model\RouteResponse
     */
    public function fetchRouteResponse($body)
    {
        list($response) = $this->fetchRouteResponseWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation fetchRouteResponseWithHttpInfo
     *
     * @param  \ithings\ptvxserver\model\JobRequest $body (required)
     *
     * @throws \ithings\ptvxserver\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ithings\ptvxserver\model\RouteResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function fetchRouteResponseWithHttpInfo($body)
    {
        $returnType = '\ithings\ptvxserver\model\RouteResponse';
        $request = $this->fetchRouteResponseRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ithings\ptvxserver\model\RouteResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ithings\ptvxserver\model\XServerError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation fetchRouteResponseAsync
     *
     * 
     *
     * @param  \ithings\ptvxserver\model\JobRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fetchRouteResponseAsync($body)
    {
        return $this->fetchRouteResponseAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation fetchRouteResponseAsyncWithHttpInfo
     *
     * 
     *
     * @param  \ithings\ptvxserver\model\JobRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fetchRouteResponseAsyncWithHttpInfo($body)
    {
        $returnType = '\ithings\ptvxserver\model\RouteResponse';
        $request = $this->fetchRouteResponseRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fetchRouteResponse'
     *
     * @param  \ithings\ptvxserver\model\JobRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function fetchRouteResponseRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling fetchRouteResponse'
            );
        }

        $resourcePath = '/services/rs/XRoute/2.26/fetchRouteResponse';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProfile
     *
     * @param  \ithings\ptvxserver\model\ProfileRequest $body body (required)
     *
     * @throws \ithings\ptvxserver\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ithings\ptvxserver\model\ProfileResponse
     */
    public function getProfile($body)
    {
        list($response) = $this->getProfileWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation getProfileWithHttpInfo
     *
     * @param  \ithings\ptvxserver\model\ProfileRequest $body (required)
     *
     * @throws \ithings\ptvxserver\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ithings\ptvxserver\model\ProfileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProfileWithHttpInfo($body)
    {
        $returnType = '\ithings\ptvxserver\model\ProfileResponse';
        $request = $this->getProfileRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ithings\ptvxserver\model\ProfileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ithings\ptvxserver\model\XServerError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProfileAsync
     *
     * 
     *
     * @param  \ithings\ptvxserver\model\ProfileRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProfileAsync($body)
    {
        return $this->getProfileAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProfileAsyncWithHttpInfo
     *
     * 
     *
     * @param  \ithings\ptvxserver\model\ProfileRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProfileAsyncWithHttpInfo($body)
    {
        $returnType = '\ithings\ptvxserver\model\ProfileResponse';
        $request = $this->getProfileRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProfile'
     *
     * @param  \ithings\ptvxserver\model\ProfileRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getProfileRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling getProfile'
            );
        }

        $resourcePath = '/services/rs/XRoute/2.26/getProfile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation route
     *
     * @param  double $start_x The longitude in WGS84 (EPSG:4326) of the start location. The location is interpreted as an routing.OnRoadRouteLocation. (required)
     * @param  double $start_y The latitude in WGS84 (EPSG:4326) of the start location. The location is interpreted as an routing.OnRoadRouteLocation. (required)
     * @param  double $destination_x The longitude in WGS84 (EPSG:4326) of the destination location. The location is interpreted as an routing.OnRoadRouteLocation. (required)
     * @param  double $destination_y The latitude in WGS84 (EPSG:4326) of the destination location. The location is interpreted as an routing.OnRoadRouteLocation. (required)
     * @param  string $stored_profile The name of the stored profile to use without its extension, e.g. &#x60;bicycle&#x60;. The corresponding file &#x60;bicycle.xml&#x60; must be available in the folder &#x60;conf/profiles&#x60;. Parent profiles must be located in the same folder. (optional)
     * @param  bool $polyline Specifies if the RouteResponse.polyline shall be returned for the complete route. (optional)
     * @param  string $theme_ids A comma-separated list of Feature Layer theme IDs which will be considered. If this parameter is specified, themes enabled in the stored profile are ignored. These themes can be any of the supported Feature Layer themes, such as &#x60;PTV_TruckAttributes&#x60;. If this parameter is not present, the themes defined by the stored profile are used. A trailing comma is permitted. For more information see Calculating the Best Route for Rush Hour Traffic and Considering Long-term Blockings. (optional)
     * @param  string $preferred_route_types The road networks to be preferred by the routing algorithm as a comma-separated list (only if the Feature Layer PTV\\_PreferredRoutes is enabled). The available types can be requested through the xRuntime service and are documented in the manual as layer-specific properties of the Feature Layer PTV\\_PreferredRoutes. If this parameter is not present, all types of PTV\\_PreferredRoutes are displayed. (optional)
     * @param  string $time_consideration Specifies how to evaluate Feature Layer attributes which contain time restrictions. For time consideration scenario &#x60;NONE&#x60; the parameters for reference time and timespan are not evaluated. For &#x60;SNAPSHOT&#x60;, &#x60;TIME_SPAN&#x60;, &#x60;EXACT_TIME_AT_START&#x60; and &#x60;EXACT_TIME_AT_ARRIVAL&#x60; the reference time is required. The time span is needed for the &#x60;TIME_SPAN&#x60; scenarios. For detailed information about time consideration scenarios see time consideration. (optional)
     * @param  \DateTime $reference_time The reference time at which Feature Layer attributes with time restrictions will be evaluated. The time format either has to conform to the notation of xs:dateTime such as 2015-12-24T12:00:00+01:00, or it has to be a datetime sequence without any delimiters nor time zone specification such as 20151224T120000. If the time-zone offset is missing, the corresponding service tries to detect it by means of information available in the calling context. A detailed description of this behavior can be found in the technical concept time zones. It is recommended to always specify the time zone. If no reference time is set, the current UTC time is used. (optional)
     * @param  double $time_span The duration of time (in combination with reference time as start) at which Feature Layer attributes with time restrictions will be evaluated, defined in \\[s\\]. The value is rounded to whole seconds. (optional)
     * @param  string $content_snapshot_id Specifies the content snapshot to use. If no snapshot ID is set, the most recent content is used. (optional)
     *
     * @throws \ithings\ptvxserver\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ithings\ptvxserver\model\RouteResponse
     */
    public function route($start_x, $start_y, $destination_x, $destination_y, $stored_profile = null, $polyline = null, $theme_ids = null, $preferred_route_types = null, $time_consideration = null, $reference_time = null, $time_span = null, $content_snapshot_id = null)
    {
        list($response) = $this->routeWithHttpInfo($start_x, $start_y, $destination_x, $destination_y, $stored_profile, $polyline, $theme_ids, $preferred_route_types, $time_consideration, $reference_time, $time_span, $content_snapshot_id);
        return $response;
    }

    /**
     * Operation routeWithHttpInfo
     *
     * @param  double $start_x The longitude in WGS84 (EPSG:4326) of the start location. The location is interpreted as an routing.OnRoadRouteLocation. (required)
     * @param  double $start_y The latitude in WGS84 (EPSG:4326) of the start location. The location is interpreted as an routing.OnRoadRouteLocation. (required)
     * @param  double $destination_x The longitude in WGS84 (EPSG:4326) of the destination location. The location is interpreted as an routing.OnRoadRouteLocation. (required)
     * @param  double $destination_y The latitude in WGS84 (EPSG:4326) of the destination location. The location is interpreted as an routing.OnRoadRouteLocation. (required)
     * @param  string $stored_profile The name of the stored profile to use without its extension, e.g. &#x60;bicycle&#x60;. The corresponding file &#x60;bicycle.xml&#x60; must be available in the folder &#x60;conf/profiles&#x60;. Parent profiles must be located in the same folder. (optional)
     * @param  bool $polyline Specifies if the RouteResponse.polyline shall be returned for the complete route. (optional)
     * @param  string $theme_ids A comma-separated list of Feature Layer theme IDs which will be considered. If this parameter is specified, themes enabled in the stored profile are ignored. These themes can be any of the supported Feature Layer themes, such as &#x60;PTV_TruckAttributes&#x60;. If this parameter is not present, the themes defined by the stored profile are used. A trailing comma is permitted. For more information see Calculating the Best Route for Rush Hour Traffic and Considering Long-term Blockings. (optional)
     * @param  string $preferred_route_types The road networks to be preferred by the routing algorithm as a comma-separated list (only if the Feature Layer PTV\\_PreferredRoutes is enabled). The available types can be requested through the xRuntime service and are documented in the manual as layer-specific properties of the Feature Layer PTV\\_PreferredRoutes. If this parameter is not present, all types of PTV\\_PreferredRoutes are displayed. (optional)
     * @param  string $time_consideration Specifies how to evaluate Feature Layer attributes which contain time restrictions. For time consideration scenario &#x60;NONE&#x60; the parameters for reference time and timespan are not evaluated. For &#x60;SNAPSHOT&#x60;, &#x60;TIME_SPAN&#x60;, &#x60;EXACT_TIME_AT_START&#x60; and &#x60;EXACT_TIME_AT_ARRIVAL&#x60; the reference time is required. The time span is needed for the &#x60;TIME_SPAN&#x60; scenarios. For detailed information about time consideration scenarios see time consideration. (optional)
     * @param  \DateTime $reference_time The reference time at which Feature Layer attributes with time restrictions will be evaluated. The time format either has to conform to the notation of xs:dateTime such as 2015-12-24T12:00:00+01:00, or it has to be a datetime sequence without any delimiters nor time zone specification such as 20151224T120000. If the time-zone offset is missing, the corresponding service tries to detect it by means of information available in the calling context. A detailed description of this behavior can be found in the technical concept time zones. It is recommended to always specify the time zone. If no reference time is set, the current UTC time is used. (optional)
     * @param  double $time_span The duration of time (in combination with reference time as start) at which Feature Layer attributes with time restrictions will be evaluated, defined in \\[s\\]. The value is rounded to whole seconds. (optional)
     * @param  string $content_snapshot_id Specifies the content snapshot to use. If no snapshot ID is set, the most recent content is used. (optional)
     *
     * @throws \ithings\ptvxserver\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ithings\ptvxserver\model\RouteResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function routeWithHttpInfo($start_x, $start_y, $destination_x, $destination_y, $stored_profile = null, $polyline = null, $theme_ids = null, $preferred_route_types = null, $time_consideration = null, $reference_time = null, $time_span = null, $content_snapshot_id = null)
    {
        $returnType = '\ithings\ptvxserver\model\RouteResponse';
        $request = $this->routeRequest($start_x, $start_y, $destination_x, $destination_y, $stored_profile, $polyline, $theme_ids, $preferred_route_types, $time_consideration, $reference_time, $time_span, $content_snapshot_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ithings\ptvxserver\model\RouteResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ithings\ptvxserver\model\XServerError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation routeAsync
     *
     * 
     *
     * @param  double $start_x The longitude in WGS84 (EPSG:4326) of the start location. The location is interpreted as an routing.OnRoadRouteLocation. (required)
     * @param  double $start_y The latitude in WGS84 (EPSG:4326) of the start location. The location is interpreted as an routing.OnRoadRouteLocation. (required)
     * @param  double $destination_x The longitude in WGS84 (EPSG:4326) of the destination location. The location is interpreted as an routing.OnRoadRouteLocation. (required)
     * @param  double $destination_y The latitude in WGS84 (EPSG:4326) of the destination location. The location is interpreted as an routing.OnRoadRouteLocation. (required)
     * @param  string $stored_profile The name of the stored profile to use without its extension, e.g. &#x60;bicycle&#x60;. The corresponding file &#x60;bicycle.xml&#x60; must be available in the folder &#x60;conf/profiles&#x60;. Parent profiles must be located in the same folder. (optional)
     * @param  bool $polyline Specifies if the RouteResponse.polyline shall be returned for the complete route. (optional)
     * @param  string $theme_ids A comma-separated list of Feature Layer theme IDs which will be considered. If this parameter is specified, themes enabled in the stored profile are ignored. These themes can be any of the supported Feature Layer themes, such as &#x60;PTV_TruckAttributes&#x60;. If this parameter is not present, the themes defined by the stored profile are used. A trailing comma is permitted. For more information see Calculating the Best Route for Rush Hour Traffic and Considering Long-term Blockings. (optional)
     * @param  string $preferred_route_types The road networks to be preferred by the routing algorithm as a comma-separated list (only if the Feature Layer PTV\\_PreferredRoutes is enabled). The available types can be requested through the xRuntime service and are documented in the manual as layer-specific properties of the Feature Layer PTV\\_PreferredRoutes. If this parameter is not present, all types of PTV\\_PreferredRoutes are displayed. (optional)
     * @param  string $time_consideration Specifies how to evaluate Feature Layer attributes which contain time restrictions. For time consideration scenario &#x60;NONE&#x60; the parameters for reference time and timespan are not evaluated. For &#x60;SNAPSHOT&#x60;, &#x60;TIME_SPAN&#x60;, &#x60;EXACT_TIME_AT_START&#x60; and &#x60;EXACT_TIME_AT_ARRIVAL&#x60; the reference time is required. The time span is needed for the &#x60;TIME_SPAN&#x60; scenarios. For detailed information about time consideration scenarios see time consideration. (optional)
     * @param  \DateTime $reference_time The reference time at which Feature Layer attributes with time restrictions will be evaluated. The time format either has to conform to the notation of xs:dateTime such as 2015-12-24T12:00:00+01:00, or it has to be a datetime sequence without any delimiters nor time zone specification such as 20151224T120000. If the time-zone offset is missing, the corresponding service tries to detect it by means of information available in the calling context. A detailed description of this behavior can be found in the technical concept time zones. It is recommended to always specify the time zone. If no reference time is set, the current UTC time is used. (optional)
     * @param  double $time_span The duration of time (in combination with reference time as start) at which Feature Layer attributes with time restrictions will be evaluated, defined in \\[s\\]. The value is rounded to whole seconds. (optional)
     * @param  string $content_snapshot_id Specifies the content snapshot to use. If no snapshot ID is set, the most recent content is used. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function routeAsync($start_x, $start_y, $destination_x, $destination_y, $stored_profile = null, $polyline = null, $theme_ids = null, $preferred_route_types = null, $time_consideration = null, $reference_time = null, $time_span = null, $content_snapshot_id = null)
    {
        return $this->routeAsyncWithHttpInfo($start_x, $start_y, $destination_x, $destination_y, $stored_profile, $polyline, $theme_ids, $preferred_route_types, $time_consideration, $reference_time, $time_span, $content_snapshot_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation routeAsyncWithHttpInfo
     *
     * 
     *
     * @param  double $start_x The longitude in WGS84 (EPSG:4326) of the start location. The location is interpreted as an routing.OnRoadRouteLocation. (required)
     * @param  double $start_y The latitude in WGS84 (EPSG:4326) of the start location. The location is interpreted as an routing.OnRoadRouteLocation. (required)
     * @param  double $destination_x The longitude in WGS84 (EPSG:4326) of the destination location. The location is interpreted as an routing.OnRoadRouteLocation. (required)
     * @param  double $destination_y The latitude in WGS84 (EPSG:4326) of the destination location. The location is interpreted as an routing.OnRoadRouteLocation. (required)
     * @param  string $stored_profile The name of the stored profile to use without its extension, e.g. &#x60;bicycle&#x60;. The corresponding file &#x60;bicycle.xml&#x60; must be available in the folder &#x60;conf/profiles&#x60;. Parent profiles must be located in the same folder. (optional)
     * @param  bool $polyline Specifies if the RouteResponse.polyline shall be returned for the complete route. (optional)
     * @param  string $theme_ids A comma-separated list of Feature Layer theme IDs which will be considered. If this parameter is specified, themes enabled in the stored profile are ignored. These themes can be any of the supported Feature Layer themes, such as &#x60;PTV_TruckAttributes&#x60;. If this parameter is not present, the themes defined by the stored profile are used. A trailing comma is permitted. For more information see Calculating the Best Route for Rush Hour Traffic and Considering Long-term Blockings. (optional)
     * @param  string $preferred_route_types The road networks to be preferred by the routing algorithm as a comma-separated list (only if the Feature Layer PTV\\_PreferredRoutes is enabled). The available types can be requested through the xRuntime service and are documented in the manual as layer-specific properties of the Feature Layer PTV\\_PreferredRoutes. If this parameter is not present, all types of PTV\\_PreferredRoutes are displayed. (optional)
     * @param  string $time_consideration Specifies how to evaluate Feature Layer attributes which contain time restrictions. For time consideration scenario &#x60;NONE&#x60; the parameters for reference time and timespan are not evaluated. For &#x60;SNAPSHOT&#x60;, &#x60;TIME_SPAN&#x60;, &#x60;EXACT_TIME_AT_START&#x60; and &#x60;EXACT_TIME_AT_ARRIVAL&#x60; the reference time is required. The time span is needed for the &#x60;TIME_SPAN&#x60; scenarios. For detailed information about time consideration scenarios see time consideration. (optional)
     * @param  \DateTime $reference_time The reference time at which Feature Layer attributes with time restrictions will be evaluated. The time format either has to conform to the notation of xs:dateTime such as 2015-12-24T12:00:00+01:00, or it has to be a datetime sequence without any delimiters nor time zone specification such as 20151224T120000. If the time-zone offset is missing, the corresponding service tries to detect it by means of information available in the calling context. A detailed description of this behavior can be found in the technical concept time zones. It is recommended to always specify the time zone. If no reference time is set, the current UTC time is used. (optional)
     * @param  double $time_span The duration of time (in combination with reference time as start) at which Feature Layer attributes with time restrictions will be evaluated, defined in \\[s\\]. The value is rounded to whole seconds. (optional)
     * @param  string $content_snapshot_id Specifies the content snapshot to use. If no snapshot ID is set, the most recent content is used. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function routeAsyncWithHttpInfo($start_x, $start_y, $destination_x, $destination_y, $stored_profile = null, $polyline = null, $theme_ids = null, $preferred_route_types = null, $time_consideration = null, $reference_time = null, $time_span = null, $content_snapshot_id = null)
    {
        $returnType = '\ithings\ptvxserver\model\RouteResponse';
        $request = $this->routeRequest($start_x, $start_y, $destination_x, $destination_y, $stored_profile, $polyline, $theme_ids, $preferred_route_types, $time_consideration, $reference_time, $time_span, $content_snapshot_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'route'
     *
     * @param  double $start_x The longitude in WGS84 (EPSG:4326) of the start location. The location is interpreted as an routing.OnRoadRouteLocation. (required)
     * @param  double $start_y The latitude in WGS84 (EPSG:4326) of the start location. The location is interpreted as an routing.OnRoadRouteLocation. (required)
     * @param  double $destination_x The longitude in WGS84 (EPSG:4326) of the destination location. The location is interpreted as an routing.OnRoadRouteLocation. (required)
     * @param  double $destination_y The latitude in WGS84 (EPSG:4326) of the destination location. The location is interpreted as an routing.OnRoadRouteLocation. (required)
     * @param  string $stored_profile The name of the stored profile to use without its extension, e.g. &#x60;bicycle&#x60;. The corresponding file &#x60;bicycle.xml&#x60; must be available in the folder &#x60;conf/profiles&#x60;. Parent profiles must be located in the same folder. (optional)
     * @param  bool $polyline Specifies if the RouteResponse.polyline shall be returned for the complete route. (optional)
     * @param  string $theme_ids A comma-separated list of Feature Layer theme IDs which will be considered. If this parameter is specified, themes enabled in the stored profile are ignored. These themes can be any of the supported Feature Layer themes, such as &#x60;PTV_TruckAttributes&#x60;. If this parameter is not present, the themes defined by the stored profile are used. A trailing comma is permitted. For more information see Calculating the Best Route for Rush Hour Traffic and Considering Long-term Blockings. (optional)
     * @param  string $preferred_route_types The road networks to be preferred by the routing algorithm as a comma-separated list (only if the Feature Layer PTV\\_PreferredRoutes is enabled). The available types can be requested through the xRuntime service and are documented in the manual as layer-specific properties of the Feature Layer PTV\\_PreferredRoutes. If this parameter is not present, all types of PTV\\_PreferredRoutes are displayed. (optional)
     * @param  string $time_consideration Specifies how to evaluate Feature Layer attributes which contain time restrictions. For time consideration scenario &#x60;NONE&#x60; the parameters for reference time and timespan are not evaluated. For &#x60;SNAPSHOT&#x60;, &#x60;TIME_SPAN&#x60;, &#x60;EXACT_TIME_AT_START&#x60; and &#x60;EXACT_TIME_AT_ARRIVAL&#x60; the reference time is required. The time span is needed for the &#x60;TIME_SPAN&#x60; scenarios. For detailed information about time consideration scenarios see time consideration. (optional)
     * @param  \DateTime $reference_time The reference time at which Feature Layer attributes with time restrictions will be evaluated. The time format either has to conform to the notation of xs:dateTime such as 2015-12-24T12:00:00+01:00, or it has to be a datetime sequence without any delimiters nor time zone specification such as 20151224T120000. If the time-zone offset is missing, the corresponding service tries to detect it by means of information available in the calling context. A detailed description of this behavior can be found in the technical concept time zones. It is recommended to always specify the time zone. If no reference time is set, the current UTC time is used. (optional)
     * @param  double $time_span The duration of time (in combination with reference time as start) at which Feature Layer attributes with time restrictions will be evaluated, defined in \\[s\\]. The value is rounded to whole seconds. (optional)
     * @param  string $content_snapshot_id Specifies the content snapshot to use. If no snapshot ID is set, the most recent content is used. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function routeRequest($start_x, $start_y, $destination_x, $destination_y, $stored_profile = null, $polyline = null, $theme_ids = null, $preferred_route_types = null, $time_consideration = null, $reference_time = null, $time_span = null, $content_snapshot_id = null)
    {
        // verify the required parameter 'start_x' is set
        if ($start_x === null || (is_array($start_x) && count($start_x) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start_x when calling route'
            );
        }
        // verify the required parameter 'start_y' is set
        if ($start_y === null || (is_array($start_y) && count($start_y) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start_y when calling route'
            );
        }
        // verify the required parameter 'destination_x' is set
        if ($destination_x === null || (is_array($destination_x) && count($destination_x) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destination_x when calling route'
            );
        }
        // verify the required parameter 'destination_y' is set
        if ($destination_y === null || (is_array($destination_y) && count($destination_y) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destination_y when calling route'
            );
        }

        $resourcePath = '/services/rest/XRoute/2.26/route/{startX}/{startY}/{destinationX}/{destinationY}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($stored_profile !== null) {
            $queryParams['storedProfile'] = ObjectSerializer::toQueryValue($stored_profile, null);
        }
        // query params
        if ($polyline !== null) {
            $queryParams['polyline'] = ObjectSerializer::toQueryValue($polyline, null);
        }
        // query params
        if ($theme_ids !== null) {
            $queryParams['themeIds'] = ObjectSerializer::toQueryValue($theme_ids, null);
        }
        // query params
        if ($preferred_route_types !== null) {
            $queryParams['preferredRouteTypes'] = ObjectSerializer::toQueryValue($preferred_route_types, null);
        }
        // query params
        if ($time_consideration !== null) {
            $queryParams['timeConsideration'] = ObjectSerializer::toQueryValue($time_consideration, null);
        }
        // query params
        if ($reference_time !== null) {
            $queryParams['referenceTime'] = ObjectSerializer::toQueryValue($reference_time, 'date-time');
        }
        // query params
        if ($time_span !== null) {
            $queryParams['timeSpan'] = ObjectSerializer::toQueryValue($time_span, 'double');
        }
        // query params
        if ($content_snapshot_id !== null) {
            $queryParams['contentSnapshotId'] = ObjectSerializer::toQueryValue($content_snapshot_id, null);
        }

        // path params
        if ($start_x !== null) {
            $resourcePath = str_replace(
                '{' . 'startX' . '}',
                ObjectSerializer::toPathValue($start_x),
                $resourcePath
            );
        }
        // path params
        if ($start_y !== null) {
            $resourcePath = str_replace(
                '{' . 'startY' . '}',
                ObjectSerializer::toPathValue($start_y),
                $resourcePath
            );
        }
        // path params
        if ($destination_x !== null) {
            $resourcePath = str_replace(
                '{' . 'destinationX' . '}',
                ObjectSerializer::toPathValue($destination_x),
                $resourcePath
            );
        }
        // path params
        if ($destination_y !== null) {
            $resourcePath = str_replace(
                '{' . 'destinationY' . '}',
                ObjectSerializer::toPathValue($destination_y),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation startCalculateReachableAreas
     *
     * @param  \ithings\ptvxserver\model\ReachableAreasRequest $body body (required)
     *
     * @throws \ithings\ptvxserver\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ithings\ptvxserver\model\Job
     */
    public function startCalculateReachableAreas($body)
    {
        list($response) = $this->startCalculateReachableAreasWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation startCalculateReachableAreasWithHttpInfo
     *
     * @param  \ithings\ptvxserver\model\ReachableAreasRequest $body (required)
     *
     * @throws \ithings\ptvxserver\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ithings\ptvxserver\model\Job, HTTP status code, HTTP response headers (array of strings)
     */
    public function startCalculateReachableAreasWithHttpInfo($body)
    {
        $returnType = '\ithings\ptvxserver\model\Job';
        $request = $this->startCalculateReachableAreasRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ithings\ptvxserver\model\Job',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ithings\ptvxserver\model\XServerError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation startCalculateReachableAreasAsync
     *
     * 
     *
     * @param  \ithings\ptvxserver\model\ReachableAreasRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startCalculateReachableAreasAsync($body)
    {
        return $this->startCalculateReachableAreasAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation startCalculateReachableAreasAsyncWithHttpInfo
     *
     * 
     *
     * @param  \ithings\ptvxserver\model\ReachableAreasRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startCalculateReachableAreasAsyncWithHttpInfo($body)
    {
        $returnType = '\ithings\ptvxserver\model\Job';
        $request = $this->startCalculateReachableAreasRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'startCalculateReachableAreas'
     *
     * @param  \ithings\ptvxserver\model\ReachableAreasRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function startCalculateReachableAreasRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling startCalculateReachableAreas'
            );
        }

        $resourcePath = '/services/rs/XRoute/2.26/startCalculateReachableAreas';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation startCalculateReachableLocations
     *
     * @param  \ithings\ptvxserver\model\ReachableLocationsRequest $body body (required)
     *
     * @throws \ithings\ptvxserver\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ithings\ptvxserver\model\Job
     */
    public function startCalculateReachableLocations($body)
    {
        list($response) = $this->startCalculateReachableLocationsWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation startCalculateReachableLocationsWithHttpInfo
     *
     * @param  \ithings\ptvxserver\model\ReachableLocationsRequest $body (required)
     *
     * @throws \ithings\ptvxserver\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ithings\ptvxserver\model\Job, HTTP status code, HTTP response headers (array of strings)
     */
    public function startCalculateReachableLocationsWithHttpInfo($body)
    {
        $returnType = '\ithings\ptvxserver\model\Job';
        $request = $this->startCalculateReachableLocationsRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ithings\ptvxserver\model\Job',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ithings\ptvxserver\model\XServerError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation startCalculateReachableLocationsAsync
     *
     * 
     *
     * @param  \ithings\ptvxserver\model\ReachableLocationsRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startCalculateReachableLocationsAsync($body)
    {
        return $this->startCalculateReachableLocationsAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation startCalculateReachableLocationsAsyncWithHttpInfo
     *
     * 
     *
     * @param  \ithings\ptvxserver\model\ReachableLocationsRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startCalculateReachableLocationsAsyncWithHttpInfo($body)
    {
        $returnType = '\ithings\ptvxserver\model\Job';
        $request = $this->startCalculateReachableLocationsRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'startCalculateReachableLocations'
     *
     * @param  \ithings\ptvxserver\model\ReachableLocationsRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function startCalculateReachableLocationsRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling startCalculateReachableLocations'
            );
        }

        $resourcePath = '/services/rs/XRoute/2.26/startCalculateReachableLocations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation startCalculateRoute
     *
     * @param  \ithings\ptvxserver\model\RouteRequest $body body (required)
     *
     * @throws \ithings\ptvxserver\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ithings\ptvxserver\model\Job
     */
    public function startCalculateRoute($body)
    {
        list($response) = $this->startCalculateRouteWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation startCalculateRouteWithHttpInfo
     *
     * @param  \ithings\ptvxserver\model\RouteRequest $body (required)
     *
     * @throws \ithings\ptvxserver\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ithings\ptvxserver\model\Job, HTTP status code, HTTP response headers (array of strings)
     */
    public function startCalculateRouteWithHttpInfo($body)
    {
        $returnType = '\ithings\ptvxserver\model\Job';
        $request = $this->startCalculateRouteRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ithings\ptvxserver\model\Job',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ithings\ptvxserver\model\XServerError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation startCalculateRouteAsync
     *
     * 
     *
     * @param  \ithings\ptvxserver\model\RouteRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startCalculateRouteAsync($body)
    {
        return $this->startCalculateRouteAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation startCalculateRouteAsyncWithHttpInfo
     *
     * 
     *
     * @param  \ithings\ptvxserver\model\RouteRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startCalculateRouteAsyncWithHttpInfo($body)
    {
        $returnType = '\ithings\ptvxserver\model\Job';
        $request = $this->startCalculateRouteRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'startCalculateRoute'
     *
     * @param  \ithings\ptvxserver\model\RouteRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function startCalculateRouteRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling startCalculateRoute'
            );
        }

        $resourcePath = '/services/rs/XRoute/2.26/startCalculateRoute';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
