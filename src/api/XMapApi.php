<?php
/**
 * XMapApi
 * PHP version 5
 *
 * @category Class
 * @package  ithings\ptvxserver
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * xServer
 *
 * PTV xServer 2.26.1 - 2.26 API document
 *
 * OpenAPI spec version: 2.26
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.34
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace ithings\ptvxserver\api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use ithings\ptvxserver\ApiException;
use ithings\ptvxserver\Configuration;
use ithings\ptvxserver\HeaderSelector;
use ithings\ptvxserver\ObjectSerializer;

/**
 * XMapApi Class Doc Comment
 *
 * @category Class
 * @package  ithings\ptvxserver
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class XMapApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation renderMap
     *
     * @param  \ithings\ptvxserver\model\MapRequest $body body (required)
     *
     * @throws \ithings\ptvxserver\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ithings\ptvxserver\model\MapResponse
     */
    public function renderMap($body)
    {
        list($response) = $this->renderMapWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation renderMapWithHttpInfo
     *
     * @param  \ithings\ptvxserver\model\MapRequest $body (required)
     *
     * @throws \ithings\ptvxserver\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ithings\ptvxserver\model\MapResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function renderMapWithHttpInfo($body)
    {
        $returnType = '\ithings\ptvxserver\model\MapResponse';
        $request = $this->renderMapRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ithings\ptvxserver\model\MapResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ithings\ptvxserver\model\XServerError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation renderMapAsync
     *
     * 
     *
     * @param  \ithings\ptvxserver\model\MapRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renderMapAsync($body)
    {
        return $this->renderMapAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation renderMapAsyncWithHttpInfo
     *
     * 
     *
     * @param  \ithings\ptvxserver\model\MapRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renderMapAsyncWithHttpInfo($body)
    {
        $returnType = '\ithings\ptvxserver\model\MapResponse';
        $request = $this->renderMapRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'renderMap'
     *
     * @param  \ithings\ptvxserver\model\MapRequest $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function renderMapRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling renderMap'
            );
        }

        $resourcePath = '/services/rs/XMap/2.26/renderMap';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tileBinary
     *
     * @param  int $zoom_level Zoom level. Details about zoom levels are documented in the Map Tile API. (required)
     * @param  int $x Horizontal tile index. (required)
     * @param  int $y Vertical tile index. (required)
     * @param  string $stored_profile The name of the stored profile to use without its extension, e.g. &#x60;silkysand&#x60;. The corresponding file &#x60;silkysand.xml&#x60; must be available in the folder &#x60;conf/profiles&#x60;. Parent profiles must be located in the same folder. (optional)
     * @param  string $layers A comma-separated list of layers which will be displayed on the map. If this parameter is specified, layers enabled in the stored profile are ignored. These layers can be the base layers &#x60;labels&#x60;, &#x60;transport&#x60;, and &#x60;background&#x60;, or any of the supported Feature Layer themes such as &#x60;PTV_TruckAttributes&#x60;. If this parameter is not present, the layers defined by the stored profile are displayed. For more information see Integration of custom data and Displaying Feature Layer PTV\\_TruckAttributes. (optional)
     * @param  string $image_format Image format of the rendered tile. This can be &#x60;PNG&#x60; or &#x60;JPG&#x60;. In case of &#x60;JPG&#x60;, the backgrounds (like oceans and forests) must be part of the image content, because they guarantee an image without any transparent pixels. This is important, because for &#x60;JPG&#x60; semi-transparent pixels would be drawn in black erroneously. Therefore a ParameterConflictException is thrown in such a case. (optional)
     * @param  int $size Width and height of the tile in pixels. The maximum allowed value is 8192. (optional)
     * @param  string $time_consideration Specifies how to evaluate Feature Layer attributes which contain time restrictions. For time consideration scenario &#x60;NONE&#x60; the parameters for reference time and timespan are not evaluated. For &#x60;SNAPSHOT&#x60; and &#x60;TIME_SPAN&#x60; the reference time is required. The time span is needed for the &#x60;TIME_SPAN&#x60; scenarios. For detailed information about time consideration scenarios see time consideration. (optional)
     * @param  \DateTime $reference_time The reference time at which Feature Layer attributes with time restrictions will be evaluated. The time format either has to conform to the notation of xs:dateTime such as 2015-12-24T12:00:00+01:00, or it has to be a datetime sequence without any delimiters nor time-zone specification such as 20151224T120000. If the time-zone offset is missing, the corresponding service tries to detect it by means of information available in the calling context. A detailed description of this behavior can be found in the technical concept time zones. It is recommended to always specify the time zone. If no reference time is set, the current UTC time is used. (optional)
     * @param  double $time_span The duration of time (in combination with reference time as start) at which Feature Layer attributes with time restrictions will be evaluated, defined in \\[s\\]. The value is rounded to whole seconds. (optional)
     * @param  bool $show_only_relevant_by_time Specifies if the map shows all attributes regardless of relevance for time consideration (default), or only the attributes which are relevant for this time consideration scenario. For further details, see Relevance of Feature Layer attributes. (optional)
     * @param  bool $show_copyright If true it shows the copyright text in the lower right corner of the image. If not defined the default value is false and no copyright text is shown. (optional)
     * @param  string $preferred_route_types The road networks to be preferred by the routing algorithm as a comma-separated list (only if the Feature Layer PTV\\_PreferredRoutes is enabled). The available types can be requested through the xRuntime service and are documented in the manual as layer-specific properties of the Feature Layer PTV\\_PreferredRoutes. If this parameter is not present, all types of PTV\\_PreferredRoutes are displayed. (optional)
     * @param  string $user_language The language of texts such as traffic-incident descriptions which are returned for *contentType &#x3D; JSON*. (optional)
     * @param  string $content_snapshot_id Specifies the content snapshot to use. If no snapshot ID is set, the most recent content is used. (optional)
     * @param  string $map_language The language used for geographic names that are part of the map. The default x-ptv-DFT means that names are given in the language spoken in that country or region. (optional)
     * @param  string $scope A user defined scope for persistent data like Feature Layers. (optional)
     * @param  bool $draw_icons Specifies if the Feature Layer icons have to be drawn on the map. (optional)
     * @param  bool $icon_reference Specifies if icon references should be returned with the features. (optional)
     *
     * @throws \ithings\ptvxserver\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function tileBinary($zoom_level, $x, $y, $stored_profile = null, $layers = null, $image_format = null, $size = null, $time_consideration = null, $reference_time = null, $time_span = null, $show_only_relevant_by_time = null, $show_copyright = null, $preferred_route_types = null, $user_language = null, $content_snapshot_id = null, $map_language = null, $scope = null, $draw_icons = null, $icon_reference = null)
    {
        list($response) = $this->tileBinaryWithHttpInfo($zoom_level, $x, $y, $stored_profile, $layers, $image_format, $size, $time_consideration, $reference_time, $time_span, $show_only_relevant_by_time, $show_copyright, $preferred_route_types, $user_language, $content_snapshot_id, $map_language, $scope, $draw_icons, $icon_reference);
        return $response;
    }

    /**
     * Operation tileBinaryWithHttpInfo
     *
     * @param  int $zoom_level Zoom level. Details about zoom levels are documented in the Map Tile API. (required)
     * @param  int $x Horizontal tile index. (required)
     * @param  int $y Vertical tile index. (required)
     * @param  string $stored_profile The name of the stored profile to use without its extension, e.g. &#x60;silkysand&#x60;. The corresponding file &#x60;silkysand.xml&#x60; must be available in the folder &#x60;conf/profiles&#x60;. Parent profiles must be located in the same folder. (optional)
     * @param  string $layers A comma-separated list of layers which will be displayed on the map. If this parameter is specified, layers enabled in the stored profile are ignored. These layers can be the base layers &#x60;labels&#x60;, &#x60;transport&#x60;, and &#x60;background&#x60;, or any of the supported Feature Layer themes such as &#x60;PTV_TruckAttributes&#x60;. If this parameter is not present, the layers defined by the stored profile are displayed. For more information see Integration of custom data and Displaying Feature Layer PTV\\_TruckAttributes. (optional)
     * @param  string $image_format Image format of the rendered tile. This can be &#x60;PNG&#x60; or &#x60;JPG&#x60;. In case of &#x60;JPG&#x60;, the backgrounds (like oceans and forests) must be part of the image content, because they guarantee an image without any transparent pixels. This is important, because for &#x60;JPG&#x60; semi-transparent pixels would be drawn in black erroneously. Therefore a ParameterConflictException is thrown in such a case. (optional)
     * @param  int $size Width and height of the tile in pixels. The maximum allowed value is 8192. (optional)
     * @param  string $time_consideration Specifies how to evaluate Feature Layer attributes which contain time restrictions. For time consideration scenario &#x60;NONE&#x60; the parameters for reference time and timespan are not evaluated. For &#x60;SNAPSHOT&#x60; and &#x60;TIME_SPAN&#x60; the reference time is required. The time span is needed for the &#x60;TIME_SPAN&#x60; scenarios. For detailed information about time consideration scenarios see time consideration. (optional)
     * @param  \DateTime $reference_time The reference time at which Feature Layer attributes with time restrictions will be evaluated. The time format either has to conform to the notation of xs:dateTime such as 2015-12-24T12:00:00+01:00, or it has to be a datetime sequence without any delimiters nor time-zone specification such as 20151224T120000. If the time-zone offset is missing, the corresponding service tries to detect it by means of information available in the calling context. A detailed description of this behavior can be found in the technical concept time zones. It is recommended to always specify the time zone. If no reference time is set, the current UTC time is used. (optional)
     * @param  double $time_span The duration of time (in combination with reference time as start) at which Feature Layer attributes with time restrictions will be evaluated, defined in \\[s\\]. The value is rounded to whole seconds. (optional)
     * @param  bool $show_only_relevant_by_time Specifies if the map shows all attributes regardless of relevance for time consideration (default), or only the attributes which are relevant for this time consideration scenario. For further details, see Relevance of Feature Layer attributes. (optional)
     * @param  bool $show_copyright If true it shows the copyright text in the lower right corner of the image. If not defined the default value is false and no copyright text is shown. (optional)
     * @param  string $preferred_route_types The road networks to be preferred by the routing algorithm as a comma-separated list (only if the Feature Layer PTV\\_PreferredRoutes is enabled). The available types can be requested through the xRuntime service and are documented in the manual as layer-specific properties of the Feature Layer PTV\\_PreferredRoutes. If this parameter is not present, all types of PTV\\_PreferredRoutes are displayed. (optional)
     * @param  string $user_language The language of texts such as traffic-incident descriptions which are returned for *contentType &#x3D; JSON*. (optional)
     * @param  string $content_snapshot_id Specifies the content snapshot to use. If no snapshot ID is set, the most recent content is used. (optional)
     * @param  string $map_language The language used for geographic names that are part of the map. The default x-ptv-DFT means that names are given in the language spoken in that country or region. (optional)
     * @param  string $scope A user defined scope for persistent data like Feature Layers. (optional)
     * @param  bool $draw_icons Specifies if the Feature Layer icons have to be drawn on the map. (optional)
     * @param  bool $icon_reference Specifies if icon references should be returned with the features. (optional)
     *
     * @throws \ithings\ptvxserver\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function tileBinaryWithHttpInfo($zoom_level, $x, $y, $stored_profile = null, $layers = null, $image_format = null, $size = null, $time_consideration = null, $reference_time = null, $time_span = null, $show_only_relevant_by_time = null, $show_copyright = null, $preferred_route_types = null, $user_language = null, $content_snapshot_id = null, $map_language = null, $scope = null, $draw_icons = null, $icon_reference = null)
    {
        $returnType = 'string';
        $request = $this->tileBinaryRequest($zoom_level, $x, $y, $stored_profile, $layers, $image_format, $size, $time_consideration, $reference_time, $time_span, $show_only_relevant_by_time, $show_copyright, $preferred_route_types, $user_language, $content_snapshot_id, $map_language, $scope, $draw_icons, $icon_reference);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ithings\ptvxserver\model\XServerError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tileBinaryAsync
     *
     * 
     *
     * @param  int $zoom_level Zoom level. Details about zoom levels are documented in the Map Tile API. (required)
     * @param  int $x Horizontal tile index. (required)
     * @param  int $y Vertical tile index. (required)
     * @param  string $stored_profile The name of the stored profile to use without its extension, e.g. &#x60;silkysand&#x60;. The corresponding file &#x60;silkysand.xml&#x60; must be available in the folder &#x60;conf/profiles&#x60;. Parent profiles must be located in the same folder. (optional)
     * @param  string $layers A comma-separated list of layers which will be displayed on the map. If this parameter is specified, layers enabled in the stored profile are ignored. These layers can be the base layers &#x60;labels&#x60;, &#x60;transport&#x60;, and &#x60;background&#x60;, or any of the supported Feature Layer themes such as &#x60;PTV_TruckAttributes&#x60;. If this parameter is not present, the layers defined by the stored profile are displayed. For more information see Integration of custom data and Displaying Feature Layer PTV\\_TruckAttributes. (optional)
     * @param  string $image_format Image format of the rendered tile. This can be &#x60;PNG&#x60; or &#x60;JPG&#x60;. In case of &#x60;JPG&#x60;, the backgrounds (like oceans and forests) must be part of the image content, because they guarantee an image without any transparent pixels. This is important, because for &#x60;JPG&#x60; semi-transparent pixels would be drawn in black erroneously. Therefore a ParameterConflictException is thrown in such a case. (optional)
     * @param  int $size Width and height of the tile in pixels. The maximum allowed value is 8192. (optional)
     * @param  string $time_consideration Specifies how to evaluate Feature Layer attributes which contain time restrictions. For time consideration scenario &#x60;NONE&#x60; the parameters for reference time and timespan are not evaluated. For &#x60;SNAPSHOT&#x60; and &#x60;TIME_SPAN&#x60; the reference time is required. The time span is needed for the &#x60;TIME_SPAN&#x60; scenarios. For detailed information about time consideration scenarios see time consideration. (optional)
     * @param  \DateTime $reference_time The reference time at which Feature Layer attributes with time restrictions will be evaluated. The time format either has to conform to the notation of xs:dateTime such as 2015-12-24T12:00:00+01:00, or it has to be a datetime sequence without any delimiters nor time-zone specification such as 20151224T120000. If the time-zone offset is missing, the corresponding service tries to detect it by means of information available in the calling context. A detailed description of this behavior can be found in the technical concept time zones. It is recommended to always specify the time zone. If no reference time is set, the current UTC time is used. (optional)
     * @param  double $time_span The duration of time (in combination with reference time as start) at which Feature Layer attributes with time restrictions will be evaluated, defined in \\[s\\]. The value is rounded to whole seconds. (optional)
     * @param  bool $show_only_relevant_by_time Specifies if the map shows all attributes regardless of relevance for time consideration (default), or only the attributes which are relevant for this time consideration scenario. For further details, see Relevance of Feature Layer attributes. (optional)
     * @param  bool $show_copyright If true it shows the copyright text in the lower right corner of the image. If not defined the default value is false and no copyright text is shown. (optional)
     * @param  string $preferred_route_types The road networks to be preferred by the routing algorithm as a comma-separated list (only if the Feature Layer PTV\\_PreferredRoutes is enabled). The available types can be requested through the xRuntime service and are documented in the manual as layer-specific properties of the Feature Layer PTV\\_PreferredRoutes. If this parameter is not present, all types of PTV\\_PreferredRoutes are displayed. (optional)
     * @param  string $user_language The language of texts such as traffic-incident descriptions which are returned for *contentType &#x3D; JSON*. (optional)
     * @param  string $content_snapshot_id Specifies the content snapshot to use. If no snapshot ID is set, the most recent content is used. (optional)
     * @param  string $map_language The language used for geographic names that are part of the map. The default x-ptv-DFT means that names are given in the language spoken in that country or region. (optional)
     * @param  string $scope A user defined scope for persistent data like Feature Layers. (optional)
     * @param  bool $draw_icons Specifies if the Feature Layer icons have to be drawn on the map. (optional)
     * @param  bool $icon_reference Specifies if icon references should be returned with the features. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tileBinaryAsync($zoom_level, $x, $y, $stored_profile = null, $layers = null, $image_format = null, $size = null, $time_consideration = null, $reference_time = null, $time_span = null, $show_only_relevant_by_time = null, $show_copyright = null, $preferred_route_types = null, $user_language = null, $content_snapshot_id = null, $map_language = null, $scope = null, $draw_icons = null, $icon_reference = null)
    {
        return $this->tileBinaryAsyncWithHttpInfo($zoom_level, $x, $y, $stored_profile, $layers, $image_format, $size, $time_consideration, $reference_time, $time_span, $show_only_relevant_by_time, $show_copyright, $preferred_route_types, $user_language, $content_snapshot_id, $map_language, $scope, $draw_icons, $icon_reference)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tileBinaryAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $zoom_level Zoom level. Details about zoom levels are documented in the Map Tile API. (required)
     * @param  int $x Horizontal tile index. (required)
     * @param  int $y Vertical tile index. (required)
     * @param  string $stored_profile The name of the stored profile to use without its extension, e.g. &#x60;silkysand&#x60;. The corresponding file &#x60;silkysand.xml&#x60; must be available in the folder &#x60;conf/profiles&#x60;. Parent profiles must be located in the same folder. (optional)
     * @param  string $layers A comma-separated list of layers which will be displayed on the map. If this parameter is specified, layers enabled in the stored profile are ignored. These layers can be the base layers &#x60;labels&#x60;, &#x60;transport&#x60;, and &#x60;background&#x60;, or any of the supported Feature Layer themes such as &#x60;PTV_TruckAttributes&#x60;. If this parameter is not present, the layers defined by the stored profile are displayed. For more information see Integration of custom data and Displaying Feature Layer PTV\\_TruckAttributes. (optional)
     * @param  string $image_format Image format of the rendered tile. This can be &#x60;PNG&#x60; or &#x60;JPG&#x60;. In case of &#x60;JPG&#x60;, the backgrounds (like oceans and forests) must be part of the image content, because they guarantee an image without any transparent pixels. This is important, because for &#x60;JPG&#x60; semi-transparent pixels would be drawn in black erroneously. Therefore a ParameterConflictException is thrown in such a case. (optional)
     * @param  int $size Width and height of the tile in pixels. The maximum allowed value is 8192. (optional)
     * @param  string $time_consideration Specifies how to evaluate Feature Layer attributes which contain time restrictions. For time consideration scenario &#x60;NONE&#x60; the parameters for reference time and timespan are not evaluated. For &#x60;SNAPSHOT&#x60; and &#x60;TIME_SPAN&#x60; the reference time is required. The time span is needed for the &#x60;TIME_SPAN&#x60; scenarios. For detailed information about time consideration scenarios see time consideration. (optional)
     * @param  \DateTime $reference_time The reference time at which Feature Layer attributes with time restrictions will be evaluated. The time format either has to conform to the notation of xs:dateTime such as 2015-12-24T12:00:00+01:00, or it has to be a datetime sequence without any delimiters nor time-zone specification such as 20151224T120000. If the time-zone offset is missing, the corresponding service tries to detect it by means of information available in the calling context. A detailed description of this behavior can be found in the technical concept time zones. It is recommended to always specify the time zone. If no reference time is set, the current UTC time is used. (optional)
     * @param  double $time_span The duration of time (in combination with reference time as start) at which Feature Layer attributes with time restrictions will be evaluated, defined in \\[s\\]. The value is rounded to whole seconds. (optional)
     * @param  bool $show_only_relevant_by_time Specifies if the map shows all attributes regardless of relevance for time consideration (default), or only the attributes which are relevant for this time consideration scenario. For further details, see Relevance of Feature Layer attributes. (optional)
     * @param  bool $show_copyright If true it shows the copyright text in the lower right corner of the image. If not defined the default value is false and no copyright text is shown. (optional)
     * @param  string $preferred_route_types The road networks to be preferred by the routing algorithm as a comma-separated list (only if the Feature Layer PTV\\_PreferredRoutes is enabled). The available types can be requested through the xRuntime service and are documented in the manual as layer-specific properties of the Feature Layer PTV\\_PreferredRoutes. If this parameter is not present, all types of PTV\\_PreferredRoutes are displayed. (optional)
     * @param  string $user_language The language of texts such as traffic-incident descriptions which are returned for *contentType &#x3D; JSON*. (optional)
     * @param  string $content_snapshot_id Specifies the content snapshot to use. If no snapshot ID is set, the most recent content is used. (optional)
     * @param  string $map_language The language used for geographic names that are part of the map. The default x-ptv-DFT means that names are given in the language spoken in that country or region. (optional)
     * @param  string $scope A user defined scope for persistent data like Feature Layers. (optional)
     * @param  bool $draw_icons Specifies if the Feature Layer icons have to be drawn on the map. (optional)
     * @param  bool $icon_reference Specifies if icon references should be returned with the features. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tileBinaryAsyncWithHttpInfo($zoom_level, $x, $y, $stored_profile = null, $layers = null, $image_format = null, $size = null, $time_consideration = null, $reference_time = null, $time_span = null, $show_only_relevant_by_time = null, $show_copyright = null, $preferred_route_types = null, $user_language = null, $content_snapshot_id = null, $map_language = null, $scope = null, $draw_icons = null, $icon_reference = null)
    {
        $returnType = 'string';
        $request = $this->tileBinaryRequest($zoom_level, $x, $y, $stored_profile, $layers, $image_format, $size, $time_consideration, $reference_time, $time_span, $show_only_relevant_by_time, $show_copyright, $preferred_route_types, $user_language, $content_snapshot_id, $map_language, $scope, $draw_icons, $icon_reference);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tileBinary'
     *
     * @param  int $zoom_level Zoom level. Details about zoom levels are documented in the Map Tile API. (required)
     * @param  int $x Horizontal tile index. (required)
     * @param  int $y Vertical tile index. (required)
     * @param  string $stored_profile The name of the stored profile to use without its extension, e.g. &#x60;silkysand&#x60;. The corresponding file &#x60;silkysand.xml&#x60; must be available in the folder &#x60;conf/profiles&#x60;. Parent profiles must be located in the same folder. (optional)
     * @param  string $layers A comma-separated list of layers which will be displayed on the map. If this parameter is specified, layers enabled in the stored profile are ignored. These layers can be the base layers &#x60;labels&#x60;, &#x60;transport&#x60;, and &#x60;background&#x60;, or any of the supported Feature Layer themes such as &#x60;PTV_TruckAttributes&#x60;. If this parameter is not present, the layers defined by the stored profile are displayed. For more information see Integration of custom data and Displaying Feature Layer PTV\\_TruckAttributes. (optional)
     * @param  string $image_format Image format of the rendered tile. This can be &#x60;PNG&#x60; or &#x60;JPG&#x60;. In case of &#x60;JPG&#x60;, the backgrounds (like oceans and forests) must be part of the image content, because they guarantee an image without any transparent pixels. This is important, because for &#x60;JPG&#x60; semi-transparent pixels would be drawn in black erroneously. Therefore a ParameterConflictException is thrown in such a case. (optional)
     * @param  int $size Width and height of the tile in pixels. The maximum allowed value is 8192. (optional)
     * @param  string $time_consideration Specifies how to evaluate Feature Layer attributes which contain time restrictions. For time consideration scenario &#x60;NONE&#x60; the parameters for reference time and timespan are not evaluated. For &#x60;SNAPSHOT&#x60; and &#x60;TIME_SPAN&#x60; the reference time is required. The time span is needed for the &#x60;TIME_SPAN&#x60; scenarios. For detailed information about time consideration scenarios see time consideration. (optional)
     * @param  \DateTime $reference_time The reference time at which Feature Layer attributes with time restrictions will be evaluated. The time format either has to conform to the notation of xs:dateTime such as 2015-12-24T12:00:00+01:00, or it has to be a datetime sequence without any delimiters nor time-zone specification such as 20151224T120000. If the time-zone offset is missing, the corresponding service tries to detect it by means of information available in the calling context. A detailed description of this behavior can be found in the technical concept time zones. It is recommended to always specify the time zone. If no reference time is set, the current UTC time is used. (optional)
     * @param  double $time_span The duration of time (in combination with reference time as start) at which Feature Layer attributes with time restrictions will be evaluated, defined in \\[s\\]. The value is rounded to whole seconds. (optional)
     * @param  bool $show_only_relevant_by_time Specifies if the map shows all attributes regardless of relevance for time consideration (default), or only the attributes which are relevant for this time consideration scenario. For further details, see Relevance of Feature Layer attributes. (optional)
     * @param  bool $show_copyright If true it shows the copyright text in the lower right corner of the image. If not defined the default value is false and no copyright text is shown. (optional)
     * @param  string $preferred_route_types The road networks to be preferred by the routing algorithm as a comma-separated list (only if the Feature Layer PTV\\_PreferredRoutes is enabled). The available types can be requested through the xRuntime service and are documented in the manual as layer-specific properties of the Feature Layer PTV\\_PreferredRoutes. If this parameter is not present, all types of PTV\\_PreferredRoutes are displayed. (optional)
     * @param  string $user_language The language of texts such as traffic-incident descriptions which are returned for *contentType &#x3D; JSON*. (optional)
     * @param  string $content_snapshot_id Specifies the content snapshot to use. If no snapshot ID is set, the most recent content is used. (optional)
     * @param  string $map_language The language used for geographic names that are part of the map. The default x-ptv-DFT means that names are given in the language spoken in that country or region. (optional)
     * @param  string $scope A user defined scope for persistent data like Feature Layers. (optional)
     * @param  bool $draw_icons Specifies if the Feature Layer icons have to be drawn on the map. (optional)
     * @param  bool $icon_reference Specifies if icon references should be returned with the features. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function tileBinaryRequest($zoom_level, $x, $y, $stored_profile = null, $layers = null, $image_format = null, $size = null, $time_consideration = null, $reference_time = null, $time_span = null, $show_only_relevant_by_time = null, $show_copyright = null, $preferred_route_types = null, $user_language = null, $content_snapshot_id = null, $map_language = null, $scope = null, $draw_icons = null, $icon_reference = null)
    {
        // verify the required parameter 'zoom_level' is set
        if ($zoom_level === null || (is_array($zoom_level) && count($zoom_level) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $zoom_level when calling tileBinary'
            );
        }
        // verify the required parameter 'x' is set
        if ($x === null || (is_array($x) && count($x) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x when calling tileBinary'
            );
        }
        // verify the required parameter 'y' is set
        if ($y === null || (is_array($y) && count($y) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $y when calling tileBinary'
            );
        }

        $resourcePath = '/services/rest/XMap/2.26/tile/{zoomLevel}/{x}/{y}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($stored_profile !== null) {
            $queryParams['storedProfile'] = ObjectSerializer::toQueryValue($stored_profile, null);
        }
        // query params
        if ($layers !== null) {
            $queryParams['layers'] = ObjectSerializer::toQueryValue($layers, null);
        }
        // query params
        if ($image_format !== null) {
            $queryParams['imageFormat'] = ObjectSerializer::toQueryValue($image_format, null);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size, 'int32');
        }
        // query params
        if ($time_consideration !== null) {
            $queryParams['timeConsideration'] = ObjectSerializer::toQueryValue($time_consideration, null);
        }
        // query params
        if ($reference_time !== null) {
            $queryParams['referenceTime'] = ObjectSerializer::toQueryValue($reference_time, 'date-time');
        }
        // query params
        if ($time_span !== null) {
            $queryParams['timeSpan'] = ObjectSerializer::toQueryValue($time_span, 'double');
        }
        // query params
        if ($show_only_relevant_by_time !== null) {
            $queryParams['showOnlyRelevantByTime'] = ObjectSerializer::toQueryValue($show_only_relevant_by_time, null);
        }
        // query params
        if ($show_copyright !== null) {
            $queryParams['showCopyright'] = ObjectSerializer::toQueryValue($show_copyright, null);
        }
        // query params
        if ($preferred_route_types !== null) {
            $queryParams['preferredRouteTypes'] = ObjectSerializer::toQueryValue($preferred_route_types, null);
        }
        // query params
        if ($user_language !== null) {
            $queryParams['userLanguage'] = ObjectSerializer::toQueryValue($user_language, null);
        }
        // query params
        if ($content_snapshot_id !== null) {
            $queryParams['contentSnapshotId'] = ObjectSerializer::toQueryValue($content_snapshot_id, null);
        }
        // query params
        if ($map_language !== null) {
            $queryParams['mapLanguage'] = ObjectSerializer::toQueryValue($map_language, null);
        }
        // query params
        if ($scope !== null) {
            $queryParams['scope'] = ObjectSerializer::toQueryValue($scope, null);
        }
        // query params
        if ($draw_icons !== null) {
            $queryParams['drawIcons'] = ObjectSerializer::toQueryValue($draw_icons, null);
        }
        // query params
        if ($icon_reference !== null) {
            $queryParams['iconReference'] = ObjectSerializer::toQueryValue($icon_reference, null);
        }

        // path params
        if ($zoom_level !== null) {
            $resourcePath = str_replace(
                '{' . 'zoomLevel' . '}',
                ObjectSerializer::toPathValue($zoom_level),
                $resourcePath
            );
        }
        // path params
        if ($x !== null) {
            $resourcePath = str_replace(
                '{' . 'x' . '}',
                ObjectSerializer::toPathValue($x),
                $resourcePath
            );
        }
        // path params
        if ($y !== null) {
            $resourcePath = str_replace(
                '{' . 'y' . '}',
                ObjectSerializer::toPathValue($y),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['image/png', 'image/jpeg']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['image/png', 'image/jpeg'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
