<?php
/**
 * LegReport
 *
 * PHP version 5
 *
 * @category Class
 * @package  ithings\ptvxserver
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * xServer
 *
 * PTV xServer 2.26.1 - 2.26 API document
 *
 * OpenAPI spec version: 2.26
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.34
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace ithings\ptvxserver\model;

use \ArrayAccess;
use \ithings\ptvxserver\ObjectSerializer;

/**
 * LegReport Class Doc Comment
 *
 * @category Class
 * @description Contains information for the route between two successive sites of a tour. A leg is either between two stops of a trip, between two trips, between the vehicle start location and the first stop of the tour or between the last stop of a tour and the vehicle end location. For further information please have a look at the technical concept Tours and Trips. Hint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.LegReport
 * @package  ithings\ptvxserver
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class LegReport implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'LegReport';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'start_tour_event_index' => '\ithings\ptvxserver\model\Index',
'end_tour_event_index' => '\ithings\ptvxserver\model\Index',
'driving_time' => '\ithings\ptvxserver\model\Duration',
'distance' => '\ithings\ptvxserver\model\Distance',
'estimated_by_direct_distance' => 'bool',
'route_violated' => 'bool',
'transport_quantities' => '\ithings\ptvxserver\model\TransportQuantityUnit[]',
'maximum_quantity_scenario_index' => '\ithings\ptvxserver\model\Index'    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'start_tour_event_index' => null,
'end_tour_event_index' => null,
'driving_time' => null,
'distance' => null,
'estimated_by_direct_distance' => null,
'route_violated' => null,
'transport_quantities' => null,
'maximum_quantity_scenario_index' => null    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'start_tour_event_index' => 'startTourEventIndex',
'end_tour_event_index' => 'endTourEventIndex',
'driving_time' => 'drivingTime',
'distance' => 'distance',
'estimated_by_direct_distance' => 'estimatedByDirectDistance',
'route_violated' => 'routeViolated',
'transport_quantities' => 'transportQuantities',
'maximum_quantity_scenario_index' => 'maximumQuantityScenarioIndex'    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'start_tour_event_index' => 'setStartTourEventIndex',
'end_tour_event_index' => 'setEndTourEventIndex',
'driving_time' => 'setDrivingTime',
'distance' => 'setDistance',
'estimated_by_direct_distance' => 'setEstimatedByDirectDistance',
'route_violated' => 'setRouteViolated',
'transport_quantities' => 'setTransportQuantities',
'maximum_quantity_scenario_index' => 'setMaximumQuantityScenarioIndex'    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'start_tour_event_index' => 'getStartTourEventIndex',
'end_tour_event_index' => 'getEndTourEventIndex',
'driving_time' => 'getDrivingTime',
'distance' => 'getDistance',
'estimated_by_direct_distance' => 'getEstimatedByDirectDistance',
'route_violated' => 'getRouteViolated',
'transport_quantities' => 'getTransportQuantities',
'maximum_quantity_scenario_index' => 'getMaximumQuantityScenarioIndex'    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['start_tour_event_index'] = isset($data['start_tour_event_index']) ? $data['start_tour_event_index'] : null;
        $this->container['end_tour_event_index'] = isset($data['end_tour_event_index']) ? $data['end_tour_event_index'] : null;
        $this->container['driving_time'] = isset($data['driving_time']) ? $data['driving_time'] : null;
        $this->container['distance'] = isset($data['distance']) ? $data['distance'] : null;
        $this->container['estimated_by_direct_distance'] = isset($data['estimated_by_direct_distance']) ? $data['estimated_by_direct_distance'] : null;
        $this->container['route_violated'] = isset($data['route_violated']) ? $data['route_violated'] : null;
        $this->container['transport_quantities'] = isset($data['transport_quantities']) ? $data['transport_quantities'] : null;
        $this->container['maximum_quantity_scenario_index'] = isset($data['maximum_quantity_scenario_index']) ? $data['maximum_quantity_scenario_index'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets start_tour_event_index
     *
     * @return \ithings\ptvxserver\model\Index
     */
    public function getStartTourEventIndex()
    {
        return $this->container['start_tour_event_index'];
    }

    /**
     * Sets start_tour_event_index
     *
     * @param \ithings\ptvxserver\model\Index $start_tour_event_index start_tour_event_index
     *
     * @return $this
     */
    public function setStartTourEventIndex($start_tour_event_index)
    {
        $this->container['start_tour_event_index'] = $start_tour_event_index;

        return $this;
    }

    /**
     * Gets end_tour_event_index
     *
     * @return \ithings\ptvxserver\model\Index
     */
    public function getEndTourEventIndex()
    {
        return $this->container['end_tour_event_index'];
    }

    /**
     * Sets end_tour_event_index
     *
     * @param \ithings\ptvxserver\model\Index $end_tour_event_index end_tour_event_index
     *
     * @return $this
     */
    public function setEndTourEventIndex($end_tour_event_index)
    {
        $this->container['end_tour_event_index'] = $end_tour_event_index;

        return $this;
    }

    /**
     * Gets driving_time
     *
     * @return \ithings\ptvxserver\model\Duration
     */
    public function getDrivingTime()
    {
        return $this->container['driving_time'];
    }

    /**
     * Sets driving_time
     *
     * @param \ithings\ptvxserver\model\Duration $driving_time driving_time
     *
     * @return $this
     */
    public function setDrivingTime($driving_time)
    {
        $this->container['driving_time'] = $driving_time;

        return $this;
    }

    /**
     * Gets distance
     *
     * @return \ithings\ptvxserver\model\Distance
     */
    public function getDistance()
    {
        return $this->container['distance'];
    }

    /**
     * Sets distance
     *
     * @param \ithings\ptvxserver\model\Distance $distance distance
     *
     * @return $this
     */
    public function setDistance($distance)
    {
        $this->container['distance'] = $distance;

        return $this;
    }

    /**
     * Gets estimated_by_direct_distance
     *
     * @return bool
     */
    public function getEstimatedByDirectDistance()
    {
        return $this->container['estimated_by_direct_distance'];
    }

    /**
     * Sets estimated_by_direct_distance
     *
     * @param bool $estimated_by_direct_distance True if the driving time of this leg is estimated by direct distance instead of the road network.    Possible causes:     *  start or end not within boundaries of map,   *  start or end too far from next road,   *  no route found between start and end.    If EstimateByReferenceMatrix is used as distance mode, the leg is estimated by direct distance if and only if the according reference locations are estimated by direct distance. If DirectDistance is used as distance mode, this flag will always be set.
     *
     * @return $this
     */
    public function setEstimatedByDirectDistance($estimated_by_direct_distance)
    {
        $this->container['estimated_by_direct_distance'] = $estimated_by_direct_distance;

        return $this;
    }

    /**
     * Gets route_violated
     *
     * @return bool
     */
    public function getRouteViolated()
    {
        return $this->container['route_violated'];
    }

    /**
     * Sets route_violated
     *
     * @param bool $route_violated True if the leg is calculated with route violations. If EstimateByReferenceMatrix is used as distance mode, the route is violated if and only if the route between the according reference locations is violated.
     *
     * @return $this
     */
    public function setRouteViolated($route_violated)
    {
        $this->container['route_violated'] = $route_violated;

        return $this;
    }

    /**
     * Gets transport_quantities
     *
     * @return \ithings\ptvxserver\model\TransportQuantityUnit[]
     */
    public function getTransportQuantities()
    {
        return $this->container['transport_quantities'];
    }

    /**
     * Sets transport_quantities
     *
     * @param \ithings\ptvxserver\model\TransportQuantityUnit[] $transport_quantities transport_quantities
     *
     * @return $this
     */
    public function setTransportQuantities($transport_quantities)
    {
        $this->container['transport_quantities'] = $transport_quantities;

        return $this;
    }

    /**
     * Gets maximum_quantity_scenario_index
     *
     * @return \ithings\ptvxserver\model\Index
     */
    public function getMaximumQuantityScenarioIndex()
    {
        return $this->container['maximum_quantity_scenario_index'];
    }

    /**
     * Sets maximum_quantity_scenario_index
     *
     * @param \ithings\ptvxserver\model\Index $maximum_quantity_scenario_index maximum_quantity_scenario_index
     *
     * @return $this
     */
    public function setMaximumQuantityScenarioIndex($maximum_quantity_scenario_index)
    {
        $this->container['maximum_quantity_scenario_index'] = $maximum_quantity_scenario_index;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}
