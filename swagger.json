{
  "swagger" : "2.0",
  "info" : {
    "description" : "PTV xServer 2.26.1 - 2.26 API document",
    "version" : "2.26",
    "title" : "xServer"
  },
  "consumes" : [ "application/json" ],
  "produces" : [ "application/json" ],
  "paths" : {
    "/services/rest/XData/2.26/timeZone/{x}/{y}" : {
      "get" : {
        "tags" : [ "xData" ],
        "description" : "Determines the time zone for a given location.",
        "operationId" : "timeZone",
        "parameters" : [ {
          "name" : "x",
          "in" : "path",
          "description" : "The value in x-direction (west to east), longitude for WGS84.",
          "required" : true,
          "type" : "number",
          "format" : "double"
        }, {
          "name" : "y",
          "in" : "path",
          "description" : "The value in y-direction (south to north), latitude for WGS84.",
          "required" : true,
          "type" : "number",
          "format" : "double"
        }, {
          "name" : "referenceDate",
          "in" : "query",
          "description" : "The date to determine the daylight saving time for the given location. If not specified the time zone valid now will be returned. If daylight saving time changes at this date, the status at 12 noon will be assumed. Consequently, if daylight saving time changes from winter to summer at this date, summer will be returned.",
          "required" : false,
          "type" : "string",
          "format" : "date",
          "x-ms-parameter-grouping" : { }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/TimeZoneResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rest/XLocate/2.26/locations/{address}" : {
      "get" : {
        "tags" : [ "xLocate" ],
        "description" : "Searches for locations matching a given address, specified as a free-form text input.",
        "operationId" : "locations",
        "parameters" : [ {
          "name" : "address",
          "in" : "path",
          "description" : "The input address.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "mapLanguage",
          "in" : "query",
          "description" : "The language used for geographic names that are part of the map. The default x-ptv-DFT means that names are given in the language spoken in that country or region.",
          "required" : false,
          "type" : "string",
          "x-ms-parameter-grouping" : { }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/LocationsResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rest/XMap/2.26/tile/{zoomLevel}/{x}/{y}" : {
      "get" : {
        "tags" : [ "xMap" ],
        "description" : "Render a single map tile according the concept of the Map Tile API. By means of different frameworks a map image can be composed of multiple tiles. These tiles can be cached and reused for drawing of similar sections of a map. Optionally it is possible to return textual information on drawn Feature Layer data. Therefore, this operation can return either an image directly or a structured response which contains the image and additional information on drawn Feature Layer data such as their positions and names.",
        "operationId" : "tileBinary",
        "produces" : [ "image/png", "image/jpeg" ],
        "parameters" : [ {
          "name" : "zoomLevel",
          "in" : "path",
          "description" : "Zoom level. Details about zoom levels are documented in the Map Tile API.",
          "required" : true,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "x",
          "in" : "path",
          "description" : "Horizontal tile index.",
          "required" : true,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "y",
          "in" : "path",
          "description" : "Vertical tile index.",
          "required" : true,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "storedProfile",
          "in" : "query",
          "description" : "The name of the stored profile to use without its extension, e.g. `silkysand`. The corresponding file `silkysand.xml` must be available in the folder `conf/profiles`. Parent profiles must be located in the same folder.",
          "required" : false,
          "type" : "string",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "layers",
          "in" : "query",
          "description" : "A comma-separated list of layers which will be displayed on the map. If this parameter is specified, layers enabled in the stored profile are ignored. These layers can be the base layers `labels`, `transport`, and `background`, or any of the supported Feature Layer themes such as `PTV_TruckAttributes`. If this parameter is not present, the layers defined by the stored profile are displayed. For more information see Integration of custom data and Displaying Feature Layer PTV\\_TruckAttributes.",
          "required" : false,
          "type" : "string",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "imageFormat",
          "in" : "query",
          "description" : "Image format of the rendered tile. This can be `PNG` or `JPG`. In case of `JPG`, the backgrounds (like oceans and forests) must be part of the image content, because they guarantee an image without any transparent pixels. This is important, because for `JPG` semi-transparent pixels would be drawn in black erroneously. Therefore a ParameterConflictException is thrown in such a case.",
          "required" : false,
          "type" : "string",
          "enum" : [ "PNG", "JPG" ],
          "x-ms-parameter-grouping" : { },
          "x-ms-enum" : {
            "name" : "ImageFormat",
            "modelAsString" : false
          }
        }, {
          "name" : "size",
          "in" : "query",
          "description" : "Width and height of the tile in pixels. The maximum allowed value is 8192.",
          "required" : false,
          "type" : "integer",
          "format" : "int32",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "timeConsideration",
          "in" : "query",
          "description" : "Specifies how to evaluate Feature Layer attributes which contain time restrictions. For time consideration scenario `NONE` the parameters for reference time and timespan are not evaluated. For `SNAPSHOT` and `TIME_SPAN` the reference time is required. The time span is needed for the `TIME_SPAN` scenarios. For detailed information about time consideration scenarios see time consideration.",
          "required" : false,
          "type" : "string",
          "enum" : [ "NONE", "SNAPSHOT", "TIME_SPAN", "EXACT_TIME_AT_START", "EXACT_TIME_AT_ARRIVAL", "OPTIMISTIC" ],
          "x-ms-parameter-grouping" : { },
          "x-ms-enum" : {
            "name" : "TimeConsiderationScenario",
            "modelAsString" : false
          }
        }, {
          "name" : "referenceTime",
          "in" : "query",
          "description" : "The reference time at which Feature Layer attributes with time restrictions will be evaluated. The time format either has to conform to the notation of xs:dateTime such as 2015-12-24T12:00:00+01:00, or it has to be a datetime sequence without any delimiters nor time-zone specification such as 20151224T120000. If the time-zone offset is missing, the corresponding service tries to detect it by means of information available in the calling context. A detailed description of this behavior can be found in the technical concept time zones. It is recommended to always specify the time zone. If no reference time is set, the current UTC time is used.",
          "required" : false,
          "type" : "string",
          "format" : "date-time",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "timeSpan",
          "in" : "query",
          "description" : "The duration of time (in combination with reference time as start) at which Feature Layer attributes with time restrictions will be evaluated, defined in \\[s\\]. The value is rounded to whole seconds.",
          "required" : false,
          "type" : "number",
          "format" : "double",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "showOnlyRelevantByTime",
          "in" : "query",
          "description" : "Specifies if the map shows all attributes regardless of relevance for time consideration (default), or only the attributes which are relevant for this time consideration scenario. For further details, see Relevance of Feature Layer attributes.",
          "required" : false,
          "type" : "boolean",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "showCopyright",
          "in" : "query",
          "description" : "If true it shows the copyright text in the lower right corner of the image. If not defined the default value is false and no copyright text is shown.",
          "required" : false,
          "type" : "boolean",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "preferredRouteTypes",
          "in" : "query",
          "description" : "The road networks to be preferred by the routing algorithm as a comma-separated list (only if the Feature Layer PTV\\_PreferredRoutes is enabled). The available types can be requested through the xRuntime service and are documented in the manual as layer-specific properties of the Feature Layer PTV\\_PreferredRoutes. If this parameter is not present, all types of PTV\\_PreferredRoutes are displayed.",
          "required" : false,
          "type" : "string",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "userLanguage",
          "in" : "query",
          "description" : "The language of texts such as traffic-incident descriptions which are returned for *contentType = JSON*.",
          "required" : false,
          "type" : "string",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "contentSnapshotId",
          "in" : "query",
          "description" : "Specifies the content snapshot to use. If no snapshot ID is set, the most recent content is used.",
          "required" : false,
          "type" : "string",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "mapLanguage",
          "in" : "query",
          "description" : "The language used for geographic names that are part of the map. The default x-ptv-DFT means that names are given in the language spoken in that country or region.",
          "required" : false,
          "type" : "string",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "scope",
          "in" : "query",
          "description" : "A user defined scope for persistent data like Feature Layers.",
          "required" : false,
          "type" : "string",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "drawIcons",
          "in" : "query",
          "description" : "Specifies if the Feature Layer icons have to be drawn on the map.",
          "required" : false,
          "type" : "boolean",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "iconReference",
          "in" : "query",
          "description" : "Specifies if icon references should be returned with the features.",
          "required" : false,
          "type" : "boolean",
          "x-ms-parameter-grouping" : { }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "type" : "file"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rest/XRoute/2.26/route/{startX}/{startY}/{destinationX}/{destinationY}" : {
      "get" : {
        "tags" : [ "xRoute" ],
        "description" : "Calculates a route from start to destination and returns route information. This operation supports exactly two on-road waypoints.",
        "operationId" : "route",
        "parameters" : [ {
          "name" : "startX",
          "in" : "path",
          "description" : "The longitude in WGS84 (EPSG:4326) of the start location. The location is interpreted as an routing.OnRoadRouteLocation.",
          "required" : true,
          "type" : "number",
          "format" : "double"
        }, {
          "name" : "startY",
          "in" : "path",
          "description" : "The latitude in WGS84 (EPSG:4326) of the start location. The location is interpreted as an routing.OnRoadRouteLocation.",
          "required" : true,
          "type" : "number",
          "format" : "double"
        }, {
          "name" : "destinationX",
          "in" : "path",
          "description" : "The longitude in WGS84 (EPSG:4326) of the destination location. The location is interpreted as an routing.OnRoadRouteLocation.",
          "required" : true,
          "type" : "number",
          "format" : "double"
        }, {
          "name" : "destinationY",
          "in" : "path",
          "description" : "The latitude in WGS84 (EPSG:4326) of the destination location. The location is interpreted as an routing.OnRoadRouteLocation.",
          "required" : true,
          "type" : "number",
          "format" : "double"
        }, {
          "name" : "storedProfile",
          "in" : "query",
          "description" : "The name of the stored profile to use without its extension, e.g. `bicycle`. The corresponding file `bicycle.xml` must be available in the folder `conf/profiles`. Parent profiles must be located in the same folder.",
          "required" : false,
          "type" : "string",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "polyline",
          "in" : "query",
          "description" : "Specifies if the RouteResponse.polyline shall be returned for the complete route.",
          "required" : false,
          "type" : "boolean",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "themeIds",
          "in" : "query",
          "description" : "A comma-separated list of Feature Layer theme IDs which will be considered. If this parameter is specified, themes enabled in the stored profile are ignored. These themes can be any of the supported Feature Layer themes, such as `PTV_TruckAttributes`. If this parameter is not present, the themes defined by the stored profile are used. A trailing comma is permitted. For more information see Calculating the Best Route for Rush Hour Traffic and Considering Long-term Blockings.",
          "required" : false,
          "type" : "string",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "preferredRouteTypes",
          "in" : "query",
          "description" : "The road networks to be preferred by the routing algorithm as a comma-separated list (only if the Feature Layer PTV\\_PreferredRoutes is enabled). The available types can be requested through the xRuntime service and are documented in the manual as layer-specific properties of the Feature Layer PTV\\_PreferredRoutes. If this parameter is not present, all types of PTV\\_PreferredRoutes are displayed.",
          "required" : false,
          "type" : "string",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "timeConsideration",
          "in" : "query",
          "description" : "Specifies how to evaluate Feature Layer attributes which contain time restrictions. For time consideration scenario `NONE` the parameters for reference time and timespan are not evaluated. For `SNAPSHOT`, `TIME_SPAN`, `EXACT_TIME_AT_START` and `EXACT_TIME_AT_ARRIVAL` the reference time is required. The time span is needed for the `TIME_SPAN` scenarios. For detailed information about time consideration scenarios see time consideration.",
          "required" : false,
          "type" : "string",
          "enum" : [ "NONE", "SNAPSHOT", "TIME_SPAN", "EXACT_TIME_AT_START", "EXACT_TIME_AT_ARRIVAL", "OPTIMISTIC" ],
          "x-ms-parameter-grouping" : { },
          "x-ms-enum" : {
            "name" : "TimeConsiderationScenario",
            "modelAsString" : false
          }
        }, {
          "name" : "referenceTime",
          "in" : "query",
          "description" : "The reference time at which Feature Layer attributes with time restrictions will be evaluated. The time format either has to conform to the notation of xs:dateTime such as 2015-12-24T12:00:00+01:00, or it has to be a datetime sequence without any delimiters nor time zone specification such as 20151224T120000. If the time-zone offset is missing, the corresponding service tries to detect it by means of information available in the calling context. A detailed description of this behavior can be found in the technical concept time zones. It is recommended to always specify the time zone. If no reference time is set, the current UTC time is used.",
          "required" : false,
          "type" : "string",
          "format" : "date-time",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "timeSpan",
          "in" : "query",
          "description" : "The duration of time (in combination with reference time as start) at which Feature Layer attributes with time restrictions will be evaluated, defined in \\[s\\]. The value is rounded to whole seconds.",
          "required" : false,
          "type" : "number",
          "format" : "double",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "contentSnapshotId",
          "in" : "query",
          "description" : "Specifies the content snapshot to use. If no snapshot ID is set, the most recent content is used.",
          "required" : false,
          "type" : "string",
          "x-ms-parameter-grouping" : { }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/RouteResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rest/XRuntime/2.26/dataInformation" : {
      "get" : {
        "tags" : [ "xRuntime" ],
        "description" : "Returns information about the data used by PTV xServer as a REST service.",
        "operationId" : "dataInformation",
        "parameters" : [ {
          "name" : "returnOnlyLicensedMapFeatures",
          "in" : "query",
          "description" : "Specifies if all DataInformationResponse.mapFeatures shall be returned or only the licensed ones.",
          "required" : false,
          "type" : "boolean",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "continents",
          "in" : "query",
          "description" : "Specifies if the DataInformationResponse.continents shall be returned.",
          "required" : false,
          "type" : "boolean",
          "x-ms-parameter-grouping" : { }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/DataInformationResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rest/XRuntime/2.26/icon/{iconReference}" : {
      "get" : {
        "tags" : [ "xRuntime" ],
        "description" : "Returns icons as a REST service.",
        "operationId" : "icon",
        "produces" : [ "image/png", "image/jpeg", "image/bmp" ],
        "parameters" : [ {
          "name" : "iconReference",
          "in" : "path",
          "description" : "Specifies the icon reference, e.g. returned in an xMap response Feature.iconReference.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "type" : "file"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rest/XRuntime/2.26/profiles" : {
      "get" : {
        "tags" : [ "xRuntime" ],
        "description" : "Returns information on the available profiles.",
        "operationId" : "profiles",
        "parameters" : [ ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/ProfilesResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rest/XRuntime/2.26/runtimeInformation" : {
      "get" : {
        "tags" : [ "xRuntime" ],
        "description" : "Returns dynamic information about the runtime of this xServer.",
        "operationId" : "runtimeInformation",
        "parameters" : [ {
          "name" : "versionInformation",
          "in" : "query",
          "description" : "Specifies if the RuntimeInformation.versionInformation shall be returned.",
          "required" : false,
          "type" : "boolean",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "serviceInformation",
          "in" : "query",
          "description" : "Specifies if the RuntimeInformation.serviceInformation shall be returned.",
          "required" : false,
          "type" : "boolean",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "memoryStatistics",
          "in" : "query",
          "description" : "Specifies if the RuntimeInformation.memoryStatistics shall be returned.",
          "required" : false,
          "type" : "boolean",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "environment",
          "in" : "query",
          "description" : "Specifies if the RuntimeInformation.environment shall be returned.",
          "required" : false,
          "type" : "boolean",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "moduleInstances",
          "in" : "query",
          "description" : "Specifies if the RuntimeInformation.moduleInstances shall be returned.",
          "required" : false,
          "type" : "boolean",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "activeRequests",
          "in" : "query",
          "description" : "Specifies if the RuntimeInformation.activeRequests shall be returned.",
          "required" : false,
          "type" : "boolean",
          "x-ms-parameter-grouping" : { }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/RuntimeInformation"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XCluster/2.26/coverLocations" : {
      "post" : {
        "tags" : [ "xCluster" ],
        "description" : "Calculates a cluster planning for the given request. In contrast to the method planClusters, not all locations need to be covered.",
        "operationId" : "coverLocations",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/CoverLocationsRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/ClustersResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XCluster/2.26/fetchClustersResponse" : {
      "post" : {
        "tags" : [ "xCluster" ],
        "description" : "Fetches results of type ClustersResponse for the given job. If the calculation ended with an exception, fetchClustersResponse will rethrow it. If the id of the job is unknown, a XServerException with message 'unknown id' is thrown.",
        "operationId" : "fetchClustersResponse",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/JobRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/ClustersResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XCluster/2.26/fetchVisitSequenceResponse" : {
      "post" : {
        "tags" : [ "xCluster" ],
        "description" : "Fetches results of type VisitSequenceResponse for the given job. If the calculation ended with an exception, fetchVisitSequenceResponse will rethrow it. If the id of the job is unknown, a XServerException with message 'unknown id' is thrown.",
        "operationId" : "fetchVisitSequenceResponse",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/JobRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/VisitSequenceResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XCluster/2.26/fetchVisitsResponse" : {
      "post" : {
        "tags" : [ "xCluster" ],
        "description" : "Fetches results of type VisitsResponse for the given job. If the calculation ended with an exception, fetchVisitsResponse will rethrow it. If the id of the job is unknown, a XServerException with message 'unknown id' is thrown.",
        "operationId" : "fetchVisitsResponse",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/JobRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/VisitsResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XCluster/2.26/optimizeVisitSequence" : {
      "post" : {
        "tags" : [ "xCluster" ],
        "description" : "Solves visit sequencing problems with street distances. This is equivalent to a traveling salesman problem (TSP) with street distances.",
        "operationId" : "optimizeVisitSequence",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/OptimizeVisitSequenceRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/VisitSequenceResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XCluster/2.26/planClusters" : {
      "post" : {
        "tags" : [ "xCluster" ],
        "description" : "Calculates a cluster planning for the given request including all of the locations.",
        "operationId" : "planClusters",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/PlanClustersRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/ClustersResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XCluster/2.26/planVisits" : {
      "post" : {
        "tags" : [ "xCluster" ],
        "description" : "Calculates a daily visit planning for the given request in a certain planning period.",
        "operationId" : "planVisits",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/PlanVisitsRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/VisitsResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XCluster/2.26/startCoverLocations" : {
      "post" : {
        "tags" : [ "xCluster" ],
        "description" : "This is the asynchronous version of coverLocations. Calling this operation will not block until the result has been calculated. Instead of a result object, a Job object is returned which identifies the started calculation. To get status updates on a running job, use the operation watchJob. If the status changes to SUCCEEDED, the calculation was successful and the result can be obtained using fetchClustersResponse. If the job ended with status FAILED, fetchClustersResponse throws the exception that occurred during calculation.",
        "operationId" : "startCoverLocations",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/CoverLocationsRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/Job"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XCluster/2.26/startOptimizeVisitSequence" : {
      "post" : {
        "tags" : [ "xCluster" ],
        "description" : "This is the asynchronous version of optimizeVisitSequence. Calling this operation will not block until the result has been calculated. Instead of a result object, a Job object is returned which identifies the started calculation. To get status updates on a running job, use the operation watchJob. If the status changes to SUCCEEDED, the calculation was successful and the result can be obtained using fetchVisitSequenceResponse. If the job ended with status FAILED, fetchVisitSequenceResponse throws the exception that occurred during calculation.",
        "operationId" : "startOptimizeVisitSequence",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/OptimizeVisitSequenceRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/Job"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XCluster/2.26/startPlanClusters" : {
      "post" : {
        "tags" : [ "xCluster" ],
        "description" : "This is the asynchronous version of planClusters. Calling this operation will not block until the result has been calculated. Instead of a result object, a Job object is returned which identifies the started calculation. To get status updates on a running job, use the operation watchJob. If the status changes to SUCCEEDED, the calculation was successful and the result can be obtained using fetchClustersResponse. If the job ended with status FAILED, fetchClustersResponse throws the exception that occurred during calculation.",
        "operationId" : "startPlanClusters",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/PlanClustersRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/Job"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XCluster/2.26/startPlanVisits" : {
      "post" : {
        "tags" : [ "xCluster" ],
        "description" : "This is the asynchronous version of planVisits. Calling this operation will not block until the result has been calculated. Instead of a result object, a Job object is returned which identifies the started calculation. To get status updates on a running job, use the operation watchJob. If the status changes to SUCCEEDED, the calculation was successful and the result can be obtained using fetchVisitsResponse. If the job ended with status FAILED, fetchVisitsResponse throws the exception that occurred during calculation.",
        "operationId" : "startPlanVisits",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/PlanVisitsRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/Job"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XData/2.26/createContentSnapshot" : {
      "post" : {
        "tags" : [ "xData" ],
        "description" : "Creates a snapshot of the current state of automatically updated data, such as PTV\\_TrafficIncidents Feature Layer. See technical concept about content snapshots for more details. Returns the ID of the content snapshot.",
        "operationId" : "createContentSnapshot",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/CreateContentSnapshotRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/ContentSnapshotResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XData/2.26/createFeatureLayer" : {
      "post" : {
        "tags" : [ "xData" ],
        "description" : "Creates a custom Feature Layer. Returns the Feature Layer as a binary object or the layer id if the persistent mode is choosen.",
        "operationId" : "createFeatureLayer",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/CreateFeatureLayerRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/FeatureLayerResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XData/2.26/deleteContentSnapshot" : {
      "post" : {
        "tags" : [ "xData" ],
        "description" : "Deletes a content snapshot.",
        "operationId" : "deleteContentSnapshot",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/DeleteContentSnapshotRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/VoidResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XData/2.26/deleteFeatureLayer" : {
      "post" : {
        "tags" : [ "xData" ],
        "description" : "Deletes a custom Feature Layer.",
        "operationId" : "deleteFeatureLayer",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/DeleteFeatureLayerRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/VoidResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XData/2.26/deleteHighPerformanceRoutingNetwork" : {
      "post" : {
        "tags" : [ "xData" ],
        "description" : "Deletes a high-performance routing network with a given ID considering user privileges and concurrent usage.",
        "operationId" : "deleteHighPerformanceRoutingNetwork",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/DeleteHighPerformanceRoutingNetworkRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/VoidResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XData/2.26/fetchFeatureLayerResponse" : {
      "post" : {
        "tags" : [ "xData" ],
        "description" : "Fetches results of type FeatureLayerResponse for the given job. If the calculation ended with an exception, fetchFeatureLayerResponse will rethrow it. If the id of the job is unknown, a XServerException with message 'unknown id' is thrown.",
        "operationId" : "fetchFeatureLayerResponse",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/JobRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/FeatureLayerResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XData/2.26/fetchHighPerformanceRoutingNetworkResponse" : {
      "post" : {
        "tags" : [ "xData" ],
        "description" : "Fetches results of type HighPerformanceRoutingNetworkResponse for the given job. If the calculation ended with an exception, fetchHighPerformanceRoutingNetworkResponse will rethrow it. If the id of the job is unknown, a XServerException with message 'unknown id' is thrown.",
        "operationId" : "fetchHighPerformanceRoutingNetworkResponse",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/JobRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/HighPerformanceRoutingNetworkResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XData/2.26/getSegments" : {
      "post" : {
        "tags" : [ "xData" ],
        "description" : "Retrieves a list of segments from the map data according to the specified input, for example a coordinate. Returns a list of segments according to the specified criteria.",
        "operationId" : "getSegments",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/SegmentsRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/SegmentsResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XData/2.26/getTimeZone" : {
      "post" : {
        "tags" : [ "xData" ],
        "description" : "Determines the time zone for a given location.",
        "operationId" : "getTimeZone",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/TimeZoneRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/TimeZoneResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XData/2.26/listContentSnapshots" : {
      "post" : {
        "tags" : [ "xData" ],
        "description" : "Lists available content snapshots including their meta data considering user privileges.",
        "operationId" : "listContentSnapshots",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/ListContentSnapshotsRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/ContentSnapshotsListResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XData/2.26/listFeatureLayers" : {
      "post" : {
        "tags" : [ "xData" ],
        "description" : "Lists available custom Feature Layers including their meta data considering user privileges and concurrent usage. See technical concept about multitenancy on how to list Feature Layers for all available tenants or scopes.",
        "operationId" : "listFeatureLayers",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/ListFeatureLayersRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/FeatureLayersListResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XData/2.26/listHighPerformanceRoutingNetworks" : {
      "post" : {
        "tags" : [ "xData" ],
        "description" : "Lists available high-performance routing networks including their meta data considering user privileges. Both networks of the map and user-created networks are listed. Networks belonging to the map have no scope, no tenant, and cannot be deleted. See technical concept about multitenancy on how to list networks for all available tenants or scopes.",
        "operationId" : "listHighPerformanceRoutingNetworks",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/ListHighPerformanceRoutingNetworksRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/HighPerformanceRoutingNetworksListResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XData/2.26/startCreateFeatureLayer" : {
      "post" : {
        "tags" : [ "xData" ],
        "description" : "This is the asynchronous version of createFeatureLayer. Calling this operation will not block until the result has been calculated. Instead of a result object, a Job object is returned which identifies the started calculation. To get status updates on a running job, use the operation watchJob. If the status changes to SUCCEEDED, the calculation was successful and the result can be obtained using fetchFeatureLayerResponse. If the job ended with status FAILED, fetchFeatureLayerResponse throws the exception that occurred during calculation.",
        "operationId" : "startCreateFeatureLayer",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/CreateFeatureLayerRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/Job"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XData/2.26/startCreateHighPerformanceRoutingNetwork" : {
      "post" : {
        "tags" : [ "xData" ],
        "description" : "Creates a high-performance routing network. Returns the ID of the high-performance routing network. Calling this operation will not block until the result has been calculated. Instead of a result object, a Job object is returned which identifies the started calculation. To get status updates on a running job, use the operation watchJob. If the status changes to SUCCEEDED, the calculation was successful and the result can be obtained using fetchHighPerformanceRoutingNetworkResponse. If the job ended with status FAILED, fetchHighPerformanceRoutingNetworkResponse throws the exception that occurred during calculation.",
        "operationId" : "startCreateHighPerformanceRoutingNetwork",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/CreateHighPerformanceRoutingNetworkRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/Job"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XDima/2.26/createDistanceMatrix" : {
      "post" : {
        "tags" : [ "xDima" ],
        "description" : "Creates a distance matrix by calculating road distances and travel times between given locations. An InvalidValueException is returned if the Feature Layer theme PTV\\_RestrictionZones is activated. PTV\\_RestrictionZones cannot be used for distance matrices. Returns a summary of this distance matrix calculation.",
        "operationId" : "createDistanceMatrix",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/CreateDistanceMatrixRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/DistanceMatrixResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XDima/2.26/deleteDistanceMatrix" : {
      "post" : {
        "tags" : [ "xDima" ],
        "description" : "Deletes a distance matrix with a given ID considering user privileges and concurrent usage.",
        "operationId" : "deleteDistanceMatrix",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/DeleteDistanceMatrixRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/VoidResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XDima/2.26/fetchDistanceMatrixResponse" : {
      "post" : {
        "tags" : [ "xDima" ],
        "description" : "Fetches results of type DistanceMatrixResponse for the given job. If the calculation ended with an exception, fetchDistanceMatrixResponse will rethrow it. If the id of the job is unknown, a XServerException with message 'unknown id' is thrown.",
        "operationId" : "fetchDistanceMatrixResponse",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/JobRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/DistanceMatrixResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XDima/2.26/getDistanceMatrix" : {
      "post" : {
        "tags" : [ "xDima" ],
        "description" : "Gets the distance matrix contents for specific matrix elements specified as relations between route locations or specified as an array of start and destination locations. Returns arrays representing the matrix contents for the requested part of the matrix.",
        "operationId" : "getDistanceMatrix",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/GetDistanceMatrixRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/DistanceMatrixResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XDima/2.26/listDistanceMatrices" : {
      "post" : {
        "tags" : [ "xDima" ],
        "description" : "Lists available distance matrices including their meta data considering user privileges and concurrent usage. See technical concept about multitenancy how to list matrices for all available tenants or scopes.",
        "operationId" : "listDistanceMatrices",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/ListDistanceMatricesRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/DistanceMatrixListResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XDima/2.26/startCreateDistanceMatrix" : {
      "post" : {
        "tags" : [ "xDima" ],
        "description" : "This is the asynchronous version of createDistanceMatrix. Calling this operation will not block until the result has been calculated. Instead of a result object, a Job object is returned which identifies the started calculation. To get status updates on a running job, use the operation watchJob. If the status changes to SUCCEEDED, the calculation was successful and the result can be obtained using fetchDistanceMatrixResponse. If the job ended with status FAILED, fetchDistanceMatrixResponse throws the exception that occurred during calculation.",
        "operationId" : "startCreateDistanceMatrix",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/CreateDistanceMatrixRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/Job"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XDima/2.26/startUpdateDistanceMatrix" : {
      "post" : {
        "tags" : [ "xDima" ],
        "description" : "This is the asynchronous version of updateDistanceMatrix. Calling this operation will not block until the result has been calculated. Instead of a result object, a Job object is returned which identifies the started calculation. To get status updates on a running job, use the operation watchJob. If the status changes to SUCCEEDED, the calculation was successful and the result can be obtained using fetchDistanceMatrixResponse. If the job ended with status FAILED, fetchDistanceMatrixResponse throws the exception that occurred during calculation.",
        "operationId" : "startUpdateDistanceMatrix",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/UpdateDistanceMatrixRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/Job"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XDima/2.26/updateDistanceMatrix" : {
      "post" : {
        "tags" : [ "xDima" ],
        "description" : "Updates an existing distance matrix by extending it with new locations or overwriting existing entries. Returns a summary of this distance matrix calculation.",
        "operationId" : "updateDistanceMatrix",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/UpdateDistanceMatrixRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/DistanceMatrixResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XLoad/2.26/fetchPackedBinsResponse" : {
      "post" : {
        "tags" : [ "xLoad" ],
        "description" : "Fetches results of type PackedBinsResponse for the given job. If the calculation ended with an exception, fetchPackedBinsResponse will rethrow it. If the id of the job is unknown, a XServerException with message 'unknown id' is thrown.",
        "operationId" : "fetchPackedBinsResponse",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/JobRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/PackedBinsResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XLoad/2.26/packBins" : {
      "post" : {
        "tags" : [ "xLoad" ],
        "description" : "Performs a bin packing operation as described by the request.",
        "operationId" : "packBins",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/PackBinsRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/PackedBinsResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XLoad/2.26/startPackBins" : {
      "post" : {
        "tags" : [ "xLoad" ],
        "description" : "This is the asynchronous version of packBins. Calling this operation will not block until the result has been calculated. Instead of a result object, a Job object is returned which identifies the started calculation. To get status updates on a running job, use the operation watchJob. If the status changes to SUCCEEDED, the calculation was successful and the result can be obtained using fetchPackedBinsResponse. If the job ended with status FAILED, fetchPackedBinsResponse throws the exception that occurred during calculation.",
        "operationId" : "startPackBins",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/PackBinsRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/Job"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XLocate/2.26/fetchLocationsBulkResponse" : {
      "post" : {
        "tags" : [ "xLocate" ],
        "description" : "Fetches results of type LocationsBulkResponse for the given job. If the calculation ended with an exception, fetchLocationsBulkResponse will rethrow it. If the id of the job is unknown, a XServerException with message 'unknown id' is thrown.",
        "operationId" : "fetchLocationsBulkResponse",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/JobRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/LocationsBulkResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XLocate/2.26/searchLocations" : {
      "post" : {
        "tags" : [ "xLocate" ],
        "description" : "Searches for locations matching a given address",
        "operationId" : "searchLocations",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/SearchLocationsRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/LocationsResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XLocate/2.26/searchLocationsInBulk" : {
      "post" : {
        "tags" : [ "xLocate" ],
        "description" : "For each element of a list of addresses, searches for locations matching that address.",
        "operationId" : "searchLocationsInBulk",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/SearchLocationsBulkRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/LocationsBulkResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XLocate/2.26/startSearchLocationsInBulk" : {
      "post" : {
        "tags" : [ "xLocate" ],
        "description" : "This is the asynchronous version of searchLocationsInBulk. Calling this operation will not block until the result has been calculated. Instead of a result object, a Job object is returned which identifies the started calculation. To get status updates on a running job, use the operation watchJob. If the status changes to SUCCEEDED, the calculation was successful and the result can be obtained using fetchLocationsBulkResponse. If the job ended with status FAILED, fetchLocationsBulkResponse throws the exception that occurred during calculation.",
        "operationId" : "startSearchLocationsInBulk",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/SearchLocationsBulkRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/Job"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XMap/2.26/renderMap" : {
      "post" : {
        "tags" : [ "xMap" ],
        "description" : "Render image(s) of a map and return information on drawn Feature Layer data.",
        "operationId" : "renderMap",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/MapRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/MapResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XMatch/2.26/fetchTrackResponse" : {
      "post" : {
        "tags" : [ "xMatch" ],
        "description" : "Fetches results of type TrackResponse for the given job. If the calculation ended with an exception, fetchTrackResponse will rethrow it. If the id of the job is unknown, a XServerException with message 'unknown id' is thrown.",
        "operationId" : "fetchTrackResponse",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/JobRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/TrackResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XMatch/2.26/matchPositions" : {
      "post" : {
        "tags" : [ "xMatch" ],
        "description" : "Matches positions which do not necessarily belong together",
        "operationId" : "matchPositions",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/MatchPositionsRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/PositionsResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XMatch/2.26/matchTrack" : {
      "post" : {
        "tags" : [ "xMatch" ],
        "description" : "Matches a complete track and returns the path(s) driven by the vehicle",
        "operationId" : "matchTrack",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/MatchTrackRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/TrackResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XMatch/2.26/startMatchTrack" : {
      "post" : {
        "tags" : [ "xMatch" ],
        "description" : "This is the asynchronous version of matchTrack. Calling this operation will not block until the result has been calculated. Instead of a result object, a Job object is returned which identifies the started calculation. To get status updates on a running job, use the operation watchJob. If the status changes to SUCCEEDED, the calculation was successful and the result can be obtained using fetchTrackResponse. If the job ended with status FAILED, fetchTrackResponse throws the exception that occurred during calculation.",
        "operationId" : "startMatchTrack",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/MatchTrackRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/Job"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XRoute/2.26/calculateReachableAreas" : {
      "post" : {
        "tags" : [ "xRoute" ],
        "description" : "Calculate the areas which can be reached from a location within given horizons. This operation requires a special license.",
        "operationId" : "calculateReachableAreas",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/ReachableAreasRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/ReachableAreasResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XRoute/2.26/calculateReachableLocations" : {
      "post" : {
        "tags" : [ "xRoute" ],
        "description" : "Calculates the locations that can be reached from a waypoint within a given horizon.",
        "operationId" : "calculateReachableLocations",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/ReachableLocationsRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/ReachableLocationsResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XRoute/2.26/calculateRoute" : {
      "post" : {
        "tags" : [ "xRoute" ],
        "description" : "Calculates and returns route information.",
        "operationId" : "calculateRoute",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/RouteRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/RouteResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XRoute/2.26/fetchReachableAreasResponse" : {
      "post" : {
        "tags" : [ "xRoute" ],
        "description" : "Fetches results of type ReachableAreasResponse for the given job. If the calculation ended with an exception, fetchReachableAreasResponse will rethrow it. If the id of the job is unknown, a XServerException with message 'unknown id' is thrown.",
        "operationId" : "fetchReachableAreasResponse",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/JobRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/ReachableAreasResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XRoute/2.26/fetchReachableLocationsResponse" : {
      "post" : {
        "tags" : [ "xRoute" ],
        "description" : "Fetches results of type ReachableLocationsResponse for the given job. If the calculation ended with an exception, fetchReachableLocationsResponse will rethrow it. If the id of the job is unknown, a XServerException with message 'unknown id' is thrown.",
        "operationId" : "fetchReachableLocationsResponse",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/JobRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/ReachableLocationsResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XRoute/2.26/fetchRouteResponse" : {
      "post" : {
        "tags" : [ "xRoute" ],
        "description" : "Fetches results of type RouteResponse for the given job. If the calculation ended with an exception, fetchRouteResponse will rethrow it. If the id of the job is unknown, a XServerException with message 'unknown id' is thrown.",
        "operationId" : "fetchRouteResponse",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/JobRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/RouteResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XRoute/2.26/getProfile" : {
      "post" : {
        "tags" : [ "xRoute" ],
        "description" : "Returns the effective profile specified by the stored and the request profile. If no request profile is specified, the response contains the complete contents of the stored profile.",
        "operationId" : "getProfile",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/ProfileRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/ProfileResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XRoute/2.26/startCalculateReachableAreas" : {
      "post" : {
        "tags" : [ "xRoute" ],
        "description" : "This is the asynchronous version of calculateReachableAreas. Calling this operation will not block until the result has been calculated. Instead of a result object, a Job object is returned which identifies the started calculation. To get status updates on a running job, use the operation watchJob. If the status changes to SUCCEEDED, the calculation was successful and the result can be obtained using fetchReachableAreasResponse. If the job ended with status FAILED, fetchReachableAreasResponse throws the exception that occurred during calculation.",
        "operationId" : "startCalculateReachableAreas",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/ReachableAreasRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/Job"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XRoute/2.26/startCalculateReachableLocations" : {
      "post" : {
        "tags" : [ "xRoute" ],
        "description" : "This is the asynchronous version of calculateReachableLocations. Calling this operation will not block until the result has been calculated. Instead of a result object, a Job object is returned which identifies the started calculation. To get status updates on a running job, use the operation watchJob. If the status changes to SUCCEEDED, the calculation was successful and the result can be obtained using fetchReachableLocationsResponse. If the job ended with status FAILED, fetchReachableLocationsResponse throws the exception that occurred during calculation.",
        "operationId" : "startCalculateReachableLocations",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/ReachableLocationsRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/Job"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XRoute/2.26/startCalculateRoute" : {
      "post" : {
        "tags" : [ "xRoute" ],
        "description" : "This is the asynchronous version of calculateRoute. Calling this operation will not block until the result has been calculated. Instead of a result object, a Job object is returned which identifies the started calculation. To get status updates on a running job, use the operation watchJob. If the status changes to SUCCEEDED, the calculation was successful and the result can be obtained using fetchRouteResponse. If the job ended with status FAILED, fetchRouteResponse throws the exception that occurred during calculation.",
        "operationId" : "startCalculateRoute",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/RouteRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/Job"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XRuntime/2.26/deleteJob" : {
      "post" : {
        "tags" : [ "xRuntime" ],
        "description" : "Attempts to delete a running job. If successful, the returned job will have state DELETED.",
        "operationId" : "deleteJob",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/JobRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/Job"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XRuntime/2.26/deleteRequest" : {
      "post" : {
        "tags" : [ "xRuntime" ],
        "description" : "Immediately deletes a running request.",
        "operationId" : "deleteRequest",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/StopDeleteRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/VoidResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XRuntime/2.26/getDataInformation" : {
      "post" : {
        "tags" : [ "xRuntime" ],
        "description" : "Returns information about the data used by PTV xServer.",
        "operationId" : "getDataInformation",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/DataInformationRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/DataInformationResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XRuntime/2.26/getRuntimeInformation" : {
      "post" : {
        "tags" : [ "xRuntime" ],
        "description" : "Returns dynamic information about the runtime of this xServer.",
        "operationId" : "getRuntimeInformation",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/RuntimeInformationRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/RuntimeInformation"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XRuntime/2.26/getServerConfiguration" : {
      "post" : {
        "tags" : [ "xRuntime" ],
        "description" : "Returns information on the configuration of the xServer.",
        "operationId" : "getServerConfiguration",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/ServerConfigurationRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/ServerConfigurationResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XRuntime/2.26/stopJob" : {
      "post" : {
        "tags" : [ "xRuntime" ],
        "description" : "Attempts to stop a running job. If the status of the job changes to SUCCEEDED, preliminary results can be fetched, if available.",
        "operationId" : "stopJob",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/JobRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/Job"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XRuntime/2.26/stopRequest" : {
      "post" : {
        "tags" : [ "xRuntime" ],
        "description" : "Tries to stop a running request.",
        "operationId" : "stopRequest",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/StopDeleteRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/VoidResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XRuntime/2.26/watchJob" : {
      "post" : {
        "tags" : [ "xRuntime" ],
        "description" : "Returns the status of the given job.",
        "operationId" : "watchJob",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/WatchRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/Job"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XTour/2.26/changeTours" : {
      "post" : {
        "tags" : [ "xTour" ],
        "description" : "Change existing tours via specified actions. Returns a plan containing the changed tours and reports with additional information about those changed tours. The source tour(s) and target tour are always returned even if the tours did not change (for example if an addTripAction with an insertion position of type insertion at best position does not find a valid insertion position). Furthermore the stored request will be the original PlanToursRequest with changed tours information contained in the input plan.",
        "operationId" : "changeTours",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/ChangeToursRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/ToursResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XTour/2.26/evaluateToursInExecution" : {
      "post" : {
        "tags" : [ "xTour" ],
        "description" : "Calculate time profile for a tour in execution. Returns tour reports containing the time profile starting at the current position of each specified vehicle.",
        "operationId" : "evaluateToursInExecution",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/ToursInExecutionRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/ToursResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XTour/2.26/fetchChangeToursProposalsResponse" : {
      "post" : {
        "tags" : [ "xTour" ],
        "description" : "Fetches results of type ChangeToursProposalsResponse for the given job. If the calculation ended with an exception, fetchChangeToursProposalsResponse will rethrow it. If the id of the job is unknown, a XServerException with message 'unknown id' is thrown.",
        "operationId" : "fetchChangeToursProposalsResponse",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/JobRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/ChangeToursProposalsResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XTour/2.26/fetchToursResponse" : {
      "post" : {
        "tags" : [ "xTour" ],
        "description" : "Fetches results of type ToursResponse for the given job. If the calculation ended with an exception, fetchToursResponse will rethrow it. If the id of the job is unknown, a XServerException with message 'unknown id' is thrown.",
        "operationId" : "fetchToursResponse",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/JobRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/ToursResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XTour/2.26/findChangeToursProposals" : {
      "post" : {
        "tags" : [ "xTour" ],
        "description" : "Propose ChangeToursActions to change an existing tour plan as desired. Returns proposed ChangeToursActions with resulting TourReports if the corresponding ChangeToursAction would be applied via a ChangeToursRequest.",
        "operationId" : "findChangeToursProposals",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/FindChangeToursProposalsRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/ChangeToursProposalsResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XTour/2.26/planTours" : {
      "post" : {
        "tags" : [ "xTour" ],
        "description" : "Plan tours that ideally include all orders that are specified in the request. Returns a plan with tours and reports with additional information about the planned tours.",
        "operationId" : "planTours",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/PlanToursRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/ToursResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XTour/2.26/startChangeTours" : {
      "post" : {
        "tags" : [ "xTour" ],
        "description" : "This is the asynchronous version of changeTours. Calling this operation will not block until the result has been calculated. Instead of a result object, a Job object is returned which identifies the started calculation. To get status updates on a running job, use the operation watchJob. If the status changes to SUCCEEDED, the calculation was successful and the result can be obtained using fetchToursResponse. If the job ended with status FAILED, fetchToursResponse throws the exception that occurred during calculation.",
        "operationId" : "startChangeTours",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/ChangeToursRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/Job"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XTour/2.26/startEvaluateToursInExecution" : {
      "post" : {
        "tags" : [ "xTour" ],
        "description" : "This is the asynchronous version of evaluateToursInExecution. Calling this operation will not block until the result has been calculated. Instead of a result object, a Job object is returned which identifies the started calculation. To get status updates on a running job, use the operation watchJob. If the status changes to SUCCEEDED, the calculation was successful and the result can be obtained using fetchToursResponse. If the job ended with status FAILED, fetchToursResponse throws the exception that occurred during calculation.",
        "operationId" : "startEvaluateToursInExecution",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/ToursInExecutionRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/Job"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XTour/2.26/startFindChangeToursProposals" : {
      "post" : {
        "tags" : [ "xTour" ],
        "description" : "This is the asynchronous version of findChangeToursProposals. Calling this operation will not block until the result has been calculated. Instead of a result object, a Job object is returned which identifies the started calculation. To get status updates on a running job, use the operation watchJob. If the status changes to SUCCEEDED, the calculation was successful and the result can be obtained using fetchChangeToursProposalsResponse. If the job ended with status FAILED, fetchChangeToursProposalsResponse throws the exception that occurred during calculation.",
        "operationId" : "startFindChangeToursProposals",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/FindChangeToursProposalsRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/Job"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    },
    "/services/rs/XTour/2.26/startPlanTours" : {
      "post" : {
        "tags" : [ "xTour" ],
        "description" : "This is the asynchronous version of planTours. Calling this operation will not block until the result has been calculated. Instead of a result object, a Job object is returned which identifies the started calculation. To get status updates on a running job, use the operation watchJob. If the status changes to SUCCEEDED, the calculation was successful and the result can be obtained using fetchToursResponse. If the job ended with status FAILED, fetchToursResponse throws the exception that occurred during calculation.",
        "operationId" : "startPlanTours",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/PlanToursRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/Job"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    }
  },
  "definitions" : {
    "AbsoluteDirection" : {
      "type" : "number",
      "format" : "double",
      "description" : "Defines a direction through a clockwise angle with respect to north in degrees \\[??\\], e.g., 0?? is north, 90?? is east, 180?? is south, and 270?? is west. Range: 0 ??? value ??? 360.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.AbsoluteDirection"
    },
    "AbsoluteDirectionInteger" : {
      "type" : "integer",
      "format" : "int32",
      "description" : "Defines a direction through a clockwise angle with respect to north in degrees \\[??\\], e.g., 0?? is north, 90?? is east, 180?? is south, and 270?? is west. Range: 0 ??? value ??? 360.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.AbsoluteDirectionInteger"
    },
    "AccessDeniedFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RejectedRequestFault"
      }, {
        "type" : "object",
        "description" : "This fault is thrown if the sender does not have the rights to execute the request. This may be due to required admin privileges or blocked methods by a middleware.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.AccessDeniedFault"
      } ],
      "x-discriminator-value" : "AccessDeniedFault",
      "x-ms-discriminator-value" : "AccessDeniedFault"
    },
    "AccessType" : {
      "type" : "string",
      "description" : "Indicates if a range of segments is entered or exited or both at the same time. The latter could be true, if the range consists of only few segments or nodes.  \n * `ENTER` - Indicates the entering of a range of segments.  \n * `EXIT` - Indicates the exiting of a range of segments.  \n * `PASS` - Indicates that the range is very small.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.xroute.AccessType",
      "enum" : [ "ENTER", "EXIT", "PASS" ],
      "x-ms-enum" : {
        "name" : "AccessType",
        "modelAsString" : false
      }
    },
    "ActivityCapacity" : {
      "type" : "object",
      "required" : [ "value" ],
      "properties" : {
        "clusterId" : {
          "type" : "string",
          "description" : "The ID of the cluster whose activity shall be adjusted. In the plan clusters use case, this field can be left out for optional clusters."
        },
        "value" : {
          "type" : "number",
          "format" : "double",
          "description" : "The activity capacity for the cluster."
        }
      },
      "description" : "States the activity capacity for the output clusters. Activity capacities will be freely over or underutilized proportionally with regards to other output clusters to be able to assign all available activity.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.ActivityCapacity"
    },
    "AddFixationsAction" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ChangeToursAction"
      }, {
        "type" : "object",
        "properties" : {
          "fixations" : {
            "type" : "array",
            "items" : {
              "description" : "Fixations to be added to the current plan.",
              "$ref" : "#/definitions/Fixation"
            }
          }
        },
        "description" : "A specific action to add fixations to the current plan. If at least one of the fixations references the ID of a nonexistent object, an exception is thrown and none of the fixations is added. If one of the fixations is already existing in the current plan, no exception is thrown but the fixation is just ignored.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.AddFixationsAction"
      } ],
      "x-discriminator-value" : "AddFixationsAction",
      "x-ms-discriminator-value" : "AddFixationsAction"
    },
    "AddTripAction" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ChangeToursAction"
      }, {
        "type" : "object",
        "required" : [ "insertionPosition", "targetVehicleId" ],
        "properties" : {
          "orderIds" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "description" : "IDs of orders from which a trip is created. Orders that cannot be planned end up in orderIdsNotPlanned after performing the AddTripAction. All referenced orders need to be unplanned."
            }
          },
          "targetVehicleId" : {
            "type" : "string",
            "description" : "ID of the vehicle for that a trip is added. The vehicle can be empty or already have a tour with one or more trips assigned."
          },
          "insertionPosition" : {
            "description" : "InsertionPosition of the trip that is added. If InsertionPosition is of type InsertionAtBestPosition, orders in orderIds that can not be moved to the target vehicle are listed in a NoValidInsertionPositionFoundLimitation as objectIds.",
            "$ref" : "#/definitions/InsertionPosition"
          }
        },
        "description" : "A specific action to create a single trip of specified orders for a specified vehicle instance. The trip can be created for an unplanned vehicle or within a tour of an already planned vehicle. For an AddTripAction at a specified position a trip of at least one order is created even if the resulting tour becomes invalid but remains structurally valid.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.AddTripAction"
      } ],
      "x-discriminator-value" : "AddTripAction",
      "x-ms-discriminator-value" : "AddTripAction"
    },
    "AddTripStartIntervalsAction" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ChangeToursAction"
      }, {
        "type" : "object",
        "properties" : {
          "tripStartIntervals" : {
            "type" : "array",
            "items" : {
              "description" : "TripStartIntervals to be added to the current plan.",
              "$ref" : "#/definitions/TripStartInterval"
            }
          }
        },
        "description" : "A specific action to add trip start intervals to the current plan. If at least one of the trip start intervals references the trip ID of a nonexistent trip or if a trip start interval is added again for the same trip ID, an exception is thrown and none of the trip start intervals is added.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.AddTripStartIntervalsAction"
      } ],
      "x-discriminator-value" : "AddTripStartIntervalsAction",
      "x-ms-discriminator-value" : "AddTripStartIntervalsAction"
    },
    "Address" : {
      "type" : "object",
      "properties" : {
        "country" : {
          "type" : "string",
          "description" : "The country. In a response, it is represented by its full name (not abbreviated or encoded) unless a different representation is requested via SearchOptions.outputCountryType."
        },
        "state" : {
          "type" : "string",
          "description" : "The name of the principal country subdivision which the address belongs to (for example, a state in the USA, or a canton in Switzerland)."
        },
        "province" : {
          "type" : "string",
          "description" : "The name of the second-level country subdivision which the address belongs to (for example, a county in the UK, or a province in Italy)."
        },
        "postalCode" : {
          "type" : "string",
          "description" : "The postal code of the address."
        },
        "city" : {
          "type" : "string",
          "description" : "The city of the address, i.e. the highest entity at the communal level which the address belongs to."
        },
        "district" : {
          "type" : "string",
          "description" : "The district of the address, i.e. the entity below city."
        },
        "subdistrict" : {
          "type" : "string",
          "description" : "The subdistrict of the address, i.e. the entity below district."
        },
        "street" : {
          "type" : "string",
          "description" : "The street of the address."
        },
        "houseNumber" : {
          "type" : "string",
          "description" : "The house number of the address."
        }
      },
      "description" : "Represents the address of a geographical object. Where a string, such as a city or street name, is available in multiple languages, it is returned in the default language specified by the object's location, i.e. in which country it is located. Because addressing schemes vary strongly between countries, most fields are optional.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xlocate.Address"
    },
    "AddressScores" : {
      "type" : "object",
      "properties" : {
        "country" : {
          "description" : "The score for the returned country.",
          "$ref" : "#/definitions/Percent"
        },
        "state" : {
          "description" : "The score for the returned state.",
          "$ref" : "#/definitions/Percent"
        },
        "province" : {
          "description" : "The score for the returned province.",
          "$ref" : "#/definitions/Percent"
        },
        "postalCode" : {
          "description" : "The score for the returned postal code.",
          "$ref" : "#/definitions/Percent"
        },
        "city" : {
          "description" : "The score for the returned city.",
          "$ref" : "#/definitions/Percent"
        },
        "district" : {
          "description" : "The score for the returned district.",
          "$ref" : "#/definitions/Percent"
        },
        "subdistrict" : {
          "description" : "The score for the returned subdistrict.",
          "$ref" : "#/definitions/Percent"
        },
        "street" : {
          "description" : "The score for the returned street name.",
          "$ref" : "#/definitions/Percent"
        },
        "houseNumber" : {
          "description" : "The score for the returned house number.",
          "$ref" : "#/definitions/Percent"
        }
      },
      "description" : "The scores for the fields of the result Address. Only present for fields that were given in the input Address.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xlocate.AddressScores"
    },
    "Alignment" : {
      "type" : "string",
      "description" : "Defines the alignment of a label, i.e. the position of the label which matches its geographic reference point.  \n * `TOP_LEFT` - The top left corner of the label.  \n * `TOP_CENTER` - The center of the top border of the label.  \n * `TOP_RIGHT` - The top right corner of the label.  \n * `LEFT_CENTER` - The center of the left border of the label.  \n * `CENTER` - The center of the label.  \n * `RIGHT_CENTER` - The center of the right border of the label.  \n * `BOTTOM_LEFT` - The bottom left corner of the label.  \n * `BOTTOM_CENTER` - The center of the bottom border of the label.  \n * `BOTTOM_RIGHT` - The bottom right corner of the label.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.renderingprofile.Alignment",
      "enum" : [ "TOP_LEFT", "TOP_CENTER", "TOP_RIGHT", "LEFT_CENTER", "CENTER", "RIGHT_CENTER", "BOTTOM_LEFT", "BOTTOM_CENTER", "BOTTOM_RIGHT" ],
      "x-ms-enum" : {
        "name" : "Alignment",
        "modelAsString" : false
      }
    },
    "AllowedItemOrientations" : {
      "type" : "object",
      "properties" : {
        "original" : {
          "type" : "boolean",
          "description" : "Item are is allowed to be packed unrotated. Dimensions stay (x,y,z)."
        },
        "x" : {
          "type" : "boolean",
          "description" : "Items are allowed to be packed rotated widthwise (around x-axis) by 90 degrees. Dimensions would be (x,z,y)."
        },
        "y" : {
          "type" : "boolean",
          "description" : "Items are allowed to be packed rotated heightwise (around y-axis) by 90 degrees. Dimensions would be (z,y,x)."
        },
        "z" : {
          "type" : "boolean",
          "description" : "Items are allowed to be packed rotated lengthwise (around z-axis) by 90 degrees. Dimensions would be (y,x,z)."
        },
        "xz" : {
          "type" : "boolean",
          "description" : "Items are allowed to be packed rotated width- then heightwise (around x- then z-axis) by 90 degrees. Dimensions would be (z,x,y)."
        },
        "yz" : {
          "type" : "boolean",
          "description" : "Items are allowed to be packed rotated length- then heightwise (around its y- then z-axis) by 90 degrees. Dimensions would be (y,z,x)."
        }
      },
      "description" : "Describes the allowed orientations for items. Depending on how an item is oriented, load will be applied on a different axis of the item if something is stacked on top of it. See ItemOrientation.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xload.AllowedItemOrientations"
    },
    "AlternativeRoute" : {
      "type" : "object",
      "required" : [ "distance", "travelTime", "violated" ],
      "properties" : {
        "distance" : {
          "description" : "The distance of the complete route.",
          "type" : "number"
        },
        "travelTime" : {
          "description" : "The travel time for the complete route.",
          "$ref" : "#/definitions/Duration"
        },
        "trafficDelay" : {
          "description" : "The total delay due to traffic incidents (traffic jams, construction sites etc.) on the route.\r\n\r\nFor each section of the route where traffic incidents are present, the delay is calculated comparing the travel time for that section with and without traffic incidents. That means the delay contains the time that it takes longer to pass the traffic jam than usually at the same time and the same day of week. As an example, driving a section on a highway between two exits usually takes 15 minutes on an average Friday afternoon at 4 pm, but due to a road works there is a traffic jam on this specific Friday afternoon at 4 pm, and driving this section takes 30 minutes. The delay will be 15 minutes.\r\n\r\nThis value will be non-zero only when Feature Layer PTV\\_TrafficIncidents is enabled and one of the time-consideration scenarios ExactTimeConsiderationAtStart and ExactTimeConsiderationAtArrival is used.",
          "$ref" : "#/definitions/Duration"
        },
        "violated" : {
          "type" : "boolean",
          "description" : "If set to true, indicates that this route contains a violation for the chosen vehicle."
        },
        "encodedPath" : {
          "description" : "The encoded string describing the complete path of the calculated route. Use this string as an input of another route request to calculate the same route with different parameters.  \r\nIt is only returned if requested by ResultFields.encodedPath.",
          "$ref" : "#/definitions/EncodedContent"
        },
        "polyline" : {
          "description" : "The polyline of the complete alternative route. This polyline consists of all coordinates representing the alternative route and can be used to draw the route into a map.  \r\nIt is only returned if requested by ResultFields.polyline.",
          "$ref" : "#/definitions/EncodedGeometry"
        }
      },
      "description" : "Contains basic information about an alternative route for the current route.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.AlternativeRoute"
    },
    "AmbiguousInsertionPositionFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TripStructureFault"
      }, {
        "type" : "object",
        "required" : [ "orderId", "taskType" ],
        "properties" : {
          "orderId" : {
            "type" : "string",
            "description" : "ID of the order with unclear insertion position."
          },
          "taskType" : {
            "description" : "Task type of the task with unclear insertion position.",
            "$ref" : "#/definitions/TaskType"
          }
        },
        "description" : "This fault is thrown if the insertion position of an order is not clearly determinable.\r\n\r\nThe insertion position of an order contained in a MoveOrdersAction can be ambiguous. Either orders from different sites shall be moved to a specified insertion position which means the resulting stop sequence is unclear. Or all orders of the target trip shall be moved such that the target trip would be dissolved after removing the orders. In that case it is not clear how to interpret the specified insertion position when there are no more stops left.\r\n\r\nFurthermore the insertion position of a transport order contained in a stop of a MoveStopsAction can be ambiguous. More precisely a partner task belonging to a task contained in a stop of a MoveStopsAction could have multiple options where to be inserted in the target trip. For further explanation please have a look at the documentation of the MoveStopsAction.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.AmbiguousInsertionPositionFault"
      } ],
      "x-discriminator-value" : "AmbiguousInsertionPositionFault",
      "x-ms-discriminator-value" : "AmbiguousInsertionPositionFault"
    },
    "AnchorX" : {
      "type" : "integer",
      "format" : "int32",
      "description" : "Allowed value ranges are from -16 to 66. Range: -16 ??? value ??? 66.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.AnchorX"
    },
    "AnchorY" : {
      "type" : "integer",
      "format" : "int32",
      "description" : "Allowed value ranges are from -16 to 66. Range: -16 ??? value ??? 66.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.AnchorY"
    },
    "AngleDifference" : {
      "type" : "number",
      "format" : "double",
      "description" : "Defines the size of the smaller of the two angles defined by two directions in degrees \\[??\\]. Range: 0 ??? value ??? 180.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.AngleDifference"
    },
    "ApproximationTolerance" : {
      "type" : "number",
      "format" : "double",
      "description" : "Valid percentages - Range: 1.0 ??? value ??? 10.0.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.ApproximationTolerance"
    },
    "Arrived" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ServiceStatus"
      }, {
        "type" : "object",
        "description" : "Service not started yet but driver and vehicle have arrived at stop.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.tourplanning.Arrived"
      } ],
      "x-discriminator-value" : "Arrived",
      "x-ms-discriminator-value" : "Arrived"
    },
    "ArrowsStyle" : {
      "type" : "object",
      "properties" : {
        "drawStroke" : {
          "type" : "boolean",
          "description" : "Enables the visibility of the stroke, i.e. the edge, of the arrows."
        },
        "drawFill" : {
          "type" : "boolean",
          "description" : "Enables the visibility of the fill of the arrows."
        },
        "strokeColor" : {
          "description" : "The RGB color of the stroke of the arrows as a decimal or hexadecimal value.",
          "$ref" : "#/definitions/Color"
        },
        "fillColor" : {
          "description" : "The RGB color of the fill of the arrows as a decimal or hexadecimal value.",
          "$ref" : "#/definitions/Color"
        },
        "strokeOpacity" : {
          "description" : "The opacity of the stroke of the arrows in \\[%\\]. 100 represents opaque, 0 represents completely transparent.",
          "$ref" : "#/definitions/Percent"
        },
        "fillOpacity" : {
          "description" : "The opacity of the fill of the arrows in \\[%\\]. 100 represents opaque, 0 represents completely transparent.",
          "$ref" : "#/definitions/Percent"
        }
      },
      "description" : "Defines how to render arrows on top of the underlying stroke. The width of the arrows is automatically adapted to the width of the stroke.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.renderingprofile.ArrowsStyle"
    },
    "Axle" : {
      "type" : "object",
      "properties" : {
        "axleLoad" : {
          "description" : "The axle load. (2,4)",
          "$ref" : "#/definitions/Kilograms"
        },
        "numberOfAxles" : {
          "description" : "The number of axles the vehicle has. (2)",
          "$ref" : "#/definitions/NonNegativeInteger"
        }
      },
      "description" : "Defines the number of axles of the vehicle and the axle load.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.vehicleprofile.Axle"
    },
    "BinType" : {
      "type" : "object",
      "required" : [ "dimensions", "id" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "User provided ID for this type of bin. Must be unique."
        },
        "numberOfBins" : {
          "description" : "Number of bins of this type available for packing. Maximum is 1000.",
          "$ref" : "#/definitions/PositiveInteger"
        },
        "dimensions" : {
          "description" : "Inner dimensions of a single bin of this type. Along each axis the dimension should be between 1 and 5000 cm. The maximum volume of a bin is 425.385 m?? .",
          "$ref" : "#/definitions/BoxDimensions"
        },
        "maximumVolumeCapacity" : {
          "description" : "Maximum accumulated volume of items that can be packed into a single bin of this type irrespective of bin dimensions. This value must never exceed the natural inner volume specified by dimensions. If not given, defaults to the natural inner volume specified by dimensions. Internally rounded to nearest full cubic centimeter.",
          "$ref" : "#/definitions/Volume"
        },
        "maximumWeightCapacity" : {
          "description" : "Maximum accumulated weight of items that can be packed into a single bin of this type. If not given the weight capacity is assumed to be infinite. Internally rounded to nearest full gram. The maximum allowed weight capacity is 80 t.",
          "$ref" : "#/definitions/Kilograms"
        }
      },
      "description" : "Describes a cuboid bin type into which items can be packed.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xload.BinType"
    },
    "Bounds" : {
      "type" : "object",
      "required" : [ "maxX", "maxY", "minX", "minY" ],
      "properties" : {
        "minX" : {
          "type" : "number",
          "format" : "double",
          "description" : "Minimum value for x dimension. The numerical value has to be less than or equal to maxX."
        },
        "maxX" : {
          "type" : "number",
          "format" : "double",
          "description" : "Maximum value for x dimension. The numerical value has to be greater than or equal to minX."
        },
        "minY" : {
          "type" : "number",
          "format" : "double",
          "description" : "Minimum value for y dimension. The numerical value has to be less than or equal to maxY."
        },
        "maxY" : {
          "type" : "number",
          "format" : "double",
          "description" : "Maximum value for y dimension. The numerical value has to be greater than or equal to minY."
        }
      },
      "description" : "Boundaries are used for defining the minimal boundary rectangle of a geographical object. It contains the minimum and maximum values for x and y dimension.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.geometry.Bounds"
    },
    "BoxDimensions" : {
      "type" : "object",
      "required" : [ "x", "y", "z" ],
      "properties" : {
        "x" : {
          "description" : "Extent along x-axis (width). Rounded to nearest full centimeter internally.",
          "$ref" : "#/definitions/Dimension"
        },
        "y" : {
          "description" : "Extent along y-axis (height). Rounded to nearest full centimeter internally.",
          "$ref" : "#/definitions/Dimension"
        },
        "z" : {
          "description" : "Extent along z-axis (length). Rounded to nearest full centimeter internally.",
          "$ref" : "#/definitions/Dimension"
        }
      },
      "description" : "Size of an item or bin. See ItemPosition for a description of the coordinate system.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xload.BoxDimensions"
    },
    "BreakInterval" : {
      "type" : "object",
      "required" : [ "breakTime", "interval" ],
      "properties" : {
        "interval" : {
          "description" : "Interval within which the driver wants or needs to take a break. Interval must be at least as long as the break time.",
          "$ref" : "#/definitions/Interval"
        },
        "breakTime" : {
          "description" : "The duration of the break to be scheduled within the interval. Must be greater than 0.",
          "$ref" : "#/definitions/Duration"
        }
      },
      "description" : "A break interval is a time interval together with the required duration of the break that shall be scheduled within the interval. Such a break may be scheduled en route between stops. Due to the fact that service time is never split, the driver may have to wait at a stop for the beginning of the next break interval and only begin with the service after the break.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.BreakInterval"
    },
    "BulkProgress" : {
      "allOf" : [ {
        "$ref" : "#/definitions/JobProgress"
      }, {
        "type" : "object",
        "required" : [ "failed", "remaining", "successful" ],
        "properties" : {
          "remaining" : {
            "description" : "Specifies how many requests have still to be calculated.",
            "$ref" : "#/definitions/NonNegativeInteger"
          },
          "successful" : {
            "description" : "The number of successful calculations so far.",
            "$ref" : "#/definitions/NonNegativeInteger"
          },
          "failed" : {
            "description" : "The number of failed computations so far.",
            "$ref" : "#/definitions/NonNegativeInteger"
          }
        },
        "description" : "Default implementation for bulk jobs.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.jobs.BulkProgress"
      } ],
      "x-discriminator-value" : "BulkProgress",
      "x-ms-discriminator-value" : "BulkProgress"
    },
    "ChangeToursAction" : {
      "type" : "object",
      "required" : [ "$type", "storedRequestId" ],
      "discriminator" : "$type",
      "properties" : {
        "storedRequestId" : {
          "type" : "string",
          "description" : "ID of the stored PlanToursRequest that contains all information about the tours to be changed as input plan. This request with changed input plan containing the tours information after the ChangeToursAction will be again stored in the session storage and the ID of the stored request will be returned as stored request."
        },
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "The abstract base type for all specified actions to change tours.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.ChangeToursAction"
    },
    "ChangeToursProposal" : {
      "type" : "object",
      "properties" : {
        "changeToursAction" : {
          "description" : "The proposed ChangeToursAction that could be applied to the tour plan via a ChangeToursRequest.",
          "$ref" : "#/definitions/ChangeToursAction"
        },
        "tours" : {
          "type" : "array",
          "items" : {
            "description" : "Resulting tours if the proposed ChangeToursAction would be applied. Dependent on the ChangeToursProposalsQuery different tours are part of the result. At least the target tour of the ChangeToursAction is contained in these tours.",
            "$ref" : "#/definitions/Tour"
          }
        },
        "tourReports" : {
          "type" : "array",
          "items" : {
            "description" : "TourReports corresponding to the tours.",
            "$ref" : "#/definitions/TourReport"
          }
        },
        "vehicleIdsNotPlanned" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "description" : "References to vehicle instances that were planned before but would no longer be planned after performing the ChangeToursAction. These vehicles are not part of the tours."
          }
        },
        "violated" : {
          "type" : "boolean",
          "description" : "True if there is any tour violation."
        },
        "preferencesRespected" : {
          "type" : "boolean",
          "description" : "True if all preferences for order group consideration and single stop per customer are respected."
        }
      },
      "description" : "A ChangeToursProposal contains a ChangeToursAction with information about the resulting ToursResponse if the change would be applied to the tour plan.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.ChangeToursProposal"
    },
    "ChangeToursProposalsOptions" : {
      "type" : "object",
      "properties" : {
        "returnViolatedTours" : {
          "type" : "boolean",
          "description" : "Set to true if the response should also contain target tours with TourViolation."
        }
      },
      "description" : "Options for the propose ChangeToursAction operation.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.ChangeToursProposalsOptions"
    },
    "ChangeToursProposalsQuery" : {
      "type" : "object",
      "required" : [ "$type", "storedRequestId" ],
      "discriminator" : "$type",
      "properties" : {
        "storedRequestId" : {
          "type" : "string",
          "description" : "ID of the stored PlanToursRequest that contains all information about the tours that could be changed as input plan. This request does not actually change the plan but just proposes changes. Thus, no new object is stored in the session storage."
        },
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "The abstract base type for all specified actions to propose ChangeToursActions.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.ChangeToursProposalsQuery"
    },
    "ChangeToursProposalsResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "properties" : {
          "proposals" : {
            "type" : "array",
            "items" : {
              "description" : "Each element contains a ChangeToursAction with more information about the resulting tour plan if the change would be applied. The list is sorted increasingly according to the internal objective function considering the overall travel and driving time of tours. If returnViolatedTours is true, then proposals might contain target tours with TourViolation. These are sorted to the back. The list can be empty if no structurally valid proposal can be found.",
              "$ref" : "#/definitions/ChangeToursProposal"
            }
          }
        },
        "description" : "Contains the result of a FindChangeToursProposalsRequest.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.ChangeToursProposalsResponse"
      } ],
      "x-discriminator-value" : "ChangeToursProposalsResponse",
      "x-ms-discriminator-value" : "ChangeToursProposalsResponse"
    },
    "ChangeToursRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "required" : [ "changeToursAction" ],
        "properties" : {
          "changeToursAction" : {
            "description" : "An action that changes the existing tours in a specified way. If the action leads to any not explicitly specified new trips or to a trip merge, an exception is thrown.",
            "$ref" : "#/definitions/ChangeToursAction"
          }
        },
        "description" : "The request object for the service method changeTours. For further information please have a look at the technical concept Change Tours.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.ChangeToursRequest"
      } ],
      "x-discriminator-value" : "ChangeToursRequest",
      "x-ms-discriminator-value" : "ChangeToursRequest"
    },
    "ChangeVehicleAction" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ChangeToursAction"
      }, {
        "type" : "object",
        "required" : [ "currentVehicleId", "targetVehicleId" ],
        "properties" : {
          "currentVehicleId" : {
            "type" : "string",
            "description" : "ID of the current vehicle of the tour."
          },
          "targetVehicleId" : {
            "type" : "string",
            "description" : "ID of the target vehicle of the tour."
          }
        },
        "description" : "A specific action to change the vehicle of a tour. Either an unused vehicle can be assigned to a tour or a vehicle swap between two tours can be executed with this action. The assignment of drivers to vehicles remains unchanged, i. e. the driver changes together with the vehicle.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.ChangeVehicleAction"
      } ],
      "x-discriminator-value" : "ChangeVehicleAction",
      "x-ms-discriminator-value" : "ChangeVehicleAction"
    },
    "Cluster" : {
      "type" : "object",
      "required" : [ "id", "referenceLocation" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "The unique identifier of this cluster."
        },
        "referenceLocation" : {
          "description" : "The geographical position of the reference point of the cluster.",
          "$ref" : "#/definitions/RouteLocation"
        }
      },
      "description" : "Represents the cluster defined by its ID and its reference point.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.Cluster"
    },
    "ClusterCompatibility" : {
      "type" : "object",
      "required" : [ "compatible" ],
      "properties" : {
        "clusterIds" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "description" : "A list of clusters,represented by their ID, that are affected by the compatibility setting. The parameter compatible specifies if the current location is compatible or incompatible to this list of cluster IDs. Each cluster mentioned here has to be specified in the list of clusters in the request."
          }
        },
        "compatible" : {
          "type" : "boolean",
          "description" : "Specifies if the whole list of cluster IDs is compatible or incompatible to the current location. If it is set to true, only the clusters from the list are compatible to the location."
        }
      },
      "description" : "Defines compatible or incompatible clusters for a location. The list of cluster IDs can either be defined as compatible or as incompatible.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.ClusterCompatibility"
    },
    "ClusterFacility" : {
      "type" : "object",
      "required" : [ "cluster" ],
      "properties" : {
        "cluster" : {
          "description" : "The cluster that is represented by this cluster facility.",
          "$ref" : "#/definitions/Cluster"
        },
        "cost" : {
          "description" : "Specifies the associated cost of the cluster facility. The cost is considered if locations are assigned according to a cost limit specified in the request. If the location assignment is done according to minimum coverage, the cost is ignored if it is set.",
          "$ref" : "#/definitions/MathematicalCost"
        },
        "capacity" : {
          "type" : "number",
          "format" : "double",
          "description" : "The sum of activities of all planning locations assigned to this cluster facility cannot exceed the given capacity value. If not set, it is assumed that all planning locations can be assigned to this cluster facility in the worst case. If set, its value should be positive. If set for each cluster facility, it could happen, that a planning location remains unplanned in the end. Furthermore, it could happen, that a cluster facility is not allocated to any planning location, i.e. the respective ClusterReport.numberOfLocations is zero and the respective ClusteredLocations.locationIds is empty."
        }
      },
      "description" : "Represents a cluster that is considered to be a facility that may rise certain cost when using it.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.ClusterFacility"
    },
    "ClusterPlanningCalculationMode" : {
      "type" : "string",
      "description" : "Enumeration to define the calculation behavior of the algorithm, i.e. if the focus of calculation is on performance, quality or both.  \n * `PERFORMANCE` - The algorithm's focus is on performance. A smaller search space for solutions is considered during the computation.  \n * `QUALITY` - The algorithm's focus is on high solution quality. A larger search space for solutions is considered during the computation.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.xcluster.CalculationMode",
      "enum" : [ "PERFORMANCE", "QUALITY" ],
      "x-ms-enum" : {
        "name" : "ClusterPlanningCalculationMode",
        "modelAsString" : false
      }
    },
    "ClusterPlanningLocation" : {
      "type" : "object",
      "required" : [ "id", "routeLocation" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "The unique identifier of this location."
        },
        "routeLocation" : {
          "description" : "The geographical position of this location.",
          "$ref" : "#/definitions/RouteLocation"
        }
      },
      "description" : "Represents a location that can be visited or assigned to a cluster.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.Location"
    },
    "ClusterPlanningProfile" : {
      "type" : "object",
      "properties" : {
        "clustering" : {
          "description" : "Contains parameter values for the basic clustering use cases.",
          "$ref" : "#/definitions/Clustering"
        },
        "covering" : {
          "description" : "Contains parameter values for the covering or reachability use cases.",
          "$ref" : "#/definitions/Covering"
        },
        "visitPlanning" : {
          "description" : "Contains parameter values for the visit planning use cases.",
          "$ref" : "#/definitions/VisitPlanning"
        },
        "visitSequencing" : {
          "description" : "Contains parameter values for simple visit sequencing use cases.",
          "$ref" : "#/definitions/VisitSequencing"
        },
        "solverTimeLimit" : {
          "description" : "The maximum time in seconds the solver may use to provide a solution. When this period of time is elapsed the best solution available will be returned.",
          "$ref" : "#/definitions/Duration"
        }
      },
      "description" : "Defines parameters for cluster planning and optimization.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.clusterplanningprofile.ClusterPlanningProfile"
    },
    "ClusterPlanningProgress" : {
      "allOf" : [ {
        "$ref" : "#/definitions/JobProgress"
      }, {
        "type" : "object",
        "required" : [ "status" ],
        "properties" : {
          "status" : {
            "description" : "Current status of the planning task.",
            "$ref" : "#/definitions/ClusterPlanningProgressStatus"
          },
          "optimizationProgress" : {
            "description" : "The percentage value of the planning task that is already finished. This parameter is not available during distance matrix calculation.",
            "$ref" : "#/definitions/Percent"
          }
        },
        "description" : "Represents a progress for a running cluster planning.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.ClusterPlanningProgress"
      } ],
      "x-discriminator-value" : "ClusterPlanningProgress",
      "x-ms-discriminator-value" : "ClusterPlanningProgress"
    },
    "ClusterPlanningProgressStatus" : {
      "type" : "string",
      "description" : "Represents possible status values for the ClusterPlanningProgress.  \n * `PREPROCESSING` - Indicates that the algorithm is currently in a pre-processing stage.  \n * `PROCESSING` - Indicates that the algorithm is currently in the main processing stage.  \n * `POSTPROCESSING` - Indicates that the algorithm is currently in a post-processing stage.  \n * `DONE` - Indicates that the algorithm has finished.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.xcluster.ProgressStatus",
      "enum" : [ "PREPROCESSING", "PROCESSING", "POSTPROCESSING", "DONE" ],
      "x-ms-enum" : {
        "name" : "ClusterPlanningProgressStatus",
        "modelAsString" : false
      }
    },
    "ClusterReport" : {
      "type" : "object",
      "required" : [ "clusterId", "numberOfLocations", "totalActivity" ],
      "properties" : {
        "clusterId" : {
          "type" : "string",
          "description" : "The ID of the cluster that is described by this report."
        },
        "totalActivity" : {
          "type" : "number",
          "format" : "double",
          "description" : "The total amount of activity of the locations assigned to this cluster. If considerActivitiesAsServiceTimes is enabled in the request, the value of totalActivity represents the estimated tour duration for the current cluster."
        },
        "numberOfLocations" : {
          "description" : "The number of locations that is assigned to this cluster. A detailed list of location IDs is specified in the clustered locations.",
          "$ref" : "#/definitions/NonNegativeInteger"
        },
        "estimatedTravelTimeToCluster" : {
          "description" : "The estimated travel time from the cluster center to the cluster. It is calculated by averaging the distance from the cluster center to its 5 nearest neighbors (locations). This value can be obtained only if clusters were specified in the request.",
          "$ref" : "#/definitions/Duration"
        }
      },
      "description" : "Represents the summary of a cluster which was planned.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.ClusterReport"
    },
    "ClusteredLocations" : {
      "type" : "object",
      "required" : [ "clusterId" ],
      "properties" : {
        "clusterId" : {
          "type" : "string",
          "description" : "The ID of the cluster that is described by these clustered locations."
        },
        "locationIds" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "description" : "A list of locations that are assigned to this cluster, represented by their ID. The corresponding location elements are listed in the request."
          }
        }
      },
      "description" : "Represents the description of a set of locations being assigned to a specific cluster. The relationship between locations and cluster is described by their IDs.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.ClusteredLocations"
    },
    "Clustering" : {
      "type" : "object",
      "properties" : {
        "compactnessLevel" : {
          "description" : "Defines the exponent with which the distances are incorporated in the model.",
          "$ref" : "#/definitions/CompactnessLevel"
        },
        "approximationTolerance" : {
          "description" : "Defines (in percent) how close to the optimal solution value the solver should come before exiting an iteration. For instance, compared to 10% the value of 5% means better solution at the cost of higher running time.",
          "$ref" : "#/definitions/ApproximationTolerance"
        },
        "performPreprocessingStep" : {
          "type" : "boolean",
          "description" : "Perform preprocessing to reduce the complexity of the optimization problem. For example by excluding forbidden or redundant combinations. For large problems the preprocessing itself can be very time-consuming."
        },
        "boostActivityImportance" : {
          "type" : "boolean",
          "description" : "Setting this parameter will privilege important locations with high activity when determining territory centers."
        },
        "maximumNumberOfIterations" : {
          "description" : "The maximum number of iterations the solver may use to provide a solution.",
          "$ref" : "#/definitions/PositiveInteger"
        },
        "minimumRelativeImprovement" : {
          "description" : "The minimum relative solution value improvement (in percent) between iterations. If the relative improvement is less than the given value, no further iterations will be performed.",
          "$ref" : "#/definitions/MinimumRelativeImprovement"
        },
        "maximumNumberOfStarts" : {
          "description" : "The maximum number of starts the solver may use to provide a solution. For each start the maximum number of iterations mentioned in this profile will be used.",
          "$ref" : "#/definitions/PositiveInteger"
        },
        "maximumNumberOfSamplings" : {
          "description" : "The maximum number of samplings needed mainly in the case that the number of territories is being changed and it is required to choose some \"territory centers\" from a given list.",
          "$ref" : "#/definitions/PositiveInteger"
        },
        "numberOfNearestNeighbors" : {
          "description" : "The number of nearest neighbors used for the tour estimator.",
          "$ref" : "#/definitions/NumberOfNearestNeighbors"
        },
        "reassignmentMethod" : {
          "description" : "Defines the method of reassignment for locations after an iteration. Setting this to REDUCE might yield a better solution at the cost of more execution time.",
          "$ref" : "#/definitions/ReassignmentMethod"
        }
      },
      "description" : "Contains parameter values for the basic clustering use cases.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.clusterplanningprofile.Clustering"
    },
    "ClustersResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "properties" : {
          "clusters" : {
            "type" : "array",
            "items" : {
              "description" : "A list of clusters, described by their ID, that can also be used as input for further requests.",
              "$ref" : "#/definitions/Cluster"
            }
          },
          "clusterReports" : {
            "type" : "array",
            "items" : {
              "description" : "A list of cluster reports containing further information like the total value of activity of this cluster. The corresponding cluster is referenced by its cluster ID.",
              "$ref" : "#/definitions/ClusterReport"
            }
          },
          "clusteredLocations" : {
            "type" : "array",
            "items" : {
              "description" : "A list of location assignments that define which locations are assigned to which cluster.",
              "$ref" : "#/definitions/ClusteredLocations"
            }
          },
          "locationIdsNotPlanned" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "description" : "A list of locations, referenced by their ID, that are not included in the solution. This list is only available, if coverLocations was called."
            }
          },
          "totalClusterFacilityCost" : {
            "description" : "The accumulated cost of all clusters that are included in the solution. This parameter is only available if the cost was set in the cluster facilities of the CoverLocationsRequest.",
            "$ref" : "#/definitions/MathematicalCost"
          }
        },
        "description" : "Represents the result of a cluster planning.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.ClustersResponse"
      } ],
      "x-discriminator-value" : "ClustersResponse",
      "x-ms-discriminator-value" : "ClustersResponse"
    },
    "Color" : {
      "type" : "string",
      "description" : "The RGB color as a hexadecimal value in HTML notation such as \\#ff0000. Pattern: \\#\\[0-9A-Fa-f\\]\\{6\\}|\\\\d+.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.Color"
    },
    "CombinedTransport" : {
      "type" : "object",
      "properties" : {
        "boatPenalty" : {
          "description" : "The penalty for each combined transport segment of type boat.",
          "$ref" : "#/definitions/Penalty"
        },
        "railPenalty" : {
          "description" : "The penalty for each combined transport segment of type rail.",
          "$ref" : "#/definitions/Penalty"
        }
      },
      "description" : "Defines the parameters concerning combined transport like the truck being carried by boat or by rail.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.routingprofile.CombinedTransport"
    },
    "CombinedTransportAttributes" : {
      "type" : "object",
      "required" : [ "name", "type" ],
      "properties" : {
        "name" : {
          "type" : "string",
          "description" : "The name of the combined transport in the selected language. Usually the connection has an ID. In rare cases combined transports without ID could exist. In such cases the field is missing."
        },
        "type" : {
          "description" : "The type of combined transport. If this information is missing in the digital map the field xroute.UnspecifiedMapDataLimitation is generated and the field is set to BOAT (see segments.CombinedTransportType).",
          "$ref" : "#/definitions/CombinedTransportType"
        }
      },
      "description" : "Attributes which describe the combined transport properties of the segment in detail.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.segments.CombinedTransportAttributes"
    },
    "CombinedTransportEvent" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RouteEvent"
      }, {
        "type" : "object",
        "properties" : {
          "combinedTransportId" : {
            "description" : "The ID of the combined transport.",
            "$ref" : "#/definitions/SegmentId"
          },
          "combinedTransportName" : {
            "type" : "string",
            "description" : "The name of the combined transport."
          },
          "combinedTransportType" : {
            "description" : "The type of the combined transport.",
            "$ref" : "#/definitions/CombinedTransportType"
          },
          "accessType" : {
            "description" : "Indicates the ENTERing or EXITing of a combined transport.",
            "$ref" : "#/definitions/AccessType"
          },
          "relatedEventIndex" : {
            "description" : "For accessType ENTER this index points to the corresponding event with accessType EXIT and vice-versa.",
            "$ref" : "#/definitions/Index"
          }
        },
        "description" : "This event indicates the entering or exiting of a combined transport.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.CombinedTransportEvent"
      } ],
      "x-discriminator-value" : "CombinedTransportEvent",
      "x-ms-discriminator-value" : "CombinedTransportEvent"
    },
    "CombinedTransportType" : {
      "type" : "string",
      "description" : "The type of the combined transport segment, i.e. how the vehicle is transported.  \n * `BOAT` - The combined transport is by boat, i.e. by a ferry. Transport by boat can be avoided or prohibited during route calculation using the parameter routingprofile.CombinedTransport.boatPenalty.  \n * `RAIL` - The combined transport is by rail, i.e. on a train. Transport by rail can be avoided or prohibited during route calculation using the parameter routingprofile.CombinedTransport.railPenalty.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.segments.CombinedTransportType",
      "enum" : [ "BOAT", "RAIL" ],
      "x-ms-enum" : {
        "name" : "CombinedTransportType",
        "modelAsString" : false
      }
    },
    "CombinedTransportViaWaypoint" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InputWaypoint"
      }, {
        "type" : "object",
        "required" : [ "combinedTransportId" ],
        "properties" : {
          "combinedTransportId" : {
            "description" : "The internal ID of the combined transport that the route shall pass through. Can be retrieved using xdata/getSegments operations.",
            "$ref" : "#/definitions/SegmentId"
          }
        },
        "description" : "Specifies an input waypoint in order to force to use this combined transport on the route. There is no output waypoint and there is no leg that ends at this waypoint. This waypoint cannot be used as first or last input waypoint.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.CombinedTransportViaWaypoint"
      } ],
      "x-discriminator-value" : "CombinedTransportViaWaypoint",
      "x-ms-discriminator-value" : "CombinedTransportViaWaypoint"
    },
    "CommaSeparatedList" : {
      "type" : "string",
      "description" : "Defines a comma-separated list of values which consist only of upper-case letters, numbers, and underline characters. Pattern: (\\[A-Z0-9\\_\\]+)(,\\[A-Z0-9\\_\\]+)\\*.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.CommaSeparatedList"
    },
    "CompactnessLevel" : {
      "type" : "integer",
      "format" : "int32",
      "description" : "Valid exponents - Range: 1 ??? value ??? 4.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.CompactnessLevel"
    },
    "ConfigurationFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/SetupFault"
      }, {
        "type" : "object",
        "properties" : {
          "fileName" : {
            "description" : "The name of the configuration file that contains the wrongly configured parameter.",
            "$ref" : "#/definitions/FileName"
          },
          "parameter" : {
            "type" : "string",
            "description" : "The name of the wrongly configured parameter."
          },
          "value" : {
            "type" : "string",
            "description" : "The wrongly configured value."
          }
        },
        "description" : "This fault is thrown if an entry in a configuration file leads to a problem.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.ConfigurationFault"
      } ],
      "x-discriminator-value" : "ConfigurationFault",
      "x-ms-discriminator-value" : "ConfigurationFault"
    },
    "ConfigurationResultFields" : {
      "type" : "object",
      "properties" : {
        "profiles" : {
          "type" : "boolean",
          "description" : "Should available profiles be included?"
        },
        "configurationFileNames" : {
          "type" : "boolean",
          "description" : "Should all configuration file names be included?"
        },
        "thirdPartyLibraries" : {
          "type" : "boolean",
          "description" : "Should 3rdParty library information be included?"
        },
        "internalLibraries" : {
          "type" : "boolean",
          "description" : "Should internal library information be included?"
        }
      },
      "description" : "This type specifies what to include in the ServerConfigurationResponse object.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.ConfigurationResultFields"
    },
    "ContentSnapshotDescription" : {
      "type" : "object",
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "The ID of the content snapshot."
        },
        "label" : {
          "description" : "The optional label of the content snapshot, if it was specified in the request. This label is only used for displaying the content snapshot, e.g. in the dashboard, and is not considered in any other way.",
          "$ref" : "#/definitions/UserDefinedName"
        },
        "tenant" : {
          "type" : "string",
          "description" : "The tenant is returned only for administrators."
        },
        "scope" : {
          "description" : "The user defined scope.",
          "$ref" : "#/definitions/ScopeName"
        },
        "createdAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "Indicates the date the content snapshot was created."
        },
        "lastUsedAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "Indicates the date the content snapshot was used the last time."
        },
        "size" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Indicates the size of the content snapshot on the hard drive in bytes."
        }
      },
      "description" : "This type represents meta data about a content snapshot.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.ContentSnapshotDescription"
    },
    "ContentSnapshotInformation" : {
      "type" : "object",
      "properties" : {
        "contentSnapshotDescription" : {
          "description" : "Meta data that describes the content snapshot.",
          "$ref" : "#/definitions/ContentSnapshotDescription"
        },
        "listException" : {
          "description" : "Exception in case of an error querying a content snapshot ID.",
          "$ref" : "#/definitions/SuppressedXServerException"
        }
      },
      "description" : "The result that lists a description of a single content snapshot or the exception that was returned querying the content snapshot ID.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.ContentSnapshotInformation"
    },
    "ContentSnapshotResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "properties" : {
          "contentSnapshotDescription" : {
            "description" : "Meta information that describes the current content snapshot.",
            "$ref" : "#/definitions/ContentSnapshotDescription"
          }
        },
        "description" : "This type represents a summary of the meta information on a content snapshot.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.ContentSnapshotResponse"
      } ],
      "x-discriminator-value" : "ContentSnapshotResponse",
      "x-ms-discriminator-value" : "ContentSnapshotResponse"
    },
    "ContentSnapshotsListResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "properties" : {
          "contentSnapshotInformation" : {
            "type" : "array",
            "items" : {
              "description" : "The result list containing information about each content snapshot. If specific content snapshot IDs have been requested there is one entry in the list for each requested ID in the same order.",
              "$ref" : "#/definitions/ContentSnapshotInformation"
            }
          }
        },
        "description" : "This type represents a list of meta information on content snapshots.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.ContentSnapshotsListResponse"
      } ],
      "x-discriminator-value" : "ContentSnapshotsListResponse",
      "x-ms-discriminator-value" : "ContentSnapshotsListResponse"
    },
    "Continent" : {
      "type" : "object",
      "properties" : {
        "code" : {
          "description" : "The continent code. This code is PTV-specific, e.g. ZZ-EUR for Europe.",
          "$ref" : "#/definitions/CountryCode"
        },
        "countries" : {
          "type" : "array",
          "items" : {
            "description" : "The countries and subdivisions assigned to this continent.",
            "$ref" : "#/definitions/Country"
          }
        }
      },
      "description" : "Holds information on the data available for a continent. The assignment of countries and subdivisions to a continent depends on the data provider.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.Continent"
    },
    "Coordinate" : {
      "type" : "object",
      "required" : [ "x", "y" ],
      "properties" : {
        "x" : {
          "type" : "number",
          "format" : "double",
          "description" : "The value in x-direction (west to east), longitude for WGS84."
        },
        "y" : {
          "type" : "number",
          "format" : "double",
          "description" : "The value in y-direction (south to north), latitude for WGS84."
        },
        "z" : {
          "type" : "number",
          "format" : "double",
          "description" : "The elevation value. In responses such as xroute.RouteResponse.polyline the z-coordinate is available only on request."
        }
      },
      "description" : "A coordinate is defined by its x and y values, specifying the geographical point in a two-dimensional coordinate system, and its z-value, specifying the elevation.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.geometry.Coordinate"
    },
    "CoordinateFormat" : {
      "type" : "string",
      "description" : "EPSG-code\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.CoordinateFormat"
    },
    "Copyright" : {
      "type" : "object",
      "properties" : {
        "basemap" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "description" : "The text fragments for the basemap."
          }
        },
        "featureLayers" : {
          "type" : "array",
          "items" : {
            "description" : "The text fragments for the Feature Layers. Depending on the visible Feature Layer themes these text fragments have to be added to the copyright text on the map.",
            "$ref" : "#/definitions/FeatureLayerCopyright"
          }
        }
      },
      "description" : "This type holds the text fragments of the copyright text to be displayed on maps.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.Copyright"
    },
    "Cost" : {
      "type" : "object",
      "required" : [ "amount", "currency" ],
      "properties" : {
        "amount" : {
          "type" : "number",
          "format" : "double",
          "description" : "The amount of the costs in the specified currency."
        },
        "currency" : {
          "description" : "The currency code.",
          "$ref" : "#/definitions/CurrencyCode"
        }
      },
      "description" : "Specifies monetary costs in a certain currency. For example, toll costs that have to be paid for a route.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.types.Cost"
    },
    "CostReport" : {
      "type" : "object",
      "required" : [ "distance", "drivingTime", "travelTime" ],
      "properties" : {
        "travelTime" : {
          "description" : "The total duration between start and end of the described object. The travelTime contains all waiting, service, driving, break and rest times.",
          "$ref" : "#/definitions/Duration"
        },
        "drivingTime" : {
          "description" : "The total driving time, which is the sum of the length of all driving events. The driving time of an empty ride might not belong to any trip. See Tours and Trips.",
          "$ref" : "#/definitions/Duration"
        },
        "serviceTime" : {
          "description" : "The total service time, which is the sum of the length of all service events.",
          "$ref" : "#/definitions/Duration"
        },
        "distance" : {
          "description" : "The total driven distance.",
          "type" : "number"
        }
      },
      "description" : "Cost related information describing tours or trips. The cost report contains accumulated values describing its parent object, which is either a tour response, a tour report or a trip report.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.CostReport"
    },
    "Country" : {
      "type" : "object",
      "properties" : {
        "code" : {
          "description" : "The country code.",
          "$ref" : "#/definitions/CountryCode"
        },
        "description" : {
          "description" : "Descriptive information about the country, only available if the country does not have subdivisions.",
          "$ref" : "#/definitions/RegionDescription"
        },
        "features" : {
          "description" : "Lists the features which are available for this country, only available if the country does not have subdivisions.",
          "$ref" : "#/definitions/RegionFeatures"
        },
        "subdivisions" : {
          "type" : "array",
          "items" : {
            "description" : "The subdivisions available for this country.",
            "$ref" : "#/definitions/Subdivision"
          }
        }
      },
      "description" : "Base type for a country with or without subdivisions. Depending on how the data are built up a country can have subdivisions, e.g. a state in the US, or not.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.Country"
    },
    "CountryCode" : {
      "type" : "string",
      "description" : "Identifies countries or principal subdivisions of countries. See country codes. Pattern: \\[A-Z\\]\\{2\\}|\\[A-Z\\]\\{2\\}-\\[A-Z0-9\\]\\{1,3\\}.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.CountryCode"
    },
    "CountryCost" : {
      "type" : "object",
      "properties" : {
        "country" : {
          "description" : "The country in which the cost has to be paid.",
          "$ref" : "#/definitions/CountryCode"
        },
        "cost" : {
          "description" : "The amount that has to be paid in the local currency of the country.",
          "$ref" : "#/definitions/Cost"
        },
        "convertedCost" : {
          "description" : "The amount that has to be paid converted to the specified currency. It is only returned if a currency is specified in the route options. It is still returned in case the requested currency and the local currency of the country are the same.",
          "$ref" : "#/definitions/Cost"
        }
      },
      "description" : "Specifies monetary costs in a certain currency that apply in a certain country.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.CountryCost"
    },
    "CountryEvent" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RouteEvent"
      }, {
        "type" : "object",
        "properties" : {
          "country" : {
            "description" : "The code of the country or subdivision the route enters.",
            "$ref" : "#/definitions/CountryCode"
          }
        },
        "description" : "This event indicates that a border of a country or a subdivision is crossed by the route, i.e. the current country code changes. As this object contains only the country which is entered, consider the previous CountryEvent to obtain the code of the country or subdivision which is left. To obtain the country in which the route starts, there is always an event for the start of the route. If only borders between countries are needed, ignore those events for which only the subdivision code changes, e.g. US-GA and US-FL.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.CountryEvent"
      } ],
      "x-discriminator-value" : "CountryEvent",
      "x-ms-discriminator-value" : "CountryEvent"
    },
    "CountryFallbackLimitation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResultLimitation"
      }, {
        "type" : "object",
        "required" : [ "fallbackCountryCode", "requestedSubdivisionCode" ],
        "properties" : {
          "requestedSubdivisionCode" : {
            "type" : "string",
            "description" : "The country subdivision code that was requested in allowedCountries, but cannot be used for filtering."
          },
          "fallbackCountryCode" : {
            "type" : "string",
            "description" : "The enclosing country that is used as a fallback instead."
          }
        },
        "description" : "This result limitation indicates that allowedCountries contains a country subdivision code that cannot be used like this due to the available data, and that instead the enclosing country code was used. In such cases, results are constrained to the country, rather than only the subdivision.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xlocate.CountryFallbackLimitation"
      } ],
      "x-discriminator-value" : "CountryFallbackLimitation",
      "x-ms-discriminator-value" : "CountryFallbackLimitation"
    },
    "CountryIgnoredLimitation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResultLimitation"
      }, {
        "type" : "object",
        "required" : [ "ignoredCountryCode" ],
        "properties" : {
          "ignoredCountryCode" : {
            "type" : "string",
            "description" : "The country code that was requested in allowedCountries or prohibitedCountres, but was ignored."
          }
        },
        "description" : "This result limitation indicates that GeographicRestrictions.allowedCountries or GeographicRestrictions.prohibitedCountries contains a country code that cannot be used like this due to the available data, and that it was ignored.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.routing.CountryIgnoredLimitation"
      } ],
      "x-discriminator-value" : "CountryIgnoredLimitation",
      "x-ms-discriminator-value" : "CountryIgnoredLimitation"
    },
    "CountryList" : {
      "type" : "string",
      "description" : "Defines the countries to which a style is assigned. The value can contain a single country, a comma separated list of countries, a continent code or a comma separated list of continent codes. The value \"\\*\" defines \"every country\". See country codes. Pattern: (\\[A-Z\\]\\{2\\}|\\[A-Z\\]\\{2\\}-\\[A-Z0-9\\]\\{1,3\\})\\*(,\\[A-Z\\]\\{2\\}|,\\[A-Z\\]\\{2\\}-\\[A-Z0-9\\]\\{1,3\\})\\*|\\\\\\*.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.CountryList"
    },
    "CountrySpecificParameter" : {
      "type" : "object",
      "required" : [ "id" ],
      "properties" : {
        "rules" : {
          "type" : "array",
          "items" : {
            "description" : "Defines the state of a rule that is relative to this country, i.e. allows a subsequent rule to be enabled or disabled from its ID.",
            "$ref" : "#/definitions/FeatureLayerRule"
          }
        },
        "properties" : {
          "type" : "array",
          "items" : {
            "description" : "Defines the state of a property that is relative to this country, i.e. allows a subsequent property to be enabled or disabled from its ID.",
            "$ref" : "#/definitions/FeatureLayerProperty"
          }
        },
        "actions" : {
          "type" : "array",
          "items" : {
            "description" : "Defines the state of an action type that is relative to this country, i.e. allows a subsequent action type to be enabled or disabled from its ID.",
            "$ref" : "#/definitions/FeatureLayerAction"
          }
        },
        "id" : {
          "description" : "Defines the country ID type. The special value \"\\*\" defines every country.",
          "$ref" : "#/definitions/CountryList"
        },
        "enabled" : {
          "type" : "boolean",
          "description" : "Enables or disables the country. If disabled, every subsequent rule, property and action type that is relative to this country will be disabled as well."
        }
      },
      "description" : "Defines the country state type, that defines a country that can be enabled or disabled from its ID, and its subsequent rules, properties and action types can be enabled or disabled.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.featurelayerprofile.CountrySpecificParameter"
    },
    "CountryStyle" : {
      "type" : "object",
      "required" : [ "countryCodes" ],
      "properties" : {
        "featureLayerThemes" : {
          "type" : "array",
          "items" : {
            "description" : "Defines styles for data of a Feature Layer theme in the corresponding set of countries.",
            "$ref" : "#/definitions/FeatureLayerThemeStyle"
          }
        },
        "countryCodes" : {
          "description" : "Defines the countries to which a style is assigned. The value can contain a single country, a comma separated list of countries, a continent code or a comma separated list of continent codes. The value \"\\*\" defines \"every country. See country codes.\"",
          "$ref" : "#/definitions/CountryList"
        }
      },
      "description" : "Defines a map style for a specific country, a set of countries, or for all countries.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.renderingprofile.CountryStyle"
    },
    "CountryType" : {
      "type" : "string",
      "description" : "Specifies the representation of the country in a request or response.  \n * `ISO_3166_1_ALPHA_2` - The country will be represented as ISO 3166-1 alpha-2, e.g. DE for Germany.  \n * `ISO_3166_1_ALPHA_3` - The country will be represented as ISO 3166-1 alpha-3, e.g. DEU for Germany.  \n * `LICENSE_PLATE` - The country will be represented by its license plate code, e.g. D for Germany.  \n * `NAME` - The country will be represented by its name, not abbreviated nor encoded, in the requested language.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.xlocate.CountryType",
      "enum" : [ "ISO_3166_1_ALPHA_2", "ISO_3166_1_ALPHA_3", "LICENSE_PLATE", "NAME" ],
      "x-ms-enum" : {
        "name" : "CountryType",
        "modelAsString" : false
      }
    },
    "Course" : {
      "type" : "object",
      "properties" : {
        "violations" : {
          "description" : "Defines the parameters that control whether road restrictions can be violated. See the technical concept for details.",
          "$ref" : "#/definitions/Violations"
        },
        "network" : {
          "description" : "Defines the parameters that concern network specific segment attributes, e.g. penalties for road segments of a certain network class.",
          "$ref" : "#/definitions/Network"
        },
        "toll" : {
          "description" : "Defines the parameters for toll specific segment attributes, e.g. penalty of toll segments, etc.",
          "$ref" : "#/definitions/Toll"
        },
        "specialAreas" : {
          "description" : "Defines the parameters concerning the special areas, such as urban segments, low emission zones, etc.",
          "$ref" : "#/definitions/SpecialAreas"
        },
        "combinedTransport" : {
          "description" : "Defines the parameters concerning combined transport like the truck being carried by boat or by rail.",
          "$ref" : "#/definitions/CombinedTransport"
        },
        "maneuver" : {
          "description" : "Defines the parameters that control how special maneuvers (turns) affect the route calculation.",
          "$ref" : "#/definitions/Maneuver"
        },
        "distanceTimeWeighting" : {
          "description" : "The weight factor for route travel time. The distance enters the basic cost term with a weight of 100 - distanceTimeWeighting. Hence, with a value of 100, only travel time is optimized, while with a value of 0 only the distance of the route is optimized.",
          "$ref" : "#/definitions/Percent"
        }
      },
      "description" : "Defines the parameters of the routing algorithm that control the course of the route.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.routingprofile.Course"
    },
    "CoverLocationsOptions" : {
      "type" : "object",
      "required" : [ "coveringHorizon", "optimizationGoal" ],
      "properties" : {
        "coveringHorizon" : {
          "description" : "Defines the coverage radius of a cluster, i.e. all locations included in the horzion of a cluster are covered by it. A horizon can be specified by travel time or by distance, depending on its specific type DistanceBasedHorizon or TravelTimeBasedHorizon.",
          "$ref" : "#/definitions/Horizon"
        },
        "optimizationGoal" : {
          "description" : "Defines the optimization goal for the algorithm. The optimization goal can be seen as exit criterion for iterations of the algorithm.",
          "$ref" : "#/definitions/OptimizationGoal"
        },
        "mandatoryLocationIds" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "description" : "The IDs of locations that must be covered."
          }
        },
        "mandatoryClusterIds" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "description" : "The IDs of clusters that must be part of the solution."
          }
        }
      },
      "description" : "Input parameters for the covering algorithm.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.CoverLocationsOptions"
    },
    "CoverLocationsRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "required" : [ "coverLocationsOptions", "distanceMode" ],
        "properties" : {
          "planningLocations" : {
            "type" : "array",
            "items" : {
              "description" : "Set of locations that should be clustered.",
              "$ref" : "#/definitions/PlanningLocation"
            }
          },
          "coverLocationsOptions" : {
            "description" : "Parameters for the covering algorithm.",
            "$ref" : "#/definitions/CoverLocationsOptions"
          },
          "distanceMode" : {
            "description" : "Contains settings that specify how distances between locations are retrieved. When using direct distance the driven distances are estimated with a detour factor of 1.38 and for the duration a speed of 60 km/h is assumed. Only the following distance modes are supported: DirectDistance and ExistingDistanceMatrix.",
            "$ref" : "#/definitions/DistanceMode"
          },
          "clusterFacilities" : {
            "type" : "array",
            "items" : {
              "description" : "Set of possible clusters represented by their reference points to which locations can be assigned. A cluster facility is also represented by a cost value that describes the additional cost that emerge when using this cluster.",
              "$ref" : "#/definitions/ClusterFacility"
            }
          }
        },
        "description" : "Input for the use case cover locations.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.CoverLocationsRequest"
      } ],
      "x-discriminator-value" : "CoverLocationsRequest",
      "x-ms-discriminator-value" : "CoverLocationsRequest"
    },
    "Covering" : {
      "type" : "object",
      "properties" : {
        "approximationTolerance" : {
          "description" : "Defines (in percent) how close to the optimal solution value the solver should come before exiting an iteration. For instance, compared to 10% the value of 5% means better solution at the cost of higher running time.",
          "$ref" : "#/definitions/ApproximationTolerance"
        },
        "performPreprocessingStep" : {
          "type" : "boolean",
          "description" : "Perform preprocessing to reduce the complexity of the optimization problem. For example by excluding forbidden or redundant combinations. For large problems the preprocessing itself can be very time-consuming."
        }
      },
      "description" : "Contains parameter values for the covering or reachability use cases.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.clusterplanningprofile.Covering"
    },
    "CreateAndGetDistanceMatrixRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/CreateDistanceMatrixRequest"
      }, {
        "type" : "object",
        "properties" : {
          "resultFields" : {
            "description" : "Specifies the result fields available in the response.",
            "$ref" : "#/definitions/DistanceMatrixContentsResultFields"
          },
          "contentsOptions" : {
            "description" : "Specifies how to return the distance matrix contents.",
            "$ref" : "#/definitions/DistanceMatrixContentsOptions"
          }
        },
        "description" : "This type represents settings for the creation and immediate retrieval of the contents of a new distance matrix. The matrix is not persisted. The id field of the summary is not filled. Be aware that the default settings of the DistanceMatrixContentsResultFields are that only the travel time is returned. If other contents like distance or violation flags should be returned a specific setting of the DistanceMatrixContentsResultFields are required. Note the following limitations for this request type: The maximum number of relations (i.e., the number of start locations times the number of destination locations) is internally limited to 250000 but it can be configured in the `xserver.conf` file (see here), and timeconsideration.MultipleTravelTimesConsideration is not allowed for DistanceMatrixOptions.timeConsideration. In case the toll costs are of interest, it is sufficient to set the the result field DistanceMatrixContentsResultFields.tollCosts. As the distance matrix is not persisted, the field DistanceMatrixOptions.persistTollCosts is ignored.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdima.CreateAndGetDistanceMatrixRequest"
      } ],
      "x-discriminator-value" : "CreateAndGetDistanceMatrixRequest",
      "x-ms-discriminator-value" : "CreateAndGetDistanceMatrixRequest"
    },
    "CreateContentSnapshotRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "properties" : {
          "label" : {
            "description" : "The label or description of this content snapshot.",
            "$ref" : "#/definitions/UserDefinedName"
          }
        },
        "description" : "This type represents settings for the creation of a new content snapshot.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.CreateContentSnapshotRequest"
      } ],
      "x-discriminator-value" : "CreateContentSnapshotRequest",
      "x-ms-discriminator-value" : "CreateContentSnapshotRequest"
    },
    "CreateDistanceMatrixRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "properties" : {
          "startLocations" : {
            "type" : "array",
            "items" : {
              "description" : "The list of start locations.",
              "$ref" : "#/definitions/RouteLocation"
            }
          },
          "destinationLocations" : {
            "type" : "array",
            "items" : {
              "description" : "The list of destination locations. If this list is empty, the destination locations are equal to the start locations.",
              "$ref" : "#/definitions/RouteLocation"
            }
          },
          "label" : {
            "description" : "The label or description of this distance matrix. This is especially useful if the distance matrices should be listed in the PTV xServer dashboard.",
            "$ref" : "#/definitions/UserDefinedName"
          },
          "distanceMatrixOptions" : {
            "description" : "Calculation options for the distance matrix.",
            "$ref" : "#/definitions/DistanceMatrixOptions"
          }
        },
        "description" : "This type represents settings for the creation of a new distance matrix.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdima.CreateDistanceMatrixRequest"
      } ],
      "x-discriminator-value" : "CreateDistanceMatrixRequest",
      "x-ms-discriminator-value" : "CreateDistanceMatrixRequest"
    },
    "CreateFeatureLayerRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "required" : [ "themeId" ],
        "properties" : {
          "themeId" : {
            "description" : "The ID of the Feature Layer theme.",
            "$ref" : "#/definitions/ThemeId"
          },
          "featureScenario" : {
            "description" : "The scenario or description of this Feature Layer. This is especially useful to associate a layer to a user scenario in order to use only this layer during the routing and rendering requests. The scenario is required when the result field binaryFeatureLayer is set to false.",
            "$ref" : "#/definitions/FeatureScenario"
          },
          "features" : {
            "type" : "array",
            "items" : {
              "description" : "The list of features to add in the Feature Layer.",
              "$ref" : "#/definitions/FeatureLayerFeature"
            }
          },
          "resultFields" : {
            "description" : "The fields to be returned in the response.",
            "$ref" : "#/definitions/CreateFeatureLayerResultFields"
          }
        },
        "description" : "This type represents settings for the creation of a new Feature Layer.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.CreateFeatureLayerRequest"
      } ],
      "x-discriminator-value" : "CreateFeatureLayerRequest",
      "x-ms-discriminator-value" : "CreateFeatureLayerRequest"
    },
    "CreateFeatureLayerResultFields" : {
      "type" : "object",
      "properties" : {
        "binaryFeatureLayer" : {
          "type" : "boolean",
          "description" : "Specifies if createFeatureLayer has to return a binary Feature Layer. If false, the generated layer will be persistent."
        }
      },
      "description" : "This type represents result fields when creating a Feature Layer.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.CreateFeatureLayerResultFields"
    },
    "CreateHighPerformanceRoutingNetworkRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "properties" : {
          "label" : {
            "description" : "The label or description of this high-performance routing network. This is especially useful if the networks should be listed in the PTV xServer dashboard.",
            "$ref" : "#/definitions/UserDefinedName"
          },
          "highPerformanceRoutingNetworkOptions" : {
            "description" : "This type represents options that are relevant for selection of a high-performance routing network besides the profile.",
            "$ref" : "#/definitions/HighPerformanceRoutingNetworkOptions"
          }
        },
        "description" : "This type represents settings for the creation of a new high-performance routing network. An InvalidValueException is returned if the Feature Layer theme PTV\\_RestrictionZones is activated. PTV\\_RestrictionZones are not supported in high-performance routing.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.CreateHighPerformanceRoutingNetworkRequest"
      } ],
      "x-discriminator-value" : "CreateHighPerformanceRoutingNetworkRequest",
      "x-ms-discriminator-value" : "CreateHighPerformanceRoutingNetworkRequest"
    },
    "CurrencyCode" : {
      "type" : "string",
      "description" : "The currency code according to ISO 4217. Pattern: \\[A-Z\\]\\{3\\}.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.CurrencyCode"
    },
    "CustomerSite" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Site"
      }, {
        "type" : "object",
        "properties" : {
          "customerId" : {
            "type" : "string",
            "description" : "ID of the customer that can be set to link several customer sites with different opening intervals. Customer sites with the same customer ID may only differ in the location ID and in the opening intervals. Otherwise an exception is thrown. If successive stops at customer sites share the same customer ID, the service time per stop of the site and of the vehicle are only considered at the first stop of the sequence."
          },
          "positionInTrip" : {
            "description" : "If specified, this stop has to be the very first/last customer stop in its trip whenever there is a stop at this customer site.  \r\nIn each trip, there can only be one stop at a customer site with a trip section of type FIRST\\_CUSTOMER\\_STOP/LAST\\_CUSTOMER\\_STOP.  \r\nIf specified, tripSectionNumber must not be set for the same customer site.  \r\nSee technical concept Trip Sections and Positions in Trips for further details.",
            "$ref" : "#/definitions/PositionInTrip"
          },
          "tripSectionNumber" : {
            "description" : "If tripSectionNumber is specified, a stop at this customer site will be visited  \r\n*after* stops (within the same trip) at customer sites with specified *lower* tripSectionNumber and  \r\n*before* stops (within the same trip) at customer sites with specified *higher* tripSectionNumber.  \r\nConsequently, the trip section numbers of stops at customer sites will be non-decreasing within each trip.  \r\nIf specified, positionInTrip must not be set for the same customer site.  \r\nSee technical concept Trip Sections and Positions in Trips for further details.",
            "$ref" : "#/definitions/PositiveInteger"
          }
        },
        "description" : "A specific site representing a customer location.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.CustomerSite"
      } ],
      "x-discriminator-value" : "CustomerSite",
      "x-ms-discriminator-value" : "CustomerSite"
    },
    "CylinderCapacity" : {
      "type" : "integer",
      "format" : "int32",
      "description" : "Defines the type used for expressing the cylinder capacity in \\[cm??\\]. Range: 1 ??? value.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.CylinderCapacity"
    },
    "DailyDistanceWeight" : {
      "type" : "integer",
      "format" : "int32",
      "description" : "Valid values - Range: 1 ??? value ??? 100.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.DailyDistanceWeight"
    },
    "DataInformationOptions" : {
      "type" : "object",
      "properties" : {
        "returnOnlyLicensedMapFeatures" : {
          "type" : "boolean",
          "description" : "Specifies if the returned set of DataInformationResponse.mapFeatures contains all installed items or only the licensed ones."
        }
      },
      "description" : "Configures the content of the data information response.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.DataInformationOptions"
    },
    "DataInformationRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "properties" : {
          "dataInformationOptions" : {
            "description" : "Options which may influence the content of the corresponding response.",
            "$ref" : "#/definitions/DataInformationOptions"
          },
          "resultFields" : {
            "description" : "Specified which fields of the DataInformationResponse shall be returned.",
            "$ref" : "#/definitions/DataInformationResultFields"
          }
        },
        "description" : "Request type for data information.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.DataInformationRequest"
      } ],
      "x-discriminator-value" : "DataInformationRequest",
      "x-ms-discriminator-value" : "DataInformationRequest"
    },
    "DataInformationResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "properties" : {
          "mapDescription" : {
            "description" : "Descriptive information about the installed map.",
            "$ref" : "#/definitions/MapDescription"
          },
          "mapFeatures" : {
            "description" : "Lists all available map features which are installed with the map, if option DataInformationOptions.returnOnlyLicensedMapFeatures is false, otherwise only the licensed ones are returned.",
            "$ref" : "#/definitions/MapFeatures"
          },
          "continents" : {
            "type" : "array",
            "items" : {
              "description" : "Lists the available data and their features sorted by continent.",
              "$ref" : "#/definitions/Continent"
            }
          }
        },
        "description" : "Response type for data information. Contains the information about the installed map.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.DataInformationResponse"
      } ],
      "x-discriminator-value" : "DataInformationResponse",
      "x-ms-discriminator-value" : "DataInformationResponse"
    },
    "DataInformationResultFields" : {
      "type" : "object",
      "properties" : {
        "continents" : {
          "type" : "boolean",
          "description" : "Specifies if the DataInformationResponse.continents shall be returned."
        }
      },
      "description" : "Specifies which fields of the DataInformationResponse shall be returned.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.DataInformationResultFields"
    },
    "DataNotAvailableFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InvalidRequestFault"
      }, {
        "type" : "object",
        "required" : [ "parameter", "value" ],
        "properties" : {
          "parameter" : {
            "type" : "string",
            "description" : "The request parameter as XPath expression which requires data that is not available."
          },
          "value" : {
            "type" : "string",
            "description" : "The parameter's value or for comma-separated lists the part of the parameter's value that requires the data that is not available. For example, a Feature Layer theme or a missing rule or action in the corresponding Feature Layer theme."
          }
        },
        "description" : "This fault is thrown if due to a specific parameter of the request certain data is required to calculate the response but the data is not available.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.DataNotAvailableFault"
      } ],
      "x-discriminator-value" : "DataNotAvailableFault",
      "x-ms-discriminator-value" : "DataNotAvailableFault"
    },
    "DeleteContentSnapshotRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "required" : [ "id" ],
        "properties" : {
          "id" : {
            "type" : "string",
            "description" : "The ID of the content snapshot to be deleted."
          }
        },
        "description" : "This type represents settings for deleting a content snapshot.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.DeleteContentSnapshotRequest"
      } ],
      "x-discriminator-value" : "DeleteContentSnapshotRequest",
      "x-ms-discriminator-value" : "DeleteContentSnapshotRequest"
    },
    "DeleteDistanceMatrixRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "required" : [ "id" ],
        "properties" : {
          "id" : {
            "type" : "string",
            "description" : "The ID of the distance matrix to be deleted."
          }
        },
        "description" : "This type represents settings for deleting a distance matrix.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdima.DeleteDistanceMatrixRequest"
      } ],
      "x-discriminator-value" : "DeleteDistanceMatrixRequest",
      "x-ms-discriminator-value" : "DeleteDistanceMatrixRequest"
    },
    "DeleteFeatureLayerRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "required" : [ "featureScenario", "themeId" ],
        "properties" : {
          "themeId" : {
            "description" : "The ID of the Feature Layer theme.",
            "$ref" : "#/definitions/ThemeId"
          },
          "featureScenario" : {
            "description" : "The scenario of the Feature Layer to be deleted.",
            "$ref" : "#/definitions/FeatureScenario"
          }
        },
        "description" : "This type represents settings for deleting a Feature Layer.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.DeleteFeatureLayerRequest"
      } ],
      "x-discriminator-value" : "DeleteFeatureLayerRequest",
      "x-ms-discriminator-value" : "DeleteFeatureLayerRequest"
    },
    "DeleteHighPerformanceRoutingNetworkRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "required" : [ "id" ],
        "properties" : {
          "id" : {
            "type" : "string",
            "description" : "The ID of the high-performance routing network to be deleted."
          }
        },
        "description" : "This type represents settings for deleting a high-performance routing network.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.DeleteHighPerformanceRoutingNetworkRequest"
      } ],
      "x-discriminator-value" : "DeleteHighPerformanceRoutingNetworkRequest",
      "x-ms-discriminator-value" : "DeleteHighPerformanceRoutingNetworkRequest"
    },
    "DeliveryBeforePickupFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TripStructureFault"
      }, {
        "type" : "object",
        "required" : [ "orderId" ],
        "properties" : {
          "orderId" : {
            "type" : "string",
            "description" : "ID of the order whose delivery task is or should be executed before the pickup task."
          }
        },
        "description" : "This fault is thrown if a delivery task is executed before the corresponding pickup task in an input tour or a ChangeToursRequest would lead to this wrong order of tasks.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.DeliveryBeforePickupFault"
      } ],
      "x-discriminator-value" : "DeliveryBeforePickupFault",
      "x-ms-discriminator-value" : "DeliveryBeforePickupFault"
    },
    "DepotSite" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Site"
      }, {
        "type" : "object",
        "properties" : {
          "additionalServiceTimePerPickupStop" : {
            "description" : "Another site-dependent service time that is added to the general service time per stop of site if goods are picked up from the depot site. See Service time calculation.",
            "$ref" : "#/definitions/Duration"
          },
          "additionalServiceTimePerDeliveryStop" : {
            "description" : "Another site-dependent service time that is added to the general service time per stop of site if goods are delivered at the depot site. See Service time calculation.",
            "$ref" : "#/definitions/Duration"
          }
        },
        "description" : "A specific site representing a depot. Depots act as trip delimiters. See Tours and Trips.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.DepotSite"
      } ],
      "x-discriminator-value" : "DepotSite",
      "x-ms-discriminator-value" : "DepotSite"
    },
    "DepotVisitFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TourStructureFault"
      }, {
        "type" : "object",
        "required" : [ "orderId", "siteId" ],
        "properties" : {
          "orderId" : {
            "type" : "string",
            "description" : "ID of the visit order causing the exception."
          },
          "siteId" : {
            "type" : "string",
            "description" : "ID of the depot site the visit order refers to."
          }
        },
        "description" : "This fault is thrown if a visit order is to be executed at a depot.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.DepotVisitFault"
      } ],
      "x-discriminator-value" : "DepotVisitFault",
      "x-ms-discriminator-value" : "DepotVisitFault"
    },
    "DeprecatedParameterLimitation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResultLimitation"
      }, {
        "type" : "object",
        "required" : [ "parameter" ],
        "properties" : {
          "parameter" : {
            "type" : "string",
            "description" : "Identifies the deprecated parameter as an XPath path expression."
          }
        },
        "description" : "This result limitation indicates that a deprecated parameter is used..\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.service.DeprecatedParameterLimitation"
      } ],
      "x-discriminator-value" : "DeprecatedParameterLimitation",
      "x-ms-discriminator-value" : "DeprecatedParameterLimitation"
    },
    "Dimension" : {
      "type" : "number",
      "format" : "double",
      "description" : "Defines the type used for dimensions in \\[cm\\]. For example, the width or height of a vehicle. Range: 0.0 ??? value.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.Dimension"
    },
    "Dimensions" : {
      "type" : "object",
      "properties" : {
        "height" : {
          "description" : "The vehicle's height. (2,4)",
          "$ref" : "#/definitions/Dimension"
        },
        "heightAboveFrontAxle" : {
          "description" : "The vehicle's height above the front axle. (2)",
          "$ref" : "#/definitions/Dimension"
        },
        "length" : {
          "description" : "The vehicle's length. (2,4)",
          "$ref" : "#/definitions/Dimension"
        },
        "width" : {
          "description" : "The vehicle's width. (2,4)",
          "$ref" : "#/definitions/Dimension"
        }
      },
      "description" : "Defines the size parameters of the vehicle, e.g. height, length, etc.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.vehicleprofile.Dimensions"
    },
    "DirectDistance" : {
      "allOf" : [ {
        "$ref" : "#/definitions/DistanceMode"
      }, {
        "type" : "object",
        "description" : "Use direct distance. This mode does not require a distance matrix or a road network.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.dima.DirectDistance"
      } ],
      "x-discriminator-value" : "DirectDistance",
      "x-ms-discriminator-value" : "DirectDistance"
    },
    "DirectionToleranceInteger" : {
      "type" : "integer",
      "format" : "int32",
      "description" : "Defines a tolerance around a direction in degrees \\[??\\]. Range: 0 ??? value ??? 180.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.DirectionToleranceInteger"
    },
    "Distance" : {
      "type" : "number",
      "format" : "double",
      "description" : "Defines the type used for expressing distances in \\[m\\]. Range: 0.0 ??? value.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.Distance"
    },
    "DistanceBasedHorizon" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Horizon"
      }, {
        "type" : "object",
        "required" : [ "distance" ],
        "properties" : {
          "distance" : {
            "description" : "A distance that specifies the range of the horizon.",
            "type" : "number"
          }
        },
        "description" : "Represents a geographical horizon that is described by a distance. Every point or road segment that is reachable from the source within the specified distance is included in the horizon.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.routing.DistanceBasedHorizon"
      } ],
      "x-discriminator-value" : "DistanceBasedHorizon",
      "x-ms-discriminator-value" : "DistanceBasedHorizon"
    },
    "DistanceMatrixContents" : {
      "type" : "object",
      "required" : [ "$type" ],
      "discriminator" : "$type",
      "properties" : {
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "This type represents the contents of a distance matrix. It contains for each element corresponding to a pair of locations (start/destination) computed properties like road distance, travel time or additional data. This data is arranged in arrays. Please check the documentation of the associated requests for the data organization in the response.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdima.DistanceMatrixContents"
    },
    "DistanceMatrixContentsArrays" : {
      "allOf" : [ {
        "$ref" : "#/definitions/DistanceMatrixContents"
      }, {
        "type" : "object",
        "properties" : {
          "distances" : {
            "type" : "array",
            "items" : {
              "description" : "The distances of the requested matrix elements.",
              "type" : "number"
            }
          },
          "travelTimes" : {
            "type" : "array",
            "items" : {
              "description" : "The travel times of the requested matrix elements.",
              "$ref" : "#/definitions/Duration"
            }
          },
          "violated" : {
            "type" : "array",
            "items" : {
              "type" : "boolean",
              "description" : "The violated flags of the requested matrix elements."
            }
          },
          "estimatedByDirectDistance" : {
            "type" : "array",
            "items" : {
              "type" : "boolean",
              "description" : "The estimated by direct distance flags of the requested matrix elements."
            }
          },
          "tollCosts" : {
            "type" : "array",
            "items" : {
              "type" : "number",
              "format" : "double",
              "description" : "The toll costs of the requested matrix elements in the currency that has been provided in the options of the corresponding xdima.CreateDistanceMatrixRequest."
            }
          }
        },
        "description" : "This type represents the distance matrix contents using normal arrays. For the mapping of distances/travel times/flags to pairs of locations or relations see the documentation of the corresponding GetDistanceMatrixByLocationsRequest and GetDistanceMatrixByRelationsRequest.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdima.DistanceMatrixContentsArrays"
      } ],
      "x-discriminator-value" : "DistanceMatrixContentsArrays",
      "x-ms-discriminator-value" : "DistanceMatrixContentsArrays"
    },
    "DistanceMatrixContentsEncodedArrays" : {
      "allOf" : [ {
        "$ref" : "#/definitions/DistanceMatrixContents"
      }, {
        "type" : "object",
        "properties" : {
          "distances" : {
            "type" : "string",
            "format" : "byte",
            "description" : "The distances of the requested matrix elements expressed in meters."
          },
          "travelTimes" : {
            "type" : "string",
            "format" : "byte",
            "description" : "The travel times of the requested matrix elements expressed in milliseconds."
          },
          "violated" : {
            "type" : "string",
            "format" : "byte",
            "description" : "The violated flags of the requested matrix elements."
          },
          "estimatedByDirectDistance" : {
            "type" : "string",
            "format" : "byte",
            "description" : "The estimated by direct distance flags of the requested matrix elements."
          },
          "tollCosts" : {
            "type" : "string",
            "format" : "byte",
            "description" : "The toll costs of the requested matrix elements in the currency that has been provided in the options of the corresponding xdima.CreateDistanceMatrixRequest."
          }
        },
        "description" : "This type represents the distance matrix contents. It encodes the array of each attribute of a matrix element as byte arrays. For a detailed description of the byte arrays format see distance matrices.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdima.DistanceMatrixContentsEncodedArrays"
      } ],
      "x-discriminator-value" : "DistanceMatrixContentsEncodedArrays",
      "x-ms-discriminator-value" : "DistanceMatrixContentsEncodedArrays"
    },
    "DistanceMatrixContentsOptions" : {
      "type" : "object",
      "properties" : {
        "returnEncodedArrays" : {
          "type" : "boolean",
          "description" : "Indicates if the contents arrays shall be return encoded as byte arrays or as normal arrays."
        }
      },
      "description" : "Specifies how to fill distance matrix contents.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdima.DistanceMatrixContentsOptions"
    },
    "DistanceMatrixContentsResultFields" : {
      "type" : "object",
      "properties" : {
        "distances" : {
          "type" : "boolean",
          "description" : "Indicates if distances should be included in the result."
        },
        "travelTimes" : {
          "type" : "boolean",
          "description" : "Indicates if travel times should be included in the result."
        },
        "violated" : {
          "type" : "boolean",
          "description" : "Indicates if violated flags should be included in the result."
        },
        "estimatedByDirectDistance" : {
          "type" : "boolean",
          "description" : "Indicates if estimated by direct distance flags should be included in the result."
        },
        "tollCosts" : {
          "type" : "boolean",
          "description" : "Indicates if toll costs should be included in the result."
        }
      },
      "description" : "The type represents settings for the result fields for retrieving distance matrix relations.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdima.DistanceMatrixContentsResultFields"
    },
    "DistanceMatrixDescription" : {
      "type" : "object",
      "required" : [ "summary" ],
      "properties" : {
        "summary" : {
          "description" : "The summary of this distance matrix.",
          "$ref" : "#/definitions/DistanceMatrixSummary"
        },
        "startLocations" : {
          "type" : "array",
          "items" : {
            "description" : "The start locations of this distance matrix.",
            "$ref" : "#/definitions/RouteLocation"
          }
        },
        "destinationLocations" : {
          "type" : "array",
          "items" : {
            "description" : "The destination locations of this distance matrix.",
            "$ref" : "#/definitions/RouteLocation"
          }
        },
        "directDistanceRelations" : {
          "type" : "array",
          "items" : {
            "description" : "The list of relations in this distance matrix that could not be calculated without error. Relations are approximated by direct distance if an error occurred during route calculation, for example that a location could not be linked to the road network or no route could be found for the current vehicle profile.",
            "$ref" : "#/definitions/Relation"
          }
        },
        "distanceMatrixOptions" : {
          "description" : "The options used for calculation of this distance matrix.\r\n\r\nWarning: Options are removed from the response if they cannot be represented using the requested API version. This situation might occur if a more recent API version was used for the creation of the distance matrix than for this list request. In general, it is not recommended to mix different API versions.",
          "$ref" : "#/definitions/DistanceMatrixOptions"
        },
        "profile" : {
          "description" : "The profile used for calculation of this distance matrix.\r\n\r\nWarning: Profile elements are removed from the response if they cannot be represented using the requested API version. This restriction also applies to elements of the stored profile used for calculation of this distance matrix. If the returned profile should be used as a request profile in a subsequent request (e.g. for creating another distance matrix or for a route calculation), it is recommended to specify the same stored profile as in the original create request. In general, it is not recommended to mix different API versions.",
          "$ref" : "#/definitions/RequestProfile"
        },
        "tenant" : {
          "type" : "string",
          "description" : "The tenant is returned only for administrators."
        },
        "scope" : {
          "description" : "The user defined scope.",
          "$ref" : "#/definitions/ScopeName"
        },
        "lastUsedAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "Indicates the date the distance matrix was used the last time."
        }
      },
      "description" : "This type represents meta data about a distance matrix.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdima.DistanceMatrixDescription"
    },
    "DistanceMatrixIdNotFoundFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InvalidRequestFault"
      }, {
        "type" : "object",
        "required" : [ "distanceMatrixId" ],
        "properties" : {
          "distanceMatrixId" : {
            "type" : "string",
            "description" : "The distance matrix ID that could not be found."
          }
        },
        "description" : "This fault is thrown if a distance matrix with the specified ID could not be found on the server.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.DistanceMatrixIdNotFoundFault"
      } ],
      "x-discriminator-value" : "DistanceMatrixIdNotFoundFault",
      "x-ms-discriminator-value" : "DistanceMatrixIdNotFoundFault"
    },
    "DistanceMatrixInformation" : {
      "type" : "object",
      "properties" : {
        "distanceMatrixDescription" : {
          "description" : "Meta information that describes the current distance matrix.",
          "$ref" : "#/definitions/DistanceMatrixDescription"
        },
        "listException" : {
          "description" : "Exception in case a requested distance matrix ID is not existing on the server.",
          "$ref" : "#/definitions/SuppressedXServerException"
        }
      },
      "description" : "The result that lists a description of a single distance matrix or the exception that was returned querying the distance matrix ID.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdima.DistanceMatrixInformation"
    },
    "DistanceMatrixListResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "properties" : {
          "distanceMatrixInformation" : {
            "type" : "array",
            "items" : {
              "description" : "The result list containing information about each distance matrix. If specific distance matrix IDs have been requested there is one entry in the list for each requested ID in the same order.",
              "$ref" : "#/definitions/DistanceMatrixInformation"
            }
          }
        },
        "description" : "This type represents a list of meta information on distance matrices.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdima.DistanceMatrixListResponse"
      } ],
      "x-discriminator-value" : "DistanceMatrixListResponse",
      "x-ms-discriminator-value" : "DistanceMatrixListResponse"
    },
    "DistanceMatrixOptions" : {
      "type" : "object",
      "properties" : {
        "timeConsideration" : {
          "description" : "Set this parameter if time dependent features should be considered for the distance matrix calculation. The different scenarios of time consideration are explained in more detail in the technical concept about time consideration. If the object is NULL, all data which have time restrictions are not considered. For some scenarios a reference time is needed to match properties with a time domain against this reference time. If for this time no time zone is defined, i.e. it represents a local time, all matrix locations are checked for their time zone offsets. If a time zone cannot be determined for such a location, this location is not taken into further consideration. So, in a first step a set of locations with calculated time zones is determined. If this set contains no elements, an exception is thrown. When the time zones differ for some locations, then the time zone containing most locations is used and a result limitation is added to the result. If all locations are in the same time zone, then this time zone is used and the result is calculated as usual. Please note that the time consideration values ExactTimeConsiderationAtStart and ExactTimeConsiderationAtArrival are not available and if used an exception will be returned.",
          "$ref" : "#/definitions/TimeConsideration"
        },
        "contentSnapshotId" : {
          "type" : "string",
          "description" : "Specifies the content snapshot to use. If no snapshot ID is set, the most recent content is used."
        },
        "highPerformanceRoutingNetworkId" : {
          "type" : "string",
          "description" : "Specifies the high-performance routing network to use. Besides, the routing type must be explicitly set to RoutingType.HIGH\\_PERFORMANCE\\_ROUTING otherwise a exceptions.ParameterConflictException is thrown. The profile and request parameters of the high-performance routing network are used for linking and routing. The stored profile of the service.RequestBase will be ignored. Throws a exceptions.DataNotAvailableException if the high-performance routing network with the given id does not exist."
        },
        "geographicRestrictions" : {
          "description" : "Geographic restrictions that are considered for each routing that is done during the distance matrix calculation.",
          "$ref" : "#/definitions/GeographicRestrictions"
        },
        "detourFactor" : {
          "type" : "number",
          "format" : "double",
          "description" : "A factor that describes the average detour an actual route on the road requires, compared to the direct distance. This factor is used to approximate a relation that could not be calculated using the road network."
        },
        "averageSpeed" : {
          "description" : "The average speed of the vehicle. This parameter is used to approximate a relation that could not be calculated using the road network.",
          "$ref" : "#/definitions/Speed"
        },
        "routingType" : {
          "description" : "Strategy to decide if high-performance routing or conventional routing is used. For further explanation see the definition of RoutingType.",
          "$ref" : "#/definitions/RoutingType"
        },
        "persistTollCosts" : {
          "type" : "boolean",
          "description" : "Specifies whether to calculate and persist the toll costs of each relation in the distance matrix.  \r\nThe toll costs are persisted and returned in one currency. If no currency is set in the request, an exception is thrown.  \r\nNote that the aggregated toll costs returned by the xDima service can differ slightly from the toll costs returned by the xRoute service because price calculation, currency conversion and rounding is carried out in a different order."
        },
        "currency" : {
          "description" : "Specifies the currency in which the toll costs should be persisted and returned.  \r\nIf the option to persist the toll costs is not set, an exception is thrown.",
          "$ref" : "#/definitions/CurrencyCode"
        },
        "binaryFeatureLayer" : {
          "description" : "Specifies the binary Feature Layer to be considered in the request.",
          "$ref" : "#/definitions/EncodedContent"
        },
        "exchangeRates" : {
          "description" : "Specifies the exchange rates that should be used for the toll price conversion to the target currency.",
          "$ref" : "#/definitions/ExchangeRates"
        }
      },
      "description" : "This type represents options of a distance matrix.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.dima.DistanceMatrixOptions"
    },
    "DistanceMatrixProgress" : {
      "allOf" : [ {
        "$ref" : "#/definitions/JobProgress"
      }, {
        "type" : "object",
        "required" : [ "status" ],
        "properties" : {
          "status" : {
            "description" : "The action currently being performed.",
            "$ref" : "#/definitions/DistanceMatrixProgressStatus"
          },
          "calculationProgress" : {
            "description" : "The progress of the action CALCULATING\\_MATRIX.",
            "$ref" : "#/definitions/Percent"
          },
          "routingType" : {
            "description" : "Indicates what route calculation algorithm is being used for the distances matrix calculation.",
            "$ref" : "#/definitions/RoutingType"
          }
        },
        "description" : "The progress for a running distance matrix calculation.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.dima.DistanceMatrixProgress"
      } ],
      "x-discriminator-value" : "DistanceMatrixProgress",
      "x-ms-discriminator-value" : "DistanceMatrixProgress"
    },
    "DistanceMatrixProgressStatus" : {
      "type" : "string",
      "description" : "Possible status values for a distance matrix progress.  \n * `PREPROCESSING` - Indicates that some tasks have to be done before calculating the matrix. For example loading high-performance routing networks.  \n * `CALCULATING_MATRIX` - The actual progress of this state is available in DistanceMatrixProgress.calculationProgress.  \n * `DONE` - Indicates that the calculation of the distance matrix is finished.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.dima.ProgressStatus",
      "enum" : [ "PREPROCESSING", "CALCULATING_MATRIX", "DONE" ],
      "x-ms-enum" : {
        "name" : "DistanceMatrixProgressStatus",
        "modelAsString" : false
      }
    },
    "DistanceMatrixResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "properties" : {
          "summary" : {
            "description" : "The summary of this distance matrix.",
            "$ref" : "#/definitions/DistanceMatrixSummary"
          },
          "contents" : {
            "description" : "The contents of the distance matrix.",
            "$ref" : "#/definitions/DistanceMatrixContents"
          }
        },
        "description" : "This type represents a summary of the meta information on a distance matrix and also contains contents of the distance matrix if requested.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdima.DistanceMatrixResponse"
      } ],
      "x-discriminator-value" : "DistanceMatrixResponse",
      "x-ms-discriminator-value" : "DistanceMatrixResponse"
    },
    "DistanceMatrixResultFields" : {
      "type" : "object",
      "properties" : {
        "summary" : {
          "type" : "boolean",
          "description" : "Indicates if the summary should be included in the result."
        },
        "distanceMatrixContentsResultFields" : {
          "description" : "Further possibilities to customize the result of the contents of the distance matrix.",
          "$ref" : "#/definitions/DistanceMatrixContentsResultFields"
        }
      },
      "description" : "Settings for the result fields of the contents of a distance matrix.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdima.DistanceMatrixResultFields"
    },
    "DistanceMatrixSummary" : {
      "type" : "object",
      "required" : [ "numberOfDestinationLocations", "numberOfStartLocations", "percentageOfDirectDistanceRelations" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "The ID of the distance matrix which is generated when the distance matrix is created. Use this ID to reference the matrix for further use."
        },
        "numberOfStartLocations" : {
          "description" : "The number of start locations in the distance matrix.",
          "$ref" : "#/definitions/PositiveInteger"
        },
        "numberOfDestinationLocations" : {
          "description" : "The number of destination locations in the distance matrix.",
          "$ref" : "#/definitions/PositiveInteger"
        },
        "percentageOfDirectDistanceRelations" : {
          "description" : "Percentage of relations in the distance matrix which has not been calculated successfully. It depends on the use case and the geographical region which values can be tolerated or not.",
          "$ref" : "#/definitions/Percent"
        },
        "routingType" : {
          "description" : "Indicates what route calculation algorithm was used for the distances matrix calculation. If a profile dependent high-performance routing network is configured but there is no matching high-performance graph for the called profile the routing mode will fall back to profile independent routing.",
          "$ref" : "#/definitions/RoutingType"
        },
        "label" : {
          "description" : "The optional label of the distance matrix, if it was specified in the request. This label is only used for displaying the distance matrix, e.g. in the dashboard, and is not considered in any other way.",
          "$ref" : "#/definitions/UserDefinedName"
        }
      },
      "description" : "Represents the meta information of a distance matrix.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.dima.DistanceMatrixSummary"
    },
    "DistanceMode" : {
      "type" : "object",
      "required" : [ "$type" ],
      "discriminator" : "$type",
      "properties" : {
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "The abstract base type for different modes how distances can be retrieved for clustering or tour planning.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.dima.DistanceMode"
    },
    "DistanceViolation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TourViolation"
      }, {
        "type" : "object",
        "properties" : {
          "exceedance" : {
            "description" : "Distance by which the limit is exceeded on the current leg in total.",
            "type" : "number"
          }
        },
        "description" : "Specifies a violation that involves a distance limit. This violation has one of the following tour event violation types: MAXIMUM\\_DISTANCE.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.tourplanning.DistanceViolation"
      } ],
      "x-discriminator-value" : "DistanceViolation",
      "x-ms-discriminator-value" : "DistanceViolation"
    },
    "DriveType" : {
      "type" : "string",
      "description" : "Defines the type of drive.  \n * `MOTOR_VEHICLE` - All common motor vehicles, e.g. cars, trucks, motorcycles etc.  \n * `BICYCLE` - Bicycles and other vehicles with very limited engines such as e-bikes or mopeds.  \n * `PEDESTRIAN` - Pedestrians.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.vehicleprofile.DriveType",
      "enum" : [ "MOTOR_VEHICLE", "BICYCLE", "PEDESTRIAN" ],
      "x-ms-enum" : {
        "name" : "DriveType",
        "modelAsString" : false
      }
    },
    "Driver" : {
      "type" : "object",
      "required" : [ "id", "vehicleId" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "ID of the driver."
        },
        "operatingIntervals" : {
          "type" : "array",
          "items" : {
            "description" : "Interval during which the driver is available. The intervals must have a gap of more than 1 second. Each trip must lie completely within one of the operating intervals. The driving time outside trips must also lie completely within one of the operating intervals except for rest positions ANYWHERE chosen. The tour start and trip start events must lie within one of the operating intervals. Leaving this parameter empty means that the driver is always available. If multiple operating intervals are used for at least one driver, no time dependent distance matrix and no evaluateToursInExecution request may be used. If any operating interval contains a GDF time domain, a planning horizon is required.",
            "$ref" : "#/definitions/Interval"
          }
        },
        "breakIntervals" : {
          "type" : "array",
          "items" : {
            "description" : "List of intervals within which the driver wants or needs to take a break. Intervals must be pairwise disjoint. The list must be empty if working hours are set. If any break interval contains a GDF time domain, a planning horizon is required.",
            "$ref" : "#/definitions/BreakInterval"
          }
        },
        "vehicleId" : {
          "type" : "string",
          "description" : "ID of the driver's vehicle."
        },
        "workLogbookSummary" : {
          "description" : "The summary of a logbook of a driver. If such a summary is missing, it is assumed that the driver is fully rested.",
          "$ref" : "#/definitions/WorkLogbookSummary"
        }
      },
      "description" : "A driver is always assigned to a specific vehicle instance and may not always be available to operate it. To be precise, a driver can only operate the corresponding vehicle instance within given time intervals. In addition, it may be specified how long the driver has already worked.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.Driver"
    },
    "DrivingTimeRegulation" : {
      "type" : "string",
      "description" : "Defines which driving time regulation needs to be complied with.  \n * `NONE` - No restriction of drivers' working hours.  \n * `EU_EC_561_2006` - Regulation (EC) No 561/2006 of the European Parliament and of the Council.  \n * `US_FMCSA_395_2013` - Hours of Service (HOS) regulation as issued by the Federal Motor Carrier Safety Administration (FMCSA) in 2013.  \n * `US_FMCSA_395_2020` - Hours of Service (HOS) regulation as issued by the Federal Motor Carrier Safety Administration (FMCSA) in 2020.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.tourplanning.DrivingTimeRegulation",
      "enum" : [ "NONE", "EU_EC_561_2006", "US_FMCSA_395_2013", "US_FMCSA_395_2020" ],
      "x-ms-enum" : {
        "name" : "DrivingTimeRegulation",
        "modelAsString" : false
      }
    },
    "DrivingTimeRegulationLogbookSummary" : {
      "type" : "object",
      "required" : [ "$type" ],
      "discriminator" : "$type",
      "properties" : {
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "The summary of a logbook of a driver. If provided as input, it is taken into account when the mandatory breaks and rests are calculated.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.tourplanning.DrivingTimeRegulationLogbookSummary"
    },
    "DrivingTimeRegulationLogbookSummary_EU_EC_561_2006" : {
      "allOf" : [ {
        "$ref" : "#/definitions/DrivingTimeRegulationLogbookSummary"
      }, {
        "type" : "object",
        "properties" : {
          "accumulatedDrivingTimeSinceLastBreak" : {
            "description" : "Accumulated driving time since end of last break. As soon as 4.5 hours are accumulated, the driver is no longer allowed to drive unless he/she takes a break. A value of more than 4.5 hours has the same effect as 4.5 hours.",
            "$ref" : "#/definitions/Duration"
          },
          "accumulatedDrivingTimeSinceLastDailyRest" : {
            "description" : "Accumulated driving time since end of last daily rest. As soon as 9 hours are accumulated, the driver is no longer allowed to drive unless he/she takes a daily rest. A value of more than 9 hours has the same effect as 9 hours. May not be smaller than accumulatedDrivingTimeSinceLastBreak, otherwise an exception is thrown.",
            "$ref" : "#/definitions/Duration"
          },
          "elapsedTimeSinceEndOfLastDailyRest" : {
            "description" : "Elapsed time since end of last daily rest, that is, the time between the end of the last daily rest and the reference time. As soon as 13 hours have elapsed, the driver is no longer allowed to drive or perform service unless he/she takes a daily rest. A value of more than 13 hours has the same effect as 13 hours. May not be smaller than accumulatedDrivingTimeSinceLastDailyRest, otherwise an exception is thrown.",
            "$ref" : "#/definitions/Duration"
          }
        },
        "description" : "According to Regulation (EC) 561/2006 of the European Union.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.tourplanning.DrivingTimeRegulationLogbookSummary\\_EU\\_EC\\_561\\_2006"
      } ],
      "x-discriminator-value" : "DrivingTimeRegulationLogbookSummary_EU_EC_561_2006",
      "x-ms-discriminator-value" : "DrivingTimeRegulationLogbookSummary_EU_EC_561_2006"
    },
    "DrivingTimeRegulationLogbookSummary_US_FMCSA_395_2020" : {
      "allOf" : [ {
        "$ref" : "#/definitions/DrivingTimeRegulationLogbookSummary"
      }, {
        "type" : "object",
        "properties" : {
          "accumulatedDrivingTimeSinceLastBreak" : {
            "description" : "Accumulated driving time since end of last break. As soon as 8 hours are accumulated, the driver is no longer allowed to drive unless he/she takes a break. A value of more than 8 hours has the same effect as 8 hours.",
            "$ref" : "#/definitions/Duration"
          },
          "accumulatedDrivingTimeSinceLastDailyRest" : {
            "description" : "Accumulated driving time since end of last daily rest. As soon as 11 hours are accumulated, the driver is no longer allowed to drive unless he/she takes a daily rest. A value of more than 11 hours has the same effect as 11 hours. May not be smaller than accumulatedDrivingTimeSinceLastBreak, otherwise an exception is thrown.",
            "$ref" : "#/definitions/Duration"
          },
          "elapsedTimeSinceEndOfLastDailyRest" : {
            "description" : "Elapsed time since end of last daily rest, that is, the time between the end of the last daily rest and the reference time. As soon as 14 hours have elapsed, the driver is no longer allowed to drive or perform service unless he/she takes a daily rest. A value of more than 14 hours has the same effect as 14 hours. May not be smaller than accumulatedDrivingTimeSinceLastDailyRest, otherwise an exception is thrown.",
            "$ref" : "#/definitions/Duration"
          }
        },
        "description" : "According to the Hours of Service of Drivers published in 2020 in the United States.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.tourplanning.DrivingTimeRegulationLogbookSummary\\_US\\_FMCSA\\_395\\_2020"
      } ],
      "x-discriminator-value" : "DrivingTimeRegulationLogbookSummary_US_FMCSA_395_2020",
      "x-ms-discriminator-value" : "DrivingTimeRegulationLogbookSummary_US_FMCSA_395_2020"
    },
    "DrivingTimeRegulationOptions" : {
      "type" : "object",
      "required" : [ "$type" ],
      "discriminator" : "$type",
      "properties" : {
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "Defines options which can be applied to a specific driving time regulation.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.tourplanning.DrivingTimeRegulationOptions"
    },
    "DrivingTimeRegulationOptions_US_FMCSA_395_2013" : {
      "allOf" : [ {
        "$ref" : "#/definitions/DrivingTimeRegulationOptions"
      }, {
        "type" : "object",
        "properties" : {
          "thirtyFourHourRestartRule" : {
            "type" : "boolean",
            "description" : "Tells if the 34-hour restart can be applied after the weekly on duty hours limit has been reached. Basically, if 34 or more consecutive hours off duty are taken, it restarts the weekly on duty hours counting to zero."
          },
          "weeklyOnDutyHoursLimit" : {
            "description" : "Defines the weekly on duty hours limit to apply.",
            "$ref" : "#/definitions/WeeklyOnDutyHoursLimit_US_FMCSA_395_2013"
          },
          "twentyFourHourPeriodStartsAt" : {
            "description" : "Defines the start time of a 24-hour period. The weekly on duty hours limit is based on a rolling 7 or 8-day period starting at this specific time. In general, it is up to the motor carrier to set this value.",
            "$ref" : "#/definitions/TimeOfDay"
          },
          "thirtyMinuteBreakRule" : {
            "type" : "boolean",
            "description" : "Tells if the 30-minute break provision is enforced after 8 on-duty consecutive hours (e.g. it is not required to be enforced for short haul operations)."
          }
        },
        "description" : "Defines options which can be applied to the US Hours Of Service regulation FMCSA 395/2013.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.tourplanning.DrivingTimeRegulationOptions\\_US\\_FMCSA\\_395\\_2013"
      } ],
      "x-discriminator-value" : "DrivingTimeRegulationOptions_US_FMCSA_395_2013",
      "x-ms-discriminator-value" : "DrivingTimeRegulationOptions_US_FMCSA_395_2013"
    },
    "DrivingTimeRegulationOptions_US_FMCSA_395_2020" : {
      "allOf" : [ {
        "$ref" : "#/definitions/DrivingTimeRegulationOptions"
      }, {
        "type" : "object",
        "properties" : {
          "thirtyFourHourRestartRule" : {
            "type" : "boolean",
            "description" : "Tells if the 34-hour restart can be applied after the weekly on duty hours limit has been reached. Basically, if 34 or more consecutive hours off duty are taken, it restarts the weekly on duty hours counting to zero."
          },
          "weeklyOnDutyHoursLimit" : {
            "description" : "Defines the weekly on duty hours limit to apply.",
            "$ref" : "#/definitions/WeeklyOnDutyHoursLimit_US_FMCSA_395_2020"
          },
          "twentyFourHourPeriodStartsAt" : {
            "description" : "Defines the start time of a 24-hour period. The weekly on duty hours limit is based on a rolling 7 or 8-day period starting at this specific time. In general, it is up to the motor carrier to set this value.",
            "$ref" : "#/definitions/TimeOfDay"
          },
          "thirtyMinuteBreakRule" : {
            "type" : "boolean",
            "description" : "Tells if the 30-minute break provision is enforced after 8 cumulative hours of driving time (e.g. it is not required to be enforced for short haul operations)."
          }
        },
        "description" : "Defines options which can be applied to the US Hours Of Service regulation FMCSA 395/2020.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.tourplanning.DrivingTimeRegulationOptions\\_US\\_FMCSA\\_395\\_2020"
      } ],
      "x-discriminator-value" : "DrivingTimeRegulationOptions_US_FMCSA_395_2020",
      "x-ms-discriminator-value" : "DrivingTimeRegulationOptions_US_FMCSA_395_2020"
    },
    "DuplicateProfileFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/SetupFault"
      }, {
        "type" : "object",
        "properties" : {
          "fileName" : {
            "description" : "The name of the profile file that is present in two folders.",
            "$ref" : "#/definitions/FileName"
          }
        },
        "description" : "This fault is thrown if the profile folder contains two files with the same name in different subfolders.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.DuplicateProfileFault"
      } ],
      "x-discriminator-value" : "DuplicateProfileFault",
      "x-ms-discriminator-value" : "DuplicateProfileFault"
    },
    "Duration" : {
      "type" : "number",
      "format" : "double",
      "description" : "Defines the type used for expressing durations in \\[s\\]. The xtour and xcluster services only provide an accuracy of seconds. The value is rounded to whole seconds in this case. Range: 0.0 ??? value.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.Duration"
    },
    "ETACalculationOptions" : {
      "type" : "object",
      "required" : [ "vehiclePosition" ],
      "properties" : {
        "vehiclePosition" : {
          "description" : "Position of the vehicle.",
          "$ref" : "#/definitions/RoutingVehiclePosition"
        }
      },
      "description" : "Specifies the options to calculate the estimated time of arrival. A PathWaypoint is needed to use this feature.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.ETACalculationOptions"
    },
    "ETACalculationReport" : {
      "type" : "object",
      "properties" : {
        "newRoute" : {
          "type" : "boolean",
          "description" : "If set to true, indicates that the route has been recalculated, ignoring the given PathWaypoint."
        },
        "travelTimeExceeded" : {
          "type" : "boolean",
          "description" : "If set to true, indicates that the travel time of a segment has been recalculated because it exceeded 2h30."
        }
      },
      "description" : "Represents the summary of a route which has been calculated using the ETACalculationOptions.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.ETACalculationReport"
    },
    "EffectiveFuelConsumption" : {
      "type" : "object",
      "properties" : {
        "fleetSpecificAverageFuelConsumption" : {
          "description" : "The average fuel consumption for a fleet in \\[l/100km\\] for liquid fuel types or \\[kg/100km\\] for gaseous fuel types like COMPRESSED\\_NATURAL\\_GAS.",
          "$ref" : "#/definitions/EnergyConsumption"
        },
        "routeSpecificAverageFuelConsumption" : {
          "description" : "The average fuel consumption for a specific type of route in \\[l/100km\\] for liquid fuel types or \\[kg/100km\\] for gaseous fuel types like COMPRESSED\\_NATURAL\\_GAS.",
          "$ref" : "#/definitions/EnergyConsumption"
        },
        "actualFuelConsumptionForThisRoute" : {
          "description" : "The actual fuel consumption for this route in \\[l\\] for liquid fuel types or \\[kg\\] for gaseous fuel types like COMPRESSED\\_NATURAL\\_GAS.",
          "$ref" : "#/definitions/EnergyConsumption"
        }
      },
      "description" : "The attributes for calculating CEN or factor-based emissions. The response element contains only those scenarios for which the corresponding request parameter is set.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.EffectiveFuelConsumption"
    },
    "ElevationsNotAvailableLimitation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResultLimitation"
      }, {
        "type" : "object",
        "required" : [ "elevationsDataAvailable" ],
        "properties" : {
          "routePolylineIndices" : {
            "type" : "array",
            "items" : {
              "description" : "The intervals of the RouteResponse.polyline for which elevations are not available.\r\n\r\nThe list is only populated if the polyline for the whole route was requested by ResultFields.polyline.",
              "$ref" : "#/definitions/IndexInterval"
            }
          },
          "segmentPolylineIndices" : {
            "type" : "array",
            "items" : {
              "description" : "The intervals of the Segment.polyline for which elevations are not available.\r\n\r\nIndexPair.first denotes the index of the segment where the interval starts/ends.\r\n\r\nIndexPair.second denotes the index of the polypoint for the segment where the interval starts/ends.\r\n\r\nThe list is only populated if segments were requested by ResultFields.segments.",
              "$ref" : "#/definitions/IndexPairInterval"
            }
          },
          "legPolylineIndices" : {
            "type" : "array",
            "items" : {
              "description" : "The intervals of the Leg.polyline for which elevations are not available.\r\n\r\nIndexPair.first denotes the index of the leg where the interval starts/ends.\r\n\r\nIndexPair.second denotes the index of the polypoint for the leg where the interval starts/ends.\r\n\r\nThe list is only populated if legs were requested by ResultFields.legs.",
              "$ref" : "#/definitions/IndexPairInterval"
            }
          },
          "elevationsDataAvailable" : {
            "type" : "boolean",
            "description" : "Specifies whether elevation data are available at all. If true, the route is beyond the limits of the data, otherwise elevations could not be calculated, at all."
          }
        },
        "description" : "This result limitation indicates that elevations could not be calculated for the route or at least parts of it. The z-coordinate of the points where the elevations could not be calculated is 0. By default the coverage of elevations data is between +60?? and -60?? latitude.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.ElevationsNotAvailableLimitation"
      } ],
      "x-discriminator-value" : "ElevationsNotAvailableLimitation",
      "x-ms-discriminator-value" : "ElevationsNotAvailableLimitation"
    },
    "EmissionOptions" : {
      "type" : "object",
      "properties" : {
        "valueScenarios" : {
          "type" : "array",
          "items" : {
            "description" : "The list of Emission scenarios.",
            "$ref" : "#/definitions/EmissionValueScenario"
          }
        }
      },
      "description" : "The emissions for different fuel consumption scenarios. Only those scenarios will be returned for which the corresponding request parameter is set.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.EmissionOptions"
    },
    "EmissionStandardAustralia" : {
      "type" : "string",
      "description" : "Defines the emission standard of the vehicle valid in Australia.  \n * `NONE` - The vehicle is not assigned an emission standard for Australia.  \n * `ADR_30` - Australian design rule 30.  \n * `ADR_70_00` - Australian design rule 70/00.  \n * `ADR_80_00` - Australian design rule 80/00.  \n * `ADR_80_02` - Australian design rule 80/02.  \n * `ADR_80_03` - Australian design rule 80/03.  \n * `ADR_80_04` - Australian design rule 80/04.  \n * `ADR_80_05` - Australian design rule 80/05.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.vehicleprofile.EmissionStandardAustralia",
      "enum" : [ "NONE", "ADR_30", "ADR_70_00", "ADR_80_00", "ADR_80_02", "ADR_80_03", "ADR_80_04", "ADR_80_05" ],
      "x-ms-enum" : {
        "name" : "EmissionStandardAustralia",
        "modelAsString" : false
      }
    },
    "EmissionStandardEU" : {
      "type" : "string",
      "description" : "Defines the emission standard of the vehicle valid in the European Union.  \n * `NONE` - The vehicle is not assigned an emission standard for the European Union.  \n * `EURO_0` - Euro 0 standards (old standards 1988-1992).  \n * `EURO_1` - Euro 1 standards (also known as EC 93): Directives 91/441/EEC (passenger cars only) or 93/59/EEC (passenger cars and light trucks).  \n * `EURO_2` - Euro 2 standards (EC 96): Directives 94/12/EC and 96/69/EC for passenger cars, 2002/51/EC(row A)-2006/120/EC for motorcycle.  \n * `EURO_3` - Euro 3 standards (2000): Directives 98/69/EC for any vehicle, 2002/51/EC(row A)-2006/120/EC for motorcycle.  \n * `EURO_4` - Euro 4 standards (2005): Directives 98/69/EC and 2002/80/EC for any vehicle.  \n * `EURO_5` - Euro 5 standards (2008/9): Directive 715/2007/EC for any vehicle.  \n * `EURO_EEV` - Standards for enhanced environmentally friendly vehicles. The standard lies between the levels of Euro V and Euro VI.  \n * `EURO_6` - Euro 6 standards (2014): Directive 715/2007/EC for any vehicle. Includes 6a and 6b.  \n * `EURO_6c` - Euro 6c standards (2017): for passenger cars and light trucks.  \n * `EURO_7` - Euro 7 standards (to appear 2025).\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.vehicleprofile.EmissionStandardEU",
      "enum" : [ "NONE", "EURO_0", "EURO_1", "EURO_2", "EURO_3", "EURO_4", "EURO_5", "EURO_EEV", "EURO_6", "EURO_6c", "EURO_7" ],
      "x-ms-enum" : {
        "name" : "EmissionStandardEU",
        "modelAsString" : false
      }
    },
    "EmissionStandardType" : {
      "type" : "string",
      "description" : "Define all available emission types  \n * `HBEFA_3_2` - The emission calculation based on the Handbook of Emission Factors for Road Transport (HBEFA). HBEFA 3.2 calculation reports values for all global warming gases and other harmful substances. The internal process is independently certificated and therefore is independent of any external organizations.  \n * `HBEFA_4` - The emission calculation based on the Handbook of Emission Factors for Road Transport (HBEFA). HBEFA 4 calculation reports values for all global warming gases and other harmful substances. The internal process is independently certificated and therefore is independent of any external organizations.  \n * `EMISIA_COPERT_AUSTRALIA_1_2` - The emission calculation based on the Computer Program to calculate Emissions from Road Transport (COPERT). The COPERT Australia emission calculation reports values for CO2 and fuel consumption.  \n * `EN16258_2012` - The emission calculation according to the European CEN standard (EN16258).  \n * `FRENCH_CO2_DECREE_2011_1336` - Emission calculation according to the French CO2 decree uses various calculation factors for the average fuel consumption of a vehicle. Only the following biofuel blends are supported: E10, E85 and B30. These blends can be set using the VehicleParameters FUEL\\_TYPE and BIO\\_FUEL\\_RATIO.  \n * `EN16258_DEFRA_2014` - The emission calculation based on the emission factors provided by the Department for Environment, Food & Rural Affairs (Defra) in the United Kingdom , factors 2014.  \n * `AUSTRALIAN_NGA_FACTORS_2015` - The emission calculation based on the Australian National Greenhouse Accounts (NGA), factors 2015. To specify the emission class and the year of manufacture for each vehicle.  \n * `FRENCH_CO2E_DECREE_2017_639` - Emission calculation according to the 2017 French CO2E decree uses various calculation factors for the average fuel consumption of a vehicle. Only the following biofuel blends are supported: E10, E85 and B30. These blends can be set using the VehicleParameters FUEL\\_TYPE and BIO\\_FUEL\\_RATIO.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.emissions.EmissionStandardType",
      "enum" : [ "HBEFA_3_2", "HBEFA_4", "EMISIA_COPERT_AUSTRALIA_1_2", "EN16258_2012", "FRENCH_CO2_DECREE_2011_1336", "EN16258_DEFRA_2014", "AUSTRALIAN_NGA_FACTORS_2015", "FRENCH_CO2E_DECREE_2017_639" ],
      "x-ms-enum" : {
        "name" : "EmissionStandardType",
        "modelAsString" : false
      }
    },
    "EmissionTechnology" : {
      "type" : "string",
      "description" : "Defines the emission reduction technology of the vehicle (from HBEFA).  \n * `NONE` - No emission reduction technology.  \n * `EXHAUST_GAS_RECIRCULATION` - Exhaust gas recirculation technology.  \n * `SELECTIVE_CATALYTIC_REDUCTION` - Selective catalytic reduction.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.vehicleprofile.EmissionTechnology",
      "enum" : [ "NONE", "EXHAUST_GAS_RECIRCULATION", "SELECTIVE_CATALYTIC_REDUCTION" ],
      "x-ms-enum" : {
        "name" : "EmissionTechnology",
        "modelAsString" : false
      }
    },
    "EmissionValueScenario" : {
      "type" : "object",
      "required" : [ "$type" ],
      "discriminator" : "$type",
      "properties" : {
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "The base type for scenarios which will be used in emission calculation.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.emissions.EmissionValueScenario"
    },
    "EmissionValueScenarioType_Australian_Nga_Factors_2015" : {
      "type" : "string",
      "description" : "Define the option of scenario to calculate Australia NGA emissions  \n * `VEHICLE_SPECIFIC_AVERAGE_FUEL_CONSUMPTION` - The calculation of emissions is based on the current vehicle profile.  \n * `FLEET_SPECIFIC_AVERAGE_FUEL_CONSUMPTION` - The average fuel consumption for a fleet in \\[l/100km\\] for liquid fuel types or \\[kg/100km\\] for gaseous fuel types like COMPRESSED\\_NATURAL\\_GAS.  \n * `ROUTE_SPECIFIC_AVERAGE_FUEL_CONSUMPTION` - The average fuel consumption for a specific type of route in \\[l/100km\\] for liquid fuel types or \\[kg/100km\\] for gaseous fuel types like COMPRESSED\\_NATURAL\\_GAS.  \n * `ACTUAL_FUEL_CONSUMPTION` - The actual fuel consumption for this route in \\[l\\] for liquid fuel types or \\[kg\\] for gaseous fuel types like COMPRESSED\\_NATURAL\\_GAS.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.emissions.EmissionValueScenarioType\\_AUSTRALIAN\\_NGA\\_FACTORS\\_2015",
      "enum" : [ "VEHICLE_SPECIFIC_AVERAGE_FUEL_CONSUMPTION", "FLEET_SPECIFIC_AVERAGE_FUEL_CONSUMPTION", "ROUTE_SPECIFIC_AVERAGE_FUEL_CONSUMPTION", "ACTUAL_FUEL_CONSUMPTION" ],
      "x-ms-enum" : {
        "name" : "EmissionValueScenarioType_Australian_Nga_Factors_2015",
        "modelAsString" : false
      }
    },
    "EmissionValueScenarioType_EN16258_2012" : {
      "type" : "string",
      "description" : "Define the option of scenario to calculate CEN emissions  \n * `VEHICLE_SPECIFIC_AVERAGE_FUEL_CONSUMPTION` - The calculation of emissions is based on the current vehicle profile.  \n * `FLEET_SPECIFIC_AVERAGE_FUEL_CONSUMPTION` - The average fuel consumption for a fleet in \\[l/100km\\] for liquid fuel types or \\[kg/100km\\] for gaseous fuel types like COMPRESSED\\_NATURAL\\_GAS.  \n * `ROUTE_SPECIFIC_AVERAGE_FUEL_CONSUMPTION` - The average fuel consumption for a specific type of route in \\[l/100km\\] for liquid fuel types or \\[kg/100km\\] for gaseous fuel types like COMPRESSED\\_NATURAL\\_GAS.  \n * `ACTUAL_FUEL_CONSUMPTION` - The actual fuel consumption for this route in \\[l\\] for liquid fuel types or \\[kg\\] for gaseous fuel types like COMPRESSED\\_NATURAL\\_GAS.  \n * `HBEFA_BASED_FUEL_CONSUMPTION` - The emissions based on the fuel consumption as it was calculated by the latest HBEFA version available.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.emissions.EmissionValueScenarioType\\_EN16258\\_2012",
      "enum" : [ "VEHICLE_SPECIFIC_AVERAGE_FUEL_CONSUMPTION", "FLEET_SPECIFIC_AVERAGE_FUEL_CONSUMPTION", "ROUTE_SPECIFIC_AVERAGE_FUEL_CONSUMPTION", "ACTUAL_FUEL_CONSUMPTION", "HBEFA_BASED_FUEL_CONSUMPTION" ],
      "x-ms-enum" : {
        "name" : "EmissionValueScenarioType_EN16258_2012",
        "modelAsString" : false
      }
    },
    "EmissionValueScenarioType_EN16258_DEFRA_2014" : {
      "type" : "string",
      "description" : "Define the option of scenario to calculate DEFRA emissions  \n * `VEHICLE_SPECIFIC_AVERAGE_FUEL_CONSUMPTION` - The calculation of emissions is based on the current vehicle profile.  \n * `FLEET_SPECIFIC_AVERAGE_FUEL_CONSUMPTION` - The average fuel consumption for a fleet in \\[l/100km\\] for liquid fuel types or \\[kg/100km\\] for gaseous fuel types like COMPRESSED\\_NATURAL\\_GAS.  \n * `ROUTE_SPECIFIC_AVERAGE_FUEL_CONSUMPTION` - The average fuel consumption for a specific type of route in \\[l/100km\\] for liquid fuel types or \\[kg/100km\\] for gaseous fuel types like COMPRESSED\\_NATURAL\\_GAS.  \n * `ACTUAL_FUEL_CONSUMPTION` - The actual fuel consumption for this route in \\[l\\] for liquid fuel types or \\[kg\\] for gaseous fuel types like COMPRESSED\\_NATURAL\\_GAS.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.emissions.EmissionValueScenarioType\\_EN16258\\_DEFRA\\_2014",
      "enum" : [ "VEHICLE_SPECIFIC_AVERAGE_FUEL_CONSUMPTION", "FLEET_SPECIFIC_AVERAGE_FUEL_CONSUMPTION", "ROUTE_SPECIFIC_AVERAGE_FUEL_CONSUMPTION", "ACTUAL_FUEL_CONSUMPTION" ],
      "x-ms-enum" : {
        "name" : "EmissionValueScenarioType_EN16258_DEFRA_2014",
        "modelAsString" : false
      }
    },
    "EmissionValueScenarioType_Emisia_Copert_Australia_1_2" : {
      "type" : "string",
      "description" : "Define the option of scenario to calculate COPERT emissions  \n * `CURRENT_ROUTE` - The emissions are calculated on the current route, considering the current vehicle profile.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.emissions.EmissionValueScenarioType\\_EMISIA\\_COPERT\\_AUSTRALIA\\_1\\_2",
      "enum" : [ "CURRENT_ROUTE" ],
      "x-ms-enum" : {
        "name" : "EmissionValueScenarioType_Emisia_Copert_Australia_1_2",
        "modelAsString" : false
      }
    },
    "EmissionValueScenarioType_French_CO2_Decree_2011_1336" : {
      "type" : "string",
      "description" : "Define the option of scenario to calculate French CO2 decree emissions  \n * `VEHICLE_SPECIFIC_AVERAGE_FUEL_CONSUMPTION` - The calculation of emissions is based on the current vehicle profile.  \n * `FLEET_SPECIFIC_AVERAGE_FUEL_CONSUMPTION` - The average fuel consumption for a fleet in \\[l/100km\\] for liquid fuel types or \\[kg/100km\\] for gaseous fuel types like COMPRESSED\\_NATURAL\\_GAS.  \n * `ROUTE_SPECIFIC_AVERAGE_FUEL_CONSUMPTION` - The average fuel consumption for a specific type of route in \\[l/100km\\] for liquid fuel types or \\[kg/100km\\] for gaseous fuel types like COMPRESSED\\_NATURAL\\_GAS.  \n * `ACTUAL_FUEL_CONSUMPTION` - The actual fuel consumption for this route in \\[l\\] for liquid fuel types or \\[kg\\] for gaseous fuel types like COMPRESSED\\_NATURAL\\_GAS.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.emissions.EmissionValueScenarioType\\_FRENCH\\_CO2\\_DECREE\\_2011\\_1336",
      "enum" : [ "VEHICLE_SPECIFIC_AVERAGE_FUEL_CONSUMPTION", "FLEET_SPECIFIC_AVERAGE_FUEL_CONSUMPTION", "ROUTE_SPECIFIC_AVERAGE_FUEL_CONSUMPTION", "ACTUAL_FUEL_CONSUMPTION" ],
      "x-ms-enum" : {
        "name" : "EmissionValueScenarioType_French_CO2_Decree_2011_1336",
        "modelAsString" : false
      }
    },
    "EmissionValueScenarioType_French_CO2e_Decree_2017_639" : {
      "type" : "string",
      "description" : "Define the option of scenario to calculate 2017 French CO2E decree emissions  \n * `VEHICLE_SPECIFIC_AVERAGE_FUEL_CONSUMPTION` - The calculation of emissions is based on the current vehicle profile.  \n * `FLEET_SPECIFIC_AVERAGE_FUEL_CONSUMPTION` - The average fuel consumption for a fleet in \\[l/100km\\] for liquid fuel types or \\[kg/100km\\] for gaseous fuel types like COMPRESSED\\_NATURAL\\_GAS.  \n * `ROUTE_SPECIFIC_AVERAGE_FUEL_CONSUMPTION` - The average fuel consumption for a specific type of route in \\[l/100km\\] for liquid fuel types or \\[kg/100km\\] for gaseous fuel types like COMPRESSED\\_NATURAL\\_GAS.  \n * `ACTUAL_FUEL_CONSUMPTION` - The actual fuel consumption for this route in \\[l\\] for liquid fuel types or \\[kg\\] for gaseous fuel types like COMPRESSED\\_NATURAL\\_GAS.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.emissions.EmissionValueScenarioType\\_FRENCH\\_CO2E\\_DECREE\\_2017\\_639",
      "enum" : [ "VEHICLE_SPECIFIC_AVERAGE_FUEL_CONSUMPTION", "FLEET_SPECIFIC_AVERAGE_FUEL_CONSUMPTION", "ROUTE_SPECIFIC_AVERAGE_FUEL_CONSUMPTION", "ACTUAL_FUEL_CONSUMPTION" ],
      "x-ms-enum" : {
        "name" : "EmissionValueScenarioType_French_CO2e_Decree_2017_639",
        "modelAsString" : false
      }
    },
    "EmissionValueScenarioType_HBEFA_3_2" : {
      "type" : "string",
      "description" : "Define the option of scenario to calculate HBEFA 3.2 emissions  \n * `CURRENT_ROUTE` - The emissions are calculated on the current route, considering the current vehicle profile.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.emissions.EmissionValueScenarioType\\_HBEFA\\_3\\_2",
      "enum" : [ "CURRENT_ROUTE" ],
      "x-ms-enum" : {
        "name" : "EmissionValueScenarioType_HBEFA_3_2",
        "modelAsString" : false
      }
    },
    "EmissionValueScenarioType_HBEFA_4" : {
      "type" : "string",
      "description" : "Define the option of scenario to calculate HBEFA 4 emissions  \n * `CURRENT_ROUTE` - The emissions are calculated on the current route, considering the current vehicle profile.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.emissions.EmissionValueScenarioType\\_HBEFA\\_4",
      "enum" : [ "CURRENT_ROUTE" ],
      "x-ms-enum" : {
        "name" : "EmissionValueScenarioType_HBEFA_4",
        "modelAsString" : false
      }
    },
    "EmissionValueScenario_Australian_Nga_Factors_2015" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EmissionValueScenario"
      }, {
        "type" : "object",
        "properties" : {
          "scenarios" : {
            "type" : "array",
            "items" : {
              "description" : "Define all scenarios that will be calculated",
              "$ref" : "#/definitions/EmissionValueScenarioType_Australian_Nga_Factors_2015"
            }
          }
        },
        "description" : "Define the scenario for Australia NGA\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.emissions.EmissionValueScenario\\_AUSTRALIAN\\_NGA\\_FACTORS\\_2015"
      } ],
      "x-discriminator-value" : "EmissionValueScenario_AUSTRALIAN_NGA_FACTORS_2015",
      "x-ms-discriminator-value" : "EmissionValueScenario_AUSTRALIAN_NGA_FACTORS_2015"
    },
    "EmissionValueScenario_EN16258_2012" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EmissionValueScenario"
      }, {
        "type" : "object",
        "properties" : {
          "scenarios" : {
            "type" : "array",
            "items" : {
              "description" : "Define all scenarios that will be calculated",
              "$ref" : "#/definitions/EmissionValueScenarioType_EN16258_2012"
            }
          }
        },
        "description" : "Define the scenario for CEN\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.emissions.EmissionValueScenario\\_EN16258\\_2012"
      } ],
      "x-discriminator-value" : "EmissionValueScenario_EN16258_2012",
      "x-ms-discriminator-value" : "EmissionValueScenario_EN16258_2012"
    },
    "EmissionValueScenario_EN16258_DEFRA_2014" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EmissionValueScenario"
      }, {
        "type" : "object",
        "properties" : {
          "scenarios" : {
            "type" : "array",
            "items" : {
              "description" : "Define all scenarios that will be calculated",
              "$ref" : "#/definitions/EmissionValueScenarioType_EN16258_DEFRA_2014"
            }
          }
        },
        "description" : "Define the scenario for DEFRA\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.emissions.EmissionValueScenario\\_EN16258\\_DEFRA\\_2014"
      } ],
      "x-discriminator-value" : "EmissionValueScenario_EN16258_DEFRA_2014",
      "x-ms-discriminator-value" : "EmissionValueScenario_EN16258_DEFRA_2014"
    },
    "EmissionValueScenario_Emisia_Copert_Australia_1_2" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EmissionValueScenario"
      }, {
        "type" : "object",
        "properties" : {
          "scenarios" : {
            "type" : "array",
            "items" : {
              "description" : "Define all scenarios that will be calculated",
              "$ref" : "#/definitions/EmissionValueScenarioType_Emisia_Copert_Australia_1_2"
            }
          }
        },
        "description" : "Define the scenario for COPERT Australia 1.2\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.emissions.EmissionValueScenario\\_EMISIA\\_COPERT\\_AUSTRALIA\\_1\\_2"
      } ],
      "x-discriminator-value" : "EmissionValueScenario_EMISIA_COPERT_AUSTRALIA_1_2",
      "x-ms-discriminator-value" : "EmissionValueScenario_EMISIA_COPERT_AUSTRALIA_1_2"
    },
    "EmissionValueScenario_French_CO2_Decree_2011_1336" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EmissionValueScenario"
      }, {
        "type" : "object",
        "properties" : {
          "scenarios" : {
            "type" : "array",
            "items" : {
              "description" : "Define all scenarios that will be calculated",
              "$ref" : "#/definitions/EmissionValueScenarioType_French_CO2_Decree_2011_1336"
            }
          }
        },
        "description" : "Define the scenario for French CO2 decree\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.emissions.EmissionValueScenario\\_FRENCH\\_CO2\\_DECREE\\_2011\\_1336"
      } ],
      "x-discriminator-value" : "EmissionValueScenario_FRENCH_CO2_DECREE_2011_1336",
      "x-ms-discriminator-value" : "EmissionValueScenario_FRENCH_CO2_DECREE_2011_1336"
    },
    "EmissionValueScenario_French_CO2e_Decree_2017_639" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EmissionValueScenario"
      }, {
        "type" : "object",
        "properties" : {
          "scenarios" : {
            "type" : "array",
            "items" : {
              "description" : "Define all scenarios that will be calculated",
              "$ref" : "#/definitions/EmissionValueScenarioType_French_CO2e_Decree_2017_639"
            }
          }
        },
        "description" : "Define the scenario for 2017 French CO2E decree\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.emissions.EmissionValueScenario\\_FRENCH\\_CO2E\\_DECREE\\_2017\\_639"
      } ],
      "x-discriminator-value" : "EmissionValueScenario_FRENCH_CO2E_DECREE_2017_639",
      "x-ms-discriminator-value" : "EmissionValueScenario_FRENCH_CO2E_DECREE_2017_639"
    },
    "EmissionValueScenario_HBEFA_3_2" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EmissionValueScenario"
      }, {
        "type" : "object",
        "properties" : {
          "scenarios" : {
            "type" : "array",
            "items" : {
              "description" : "Define all scenarios that will be calculated",
              "$ref" : "#/definitions/EmissionValueScenarioType_HBEFA_3_2"
            }
          }
        },
        "description" : "Define the scenario for HBEFA 3.2\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.emissions.EmissionValueScenario\\_HBEFA\\_3\\_2"
      } ],
      "x-discriminator-value" : "EmissionValueScenario_HBEFA_3_2",
      "x-ms-discriminator-value" : "EmissionValueScenario_HBEFA_3_2"
    },
    "EmissionValueScenario_HBEFA_4" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EmissionValueScenario"
      }, {
        "type" : "object",
        "properties" : {
          "scenarios" : {
            "type" : "array",
            "items" : {
              "description" : "Define all scenarios that will be calculated",
              "$ref" : "#/definitions/EmissionValueScenarioType_HBEFA_4"
            }
          }
        },
        "description" : "Define the scenario for HBEFA 4\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.emissions.EmissionValueScenario\\_HBEFA\\_4"
      } ],
      "x-discriminator-value" : "EmissionValueScenario_HBEFA_4",
      "x-ms-discriminator-value" : "EmissionValueScenario_HBEFA_4"
    },
    "EmissionValues" : {
      "type" : "object",
      "required" : [ "$type", "standardType" ],
      "discriminator" : "$type",
      "properties" : {
        "standardType" : {
          "description" : "Specifies the type of the emission.",
          "$ref" : "#/definitions/EmissionStandardType"
        },
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "The base type for the emission values\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.emissions.EmissionValues"
    },
    "EmissionValues_Australian_Nga_Factors_2015" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EmissionValues"
      }, {
        "type" : "object",
        "required" : [ "ch4TankToWheel", "co2TankToWheel", "co2eTankToWheel", "co2eWellToWheel", "energyUseTankToWheel", "fuelConsumption", "n2oTankToWheel", "valueScenarioType" ],
        "properties" : {
          "valueScenarioType" : {
            "description" : "Specifies that the emission type is AUSTRALIAN\\_NGA\\_FACTORS\\_2015.",
            "$ref" : "#/definitions/EmissionValueScenarioType_Australian_Nga_Factors_2015"
          },
          "fuelConsumption" : {
            "description" : "The total fuel consumption. This value is 0 for vehicle specific conversion factors.",
            "$ref" : "#/definitions/Kilograms"
          },
          "energyUseTankToWheel" : {
            "description" : "The energy use tank-to-wheel.",
            "$ref" : "#/definitions/Energy"
          },
          "co2eWellToWheel" : {
            "description" : "The CO2e well-to-wheel calculation.",
            "$ref" : "#/definitions/Kilograms"
          },
          "co2eTankToWheel" : {
            "description" : "The CO2e tank-to-wheel.",
            "$ref" : "#/definitions/Kilograms"
          },
          "co2TankToWheel" : {
            "description" : "The CO2 tank-to-wheel.",
            "$ref" : "#/definitions/Kilograms"
          },
          "ch4TankToWheel" : {
            "description" : "The CH4 (methane) tank-to-wheel.",
            "$ref" : "#/definitions/Grams"
          },
          "n2oTankToWheel" : {
            "description" : "The N2O ( Nitrous oxide ) tank-to-wheel.",
            "$ref" : "#/definitions/Grams"
          }
        },
        "description" : "The emission values for Australia NGA\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.emissions.EmissionValues\\_AUSTRALIAN\\_NGA\\_FACTORS\\_2015"
      } ],
      "x-discriminator-value" : "EmissionValues_AUSTRALIAN_NGA_FACTORS_2015",
      "x-ms-discriminator-value" : "EmissionValues_AUSTRALIAN_NGA_FACTORS_2015"
    },
    "EmissionValues_EN16258_2012" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EmissionValues"
      }, {
        "type" : "object",
        "required" : [ "co2eTankToWheel", "co2eWellToWheel", "energyUseTankToWheel", "energyUseWellToWheel", "fuelConsumption", "valueScenarioType" ],
        "properties" : {
          "valueScenarioType" : {
            "description" : "Specifies that the emission type is EN16258\\_2012.",
            "$ref" : "#/definitions/EmissionValueScenarioType_EN16258_2012"
          },
          "fuelConsumption" : {
            "description" : "The total fuel consumption. This value is 0 for vehicle specific conversion factors.",
            "$ref" : "#/definitions/Kilograms"
          },
          "energyUseTankToWheel" : {
            "description" : "The energy use for tank-to-wheel calculation.",
            "$ref" : "#/definitions/Energy"
          },
          "energyUseWellToWheel" : {
            "description" : "The energy use for well-to-wheel calculation.",
            "$ref" : "#/definitions/Energy"
          },
          "co2eTankToWheel" : {
            "description" : "The CO2e tank-to-wheel calculation. The CO2e value is the unit for comparing the radiative forcing of a greenhouse gas to carbon dioxide according to \\[ISO 14064-1:2006\\].",
            "$ref" : "#/definitions/Kilograms"
          },
          "co2eWellToWheel" : {
            "description" : "The CO2e well-to-wheel calculation.",
            "$ref" : "#/definitions/Kilograms"
          }
        },
        "description" : "The emission values for CEN\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.emissions.EmissionValues\\_EN16258\\_2012"
      } ],
      "x-discriminator-value" : "EmissionValues_EN16258_2012",
      "x-ms-discriminator-value" : "EmissionValues_EN16258_2012"
    },
    "EmissionValues_EN16258_DEFRA_2014" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EmissionValues"
      }, {
        "type" : "object",
        "required" : [ "ch4TankToWheel", "co2TankToWheel", "co2eTankToWheel", "co2eWellToWheel", "energyUseTankToWheel", "fuelConsumption", "n2oTankToWheel", "valueScenarioType" ],
        "properties" : {
          "valueScenarioType" : {
            "description" : "Specifies that the emission type is EN16258\\_DEFRA\\_2014.",
            "$ref" : "#/definitions/EmissionValueScenarioType_EN16258_DEFRA_2014"
          },
          "fuelConsumption" : {
            "description" : "The total fuel consumption.",
            "$ref" : "#/definitions/Kilograms"
          },
          "energyUseTankToWheel" : {
            "description" : "The energy use tank-to-wheel.",
            "$ref" : "#/definitions/Energy"
          },
          "co2eTankToWheel" : {
            "description" : "The CO2e tank-to-wheel calculation.",
            "$ref" : "#/definitions/Kilograms"
          },
          "co2eWellToWheel" : {
            "description" : "The CO2e well-to-wheel calculation .",
            "$ref" : "#/definitions/Kilograms"
          },
          "co2TankToWheel" : {
            "description" : "The CO2 tank-to-wheel.",
            "$ref" : "#/definitions/Kilograms"
          },
          "ch4TankToWheel" : {
            "description" : "The CH4 (methane) tank-to-wheel.",
            "$ref" : "#/definitions/Grams"
          },
          "n2oTankToWheel" : {
            "description" : "The N2O (nitrous oxide ) tank-to-wheel.",
            "$ref" : "#/definitions/Grams"
          }
        },
        "description" : "The emission values for DEFRA\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.emissions.EmissionValues\\_EN16258\\_DEFRA\\_2014"
      } ],
      "x-discriminator-value" : "EmissionValues_EN16258_DEFRA_2014",
      "x-ms-discriminator-value" : "EmissionValues_EN16258_DEFRA_2014"
    },
    "EmissionValues_Emisia_Copert_Australia_1_2" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EmissionValues"
      }, {
        "type" : "object",
        "required" : [ "carbonDioxide", "fuelConsumption", "valueScenarioType" ],
        "properties" : {
          "valueScenarioType" : {
            "description" : "Specifies that the emission type is EMISIA\\_COPERT\\_AUSTRALIA\\_1\\_2.",
            "$ref" : "#/definitions/EmissionValueScenarioType_Emisia_Copert_Australia_1_2"
          },
          "carbonDioxide" : {
            "description" : "Carbon dioxide (total value).",
            "$ref" : "#/definitions/Kilograms"
          },
          "fuelConsumption" : {
            "description" : "The total fuel consumption.",
            "$ref" : "#/definitions/Kilograms"
          }
        },
        "description" : "The emission values for COPERT\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.emissions.EmissionValues\\_EMISIA\\_COPERT\\_AUSTRALIA\\_1\\_2"
      } ],
      "x-discriminator-value" : "EmissionValues_EMISIA_COPERT_AUSTRALIA_1_2",
      "x-ms-discriminator-value" : "EmissionValues_EMISIA_COPERT_AUSTRALIA_1_2"
    },
    "EmissionValues_French_CO2_Decree_2011_1336" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EmissionValues"
      }, {
        "type" : "object",
        "required" : [ "co2TankToWheel", "co2WellToWheel", "valueScenarioType" ],
        "properties" : {
          "valueScenarioType" : {
            "description" : "Specifies that the emission type is FRENCH\\_CO2\\_DECREE\\_2011\\_1336.",
            "$ref" : "#/definitions/EmissionValueScenarioType_French_CO2_Decree_2011_1336"
          },
          "co2WellToWheel" : {
            "description" : "The CO2 well-to-wheel.",
            "$ref" : "#/definitions/Kilograms"
          },
          "co2TankToWheel" : {
            "description" : "The CO2 tank-to-wheel.",
            "$ref" : "#/definitions/Kilograms"
          }
        },
        "description" : "The emission values for French CO2 decree\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.emissions.EmissionValues\\_FRENCH\\_CO2\\_DECREE\\_2011\\_1336"
      } ],
      "x-discriminator-value" : "EmissionValues_FRENCH_CO2_DECREE_2011_1336",
      "x-ms-discriminator-value" : "EmissionValues_FRENCH_CO2_DECREE_2011_1336"
    },
    "EmissionValues_French_CO2e_Decree_2017_639" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EmissionValues"
      }, {
        "type" : "object",
        "required" : [ "co2eTankToWheel", "co2eWellToWheel", "valueScenarioType" ],
        "properties" : {
          "valueScenarioType" : {
            "description" : "Specifies that the emission type is FRENCH\\_CO2E\\_DECREE\\_2017\\_639.",
            "$ref" : "#/definitions/EmissionValueScenarioType_French_CO2e_Decree_2017_639"
          },
          "co2eWellToWheel" : {
            "description" : "The CO2e well-to-wheel.",
            "$ref" : "#/definitions/Kilograms"
          },
          "co2eTankToWheel" : {
            "description" : "The CO2e tank-to-wheel.",
            "$ref" : "#/definitions/Kilograms"
          }
        },
        "description" : "The emission values for 2017 French CO2E decree\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.emissions.EmissionValues\\_FRENCH\\_CO2E\\_DECREE\\_2017\\_639"
      } ],
      "x-discriminator-value" : "EmissionValues_FRENCH_CO2E_DECREE_2017_639",
      "x-ms-discriminator-value" : "EmissionValues_FRENCH_CO2E_DECREE_2017_639"
    },
    "EmissionValues_HBEFA_3_2" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EmissionValues"
      }, {
        "type" : "object",
        "required" : [ "ammonia", "benzene", "carbonDioxide", "carbonMonoxide", "fossilCarbonDioxide", "fuelConsumption", "hydrocarbons", "hydrocarbonsExceptMethane", "methane", "nitrogenDioxide", "nitrogenOxides", "nitrousOxide", "numberOfParticles", "particles", "sulphurDioxide", "valueScenarioType" ],
        "properties" : {
          "valueScenarioType" : {
            "description" : "Specifies that the emission type is HBEFA\\_3\\_2.",
            "$ref" : "#/definitions/EmissionValueScenarioType_HBEFA_3_2"
          },
          "fuelConsumption" : {
            "description" : "The total fuel consumption.",
            "$ref" : "#/definitions/Kilograms"
          },
          "hydrocarbons" : {
            "description" : "Hydrocarbons.",
            "$ref" : "#/definitions/Grams"
          },
          "methane" : {
            "description" : "Methane.",
            "$ref" : "#/definitions/Grams"
          },
          "hydrocarbonsExceptMethane" : {
            "description" : "Hydrocarbons except for methane.",
            "$ref" : "#/definitions/Grams"
          },
          "carbonMonoxide" : {
            "description" : "Carbon monoxide.",
            "$ref" : "#/definitions/Grams"
          },
          "carbonDioxide" : {
            "description" : "Carbon dioxide (total value).",
            "$ref" : "#/definitions/Kilograms"
          },
          "fossilCarbonDioxide" : {
            "description" : "Carbon dioxide from fossil sources (this value depends on the country-specific shares of biofuels).",
            "$ref" : "#/definitions/Kilograms"
          },
          "sulphurDioxide" : {
            "description" : "Sulphur dioxide.",
            "$ref" : "#/definitions/Grams"
          },
          "nitrogenOxides" : {
            "description" : "Nitrogen oxides.",
            "$ref" : "#/definitions/Grams"
          },
          "nitrogenDioxide" : {
            "description" : "Nitrogen dioxide.",
            "$ref" : "#/definitions/Grams"
          },
          "nitrousOxide" : {
            "description" : "Nitrous oxide.",
            "$ref" : "#/definitions/Grams"
          },
          "ammonia" : {
            "description" : "Ammonia.",
            "$ref" : "#/definitions/Grams"
          },
          "benzene" : {
            "description" : "Benzene.",
            "$ref" : "#/definitions/Grams"
          },
          "particles" : {
            "description" : "Particular mass.",
            "$ref" : "#/definitions/Grams"
          },
          "numberOfParticles" : {
            "type" : "number",
            "format" : "double",
            "description" : "The number of particles (expressed as double bacause it could be greater than max int)."
          }
        },
        "description" : "The emission values for HBEFA 3.2\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.emissions.EmissionValues\\_HBEFA\\_3\\_2"
      } ],
      "x-discriminator-value" : "EmissionValues_HBEFA_3_2",
      "x-ms-discriminator-value" : "EmissionValues_HBEFA_3_2"
    },
    "EmissionValues_HBEFA_4" : {
      "allOf" : [ {
        "$ref" : "#/definitions/EmissionValues"
      }, {
        "type" : "object",
        "required" : [ "ammonia", "benzene", "carbonDioxide", "carbonMonoxide", "fossilCarbonDioxide", "fuelConsumption", "hydrocarbons", "hydrocarbonsExceptMethane", "methane", "nitrogenDioxide", "nitrogenOxides", "nitrousOxide", "numberOfParticles", "particles", "sulphurDioxide", "valueScenarioType" ],
        "properties" : {
          "valueScenarioType" : {
            "description" : "Specifies that the emission type is HBEFA\\_4.",
            "$ref" : "#/definitions/EmissionValueScenarioType_HBEFA_4"
          },
          "fuelConsumption" : {
            "description" : "The total fuel consumption. Please note that energy consumption for electric/hybrid vehicles is not included. See energyConsumption.",
            "$ref" : "#/definitions/Kilograms"
          },
          "hydrocarbons" : {
            "description" : "Hydrocarbons.",
            "$ref" : "#/definitions/Grams"
          },
          "methane" : {
            "description" : "Methane.",
            "$ref" : "#/definitions/Grams"
          },
          "hydrocarbonsExceptMethane" : {
            "description" : "Hydrocarbons except for methane.",
            "$ref" : "#/definitions/Grams"
          },
          "carbonMonoxide" : {
            "description" : "Carbon monoxide.",
            "$ref" : "#/definitions/Grams"
          },
          "carbonDioxide" : {
            "description" : "Carbon dioxide (total value).",
            "$ref" : "#/definitions/Kilograms"
          },
          "fossilCarbonDioxide" : {
            "description" : "Carbon dioxide from fossil sources (this value depends on the country-specific shares of biofuels).",
            "$ref" : "#/definitions/Kilograms"
          },
          "sulphurDioxide" : {
            "description" : "Sulphur dioxide.",
            "$ref" : "#/definitions/Grams"
          },
          "nitrogenOxides" : {
            "description" : "Nitrogen oxides.",
            "$ref" : "#/definitions/Grams"
          },
          "nitrogenDioxide" : {
            "description" : "Nitrogen dioxide.",
            "$ref" : "#/definitions/Grams"
          },
          "nitrousOxide" : {
            "description" : "Nitrous oxide.",
            "$ref" : "#/definitions/Grams"
          },
          "ammonia" : {
            "description" : "Ammonia.",
            "$ref" : "#/definitions/Grams"
          },
          "benzene" : {
            "description" : "Benzene.",
            "$ref" : "#/definitions/Grams"
          },
          "particles" : {
            "description" : "Particular mass.",
            "$ref" : "#/definitions/Grams"
          },
          "numberOfParticles" : {
            "type" : "number",
            "format" : "double",
            "description" : "The number of particles (expressed as double bacause it could be greater than max int)."
          }
        },
        "description" : "The emission values for HBEFA 4\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.emissions.EmissionValues\\_HBEFA\\_4"
      } ],
      "x-discriminator-value" : "EmissionValues_HBEFA_4",
      "x-ms-discriminator-value" : "EmissionValues_HBEFA_4"
    },
    "Emissions" : {
      "type" : "object",
      "properties" : {
        "values" : {
          "type" : "array",
          "items" : {
            "description" : "The emission value list.",
            "$ref" : "#/definitions/EmissionValues"
          }
        }
      },
      "description" : "Define the emissions\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.emissions.Emissions"
    },
    "EncodedContent" : {
      "type" : "string",
      "description" : "An internal representation of an object, e.g. a route, to be used in subsequent requests. Do not edit or modify this string. Do not store this string permanently.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.EncodedContent"
    },
    "EncodedGeometry" : {
      "type" : "object",
      "properties" : {
        "plain" : {
          "description" : "The plain representation of the geometry using structured objects.",
          "$ref" : "#/definitions/Geometry"
        },
        "wkb" : {
          "type" : "string",
          "format" : "byte",
          "description" : "The WKB (well-known binary) representation of the geometry"
        },
        "wkt" : {
          "type" : "string",
          "description" : "The WKT (well-known text) representation of the geometry."
        },
        "kml" : {
          "description" : "The KML (keyhole markup language) representation of the geometry. Coordinates are always present in WGS84 (EPSG:4326).",
          "$ref" : "#/definitions/KML"
        },
        "geoJSON" : {
          "type" : "string",
          "description" : "The GeoJSON representation of the geometry. Coordinates are always present in WGS84 (EPSG:4326)."
        }
      },
      "description" : "An EncodedGeometry contains one or more representations of the same Geometry which can be selected for each request by service.GeometryOptions.responseGeometryTypes. If z-coordinates have to be represented WKB and WKT are used in an extended form as described by OpenGIS document 99-402r2.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.geometry.EncodedGeometry"
    },
    "EncodedGeometryType" : {
      "type" : "string",
      "description" : "Defines the encoding of response geometries.  \n * `PLAIN` - Response geometries shall be encoded using structured objects.  \n * `WKB` - Response geometries shall be encoded in WKB.  \n * `WKT` - Response geometries shall be encoded in WKT.  \n * `KML` - Response geometries shall be encoded in KML.  \n * `GEOJSON` - Response geometries shall be encoded in GeoJSON.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.geometry.EncodedGeometryType",
      "enum" : [ "PLAIN", "WKB", "WKT", "KML", "GEOJSON" ],
      "x-ms-enum" : {
        "name" : "EncodedGeometryType",
        "modelAsString" : false
      }
    },
    "Energy" : {
      "type" : "number",
      "format" : "double",
      "description" : "MJ Range: 0 ??? value.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.Energy"
    },
    "EnergyConsumption" : {
      "type" : "number",
      "format" : "double",
      "description" : "Defines the vehicle's fuel consumption as \\[l/100km\\] or as \\[kg/100km\\] or its energy consumption as \\[kWh/100km\\]. Range: 0.0 ??? value.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.EnergyConsumption"
    },
    "Engine" : {
      "type" : "object",
      "properties" : {
        "engineType" : {
          "description" : "The engine type. Depending on the engine type only a subset of the other engine parameters are relevant. (1)",
          "$ref" : "#/definitions/EngineType"
        },
        "cylinderCapacity" : {
          "description" : "The cylinder capacity. (2,3)",
          "$ref" : "#/definitions/CylinderCapacity"
        },
        "fuelType" : {
          "description" : "The type of fuel (gasoline, diesel, etc.). (3)",
          "$ref" : "#/definitions/FuelType"
        },
        "bioFuelRatio" : {
          "description" : "The ratio of biofuel to conventional fuel. (3)",
          "$ref" : "#/definitions/Percent"
        },
        "fuelConsumption" : {
          "description" : "The fuel consumption for engine type COMBUSTION and HYBRID \\[l/100km or kg/100km\\]. (1,3)",
          "$ref" : "#/definitions/EnergyConsumption"
        },
        "emissionTechnology" : {
          "description" : "The emission technology (only relevant for some emission classes). (3)",
          "$ref" : "#/definitions/EmissionTechnology"
        },
        "particleFilterInstalled" : {
          "type" : "boolean",
          "description" : "Describes if a particle filter is installed. (2)"
        },
        "particleReductionClass" : {
          "description" : "The particle reduction class (Partikelminderungsklasse) according to \"Anlage XIV zu ?? 48 StVZO\" (German law). (2)",
          "$ref" : "#/definitions/ParticleReductionClass"
        },
        "emissionStandardEU" : {
          "description" : "The emission standard valid in the European Union. (2,3)",
          "$ref" : "#/definitions/EmissionStandardEU"
        },
        "emissionStandardAustralia" : {
          "description" : "The emission standard valid in Australia. (2,3)",
          "$ref" : "#/definitions/EmissionStandardAustralia"
        },
        "lowEmissionZoneTypes" : {
          "description" : "The low-emission zone types of the vehicle as a comma-separated list. The treatment of road segments that are not allowed because of the low-emission zone type is controlled by the penalty value forbiddenLowEmissionZonePenalty. Available types are DE\\_GREEN, DE\\_YELLOW, DE\\_RED for Germany. (1)",
          "$ref" : "#/definitions/CommaSeparatedList"
        }
      },
      "description" : "Defines the engine parameters of the vehicle. These parameters are only relevant if the driveType is MOTOR\\_VEHICLE.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.vehicleprofile.Engine"
    },
    "EngineType" : {
      "type" : "string",
      "description" : "Defines the engine type of the vehicle.  \n * `COMBUSTION` - Combustion. Further distinction by FuelType.  \n * `ELECTRIC` - Electric. Includes energy sources like battery or hydrogen fuel cell.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.vehicleprofile.EngineType",
      "enum" : [ "COMBUSTION", "ELECTRIC" ],
      "x-ms-enum" : {
        "name" : "EngineType",
        "modelAsString" : false
      }
    },
    "Environment" : {
      "type" : "object",
      "required" : [ "cpuArchitecture", "hostName", "numberOfProcessors", "operatingSystem" ],
      "properties" : {
        "operatingSystem" : {
          "type" : "string",
          "description" : "The operating system."
        },
        "cpuArchitecture" : {
          "type" : "string",
          "description" : "The architecture of the cpu."
        },
        "numberOfProcessors" : {
          "description" : "The number of core processors.",
          "$ref" : "#/definitions/PositiveInteger"
        },
        "hostName" : {
          "type" : "string",
          "description" : "The host name."
        }
      },
      "description" : "Information about the server's runtime environment.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.Environment"
    },
    "EstimateByReferenceMatrix" : {
      "allOf" : [ {
        "$ref" : "#/definitions/DistanceMode"
      }, {
        "type" : "object",
        "required" : [ "id" ],
        "properties" : {
          "id" : {
            "type" : "string",
            "description" : "The unique identifier of an existing distance matrix that contains every reference location of the reference location mappings. The ID is generated when the distance matrix is created. It is checked case sensitively."
          },
          "referenceLocationMappings" : {
            "type" : "array",
            "items" : {
              "description" : "Maps each request location to a reference location. If any request location is not part of this mapping or if any reference location is not part of the distance matrix or if the keys of this mapping are not unique, an exception is thrown. A location's route location and its referenceLocation may be equal. Different locations may be mapped to the same reference location. Locations with the same route location may be mapped to different reference locations.",
              "$ref" : "#/definitions/ReferenceLocationMapping"
            }
          }
        },
        "description" : "If not all route locations are part of the existing distance matrix, this distance mode can be used to indicate reference locations for each location. The distance matrix has to contain every reference location that is necessary for tour planning, otherwise an exception is thrown. For example, the distance matrix can be calculated by a createDistanceMatrix request.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.EstimateByReferenceMatrix"
      } ],
      "x-discriminator-value" : "EstimateByReferenceMatrix",
      "x-ms-discriminator-value" : "EstimateByReferenceMatrix"
    },
    "ExactTimeConsiderationAtArrival" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TimeConsideration"
      }, {
        "type" : "object",
        "properties" : {
          "referenceTime" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The reference time at which the routing takes place. This is the arrival time of the route. If no reference time is set, the current UTC time is used."
          },
          "simplifiedRouteCalculation" : {
            "type" : "boolean",
            "description" : "Using this parameter will speed-up the calculation performance but it could lead to non-optimal routes."
          }
        },
        "description" : "This time-consideration scenario evaluates all data which has time restrictions at the exact time at which the data is reached by the vehicle. The reference time is considered as the arrival time of a route. For rendering or any other services this mode is not available. For routing this means that each segment of the route is evaluated at the reference time at which it is reached in contrast to SnapshotTimeConsideration. That means that the given reference time is valid for the last segment. For all previous segments the reference time is equal to the reference time of the subsequent segment plus the travel time for the subsequent segment. Route calculation will be less performant than snapshot and time span scenarios.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.timeconsideration.ExactTimeConsiderationAtArrival"
      } ],
      "x-discriminator-value" : "ExactTimeConsiderationAtArrival",
      "x-ms-discriminator-value" : "ExactTimeConsiderationAtArrival"
    },
    "ExactTimeConsiderationAtStart" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TimeConsideration"
      }, {
        "type" : "object",
        "properties" : {
          "referenceTime" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The reference time at which the routing takes place. This is the start time of the route. If no reference time is set, the current UTC time is used."
          },
          "simplifiedRouteCalculation" : {
            "type" : "boolean",
            "description" : "Using this parameter will speed-up the calculation performance but it could lead to non-optimal routes."
          }
        },
        "description" : "This time-consideration scenario is restricted to xRoute and evaluates all data which has time restrictions at the exact time at which the data is reached by the vehicle. The reference time is considered as the start time of a route. For rendering or any other services this mode is not available. For routing this means that each segment of the route is evaluated at the reference time at which it is reached in contrast to SnapshotTimeConsideration. That means that the given reference time is valid for the first segment. For all subsequent segments the reference time is equal to the reference time of the previous segment plus the travel time for the previous segment. Route calculation will be less performant than snapshot and time-span scenarios.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.timeconsideration.ExactTimeConsiderationAtStart"
      } ],
      "x-discriminator-value" : "ExactTimeConsiderationAtStart",
      "x-ms-discriminator-value" : "ExactTimeConsiderationAtStart"
    },
    "ExchangeRate" : {
      "type" : "object",
      "required" : [ "currency", "rate" ],
      "properties" : {
        "currency" : {
          "description" : "The currency represented by its ISO 4217 code.",
          "$ref" : "#/definitions/CurrencyCode"
        },
        "rate" : {
          "type" : "number",
          "format" : "double",
          "description" : "The exchange rate for this currency relative to the base currency. Multiplying a cost in the base currency with the exchange rate yields the cost in this currency."
        }
      },
      "description" : "Specifies an exchange rate.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.types.ExchangeRate"
    },
    "ExchangeRates" : {
      "type" : "object",
      "required" : [ "baseCurrency" ],
      "properties" : {
        "baseCurrency" : {
          "description" : "The currency represented by its ISO 4217 code all rates are related to.",
          "$ref" : "#/definitions/CurrencyCode"
        },
        "rates" : {
          "type" : "array",
          "items" : {
            "description" : "The exchange rates. The base currency has a rate of 1.0.",
            "$ref" : "#/definitions/ExchangeRate"
          }
        }
      },
      "description" : "Specifies a set of exchange rates. PTV xServer supports 155 ISO 4217 currency codes. Any unknown codes will be ignored as they are not used in the data.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.types.ExchangeRates"
    },
    "ExchangeRatesNotProvidedLimitation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResultLimitation"
      }, {
        "type" : "object",
        "properties" : {
          "usedExchangeRates" : {
            "type" : "array",
            "items" : {
              "description" : "The exchange rates that were used relative to the base currency of the request.",
              "$ref" : "#/definitions/ExchangeRate"
            }
          }
        },
        "description" : "This result limitation indicates that the provided exchange rates do not cover all exchange rates that were required and that in these cases exchange rates that are provided with the map data are used.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.service.ExchangeRatesNotProvidedLimitation"
      } ],
      "x-discriminator-value" : "ExchangeRatesNotProvidedLimitation",
      "x-ms-discriminator-value" : "ExchangeRatesNotProvidedLimitation"
    },
    "ExcludeByNetworkClass" : {
      "type" : "object",
      "properties" : {
        "minimumDistancesFromWaypoint" : {
          "type" : "array",
          "items" : {
            "description" : "An approximate minimum distance from each waypoint for each of the eight network classes. The routing algorithm can exclude a road segment of the corresponding network class if the distance from each waypoint is larger than the given minimum distance. The 0-based index into this array corresponds to the network class segment attribute. Default values: UNBOUNDED,UNBOUNDED,UNBOUNDED,200,20,10,10,10.",
            "$ref" : "#/definitions/MinimumDistancesFromWaypoint"
          }
        }
      },
      "description" : "Defines a heuristic search space reduction by network class. For more information about network classes see the type of the segment attribute network class.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.routingprofile.ExcludeByNetworkClass"
    },
    "ExecutionState" : {
      "type" : "object",
      "required" : [ "currentTime", "vehicleId", "vehiclePosition" ],
      "properties" : {
        "vehicleId" : {
          "type" : "string",
          "description" : "Vehicle ID of the tour that is currently in execution. Note that the stored profile of the ToursInExecutionRequest is used for recomputation."
        },
        "vehiclePosition" : {
          "description" : "Position of the driver and his vehicle in a tour in execution.",
          "$ref" : "#/definitions/VehiclePosition"
        },
        "currentTime" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "Current time of the execution state. It is assumed that the time between lastTimeTheDriverWorked of workLogbookSummary and currentTime counts as break/rest, provided it has the required minimum duration."
        },
        "workLogbookSummary" : {
          "description" : "The summary of a logbook of a driver. If such a summary is missing, it is assumed that the driver is fully rested.",
          "$ref" : "#/definitions/WorkLogbookSummary"
        }
      },
      "description" : "The current state of a tour in execution. The work logbook summary specified at the driver of the given vehicle is overridden.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.ExecutionState"
    },
    "ExistingDistanceMatrix" : {
      "allOf" : [ {
        "$ref" : "#/definitions/DistanceMode"
      }, {
        "type" : "object",
        "required" : [ "id" ],
        "properties" : {
          "id" : {
            "type" : "string",
            "description" : "The unique identifier of the existing distance matrix. The ID is generated when the distance matrix is created. It is checked case sensitively."
          }
        },
        "description" : "Use an existing distance matrix, for example from a createDistanceMatrix request. The distance matrix has to contain every location that is necessary for the tour or cluster planning, otherwise an exception is returned.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.dima.ExistingDistanceMatrix"
      } ],
      "x-discriminator-value" : "ExistingDistanceMatrix",
      "x-ms-discriminator-value" : "ExistingDistanceMatrix"
    },
    "ExistingDistanceMatrixPerVehicle" : {
      "allOf" : [ {
        "$ref" : "#/definitions/DistanceMode"
      }, {
        "type" : "object",
        "description" : "Use an existing distance matrix per vehicle, for example from a createDistanceMatrix request. For distance mode ExistingDistanceMatrixPerVehicle, each vehicle has to have its own distance matrix ID set. If a vehicle does not have any distance matrix ID, an exception is thrown.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.ExistingDistanceMatrixPerVehicle"
      } ],
      "x-discriminator-value" : "ExistingDistanceMatrixPerVehicle",
      "x-ms-discriminator-value" : "ExistingDistanceMatrixPerVehicle"
    },
    "ExtendDistanceMatrixRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/UpdateDistanceMatrixRequest"
      }, {
        "type" : "object",
        "properties" : {
          "startLocations" : {
            "type" : "array",
            "items" : {
              "description" : "Array of start locations to be added to the current distance matrix.",
              "$ref" : "#/definitions/RouteLocation"
            }
          },
          "destinationLocations" : {
            "type" : "array",
            "items" : {
              "description" : "Array of destination locations to be added to the current distance matrix.",
              "$ref" : "#/definitions/RouteLocation"
            }
          }
        },
        "description" : "This request can be used to extend an existing distance matrix by new locations. At least one start location or one destination location must be specified. All new matrix elements introduced by the new locations are calculated by this request. It is allowed that some or even all of the given start and destination locations already exist in the distance matrix, such locations are just ignored and have no effect.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdima.ExtendDistanceMatrixRequest"
      } ],
      "x-discriminator-value" : "ExtendDistanceMatrixRequest",
      "x-ms-discriminator-value" : "ExtendDistanceMatrixRequest"
    },
    "FeatureDescription" : {
      "type" : "object",
      "properties" : {
        "attributes" : {
          "type" : "array",
          "items" : {
            "description" : "The list of attributes.",
            "$ref" : "#/definitions/KeyValuePair"
          }
        },
        "timeDomain" : {
          "type" : "string",
          "description" : "The time domain."
        }
      },
      "description" : "This type represents settings for the description of a new feature.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.FeatureDescription"
    },
    "FeatureLayerAction" : {
      "type" : "object",
      "required" : [ "enabled", "id" ],
      "properties" : {
        "id" : {
          "description" : "The action type ID. The special value \"ALL\" defines every action.",
          "$ref" : "#/definitions/FeatureLayerActionType"
        },
        "enabled" : {
          "type" : "boolean",
          "description" : "Enables or disables the action. If disabled, every subsequent property will be disabled as well."
        }
      },
      "description" : "Defines the state of an action type that is relative to this country, i.e. allows a subsequent action type to be enabled or disabled from its ID.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.featurelayerprofile.FeatureLayerAction"
    },
    "FeatureLayerActionType" : {
      "type" : "string",
      "description" : "Action type that can be triggered by an engine when reading a feature.  \n * `ALL` - Defines every action.  \n * `BONUS_MALUS` - Applies a penalty to a segment, when calculating a route.  \n * `SET_ABSOLUTE_SPEED` - Provides the real speed on a segment.  \n * `SET_TIME_ZONE` - Provides information about the time zone  \n * `SET_FREEFLOW_SPEED` - Provides the freeflow speed on a segment.  \n * `SET_DISPLAY_CLASS` - Provides information on display.  \n * `SET_NETWORK_ATTRIBUTES` - Provides network modifications.  \n * `SET_WAITING_TIME` - Provides the waiting time on a segment.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.featurelayerprofile.FeatureLayerActionType",
      "enum" : [ "ALL", "BONUS_MALUS", "SET_ABSOLUTE_SPEED", "SET_TIME_ZONE", "SET_FREEFLOW_SPEED", "SET_DISPLAY_CLASS", "SET_NETWORK_ATTRIBUTES", "SET_WAITING_TIME" ],
      "x-ms-enum" : {
        "name" : "FeatureLayerActionType",
        "modelAsString" : false
      }
    },
    "FeatureLayerCopyright" : {
      "type" : "object",
      "properties" : {
        "themeId" : {
          "description" : "The identifier of the theme.",
          "$ref" : "#/definitions/ThemeId"
        },
        "copyright" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "description" : "The text fragments for this theme."
          }
        }
      },
      "description" : "This type holds the text fragments of the copyright text for a Feature Layer theme.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.FeatureLayerCopyright"
    },
    "FeatureLayerDescription" : {
      "type" : "object",
      "required" : [ "themeId" ],
      "properties" : {
        "themeId" : {
          "description" : "The ID of the Feature Layer theme.",
          "$ref" : "#/definitions/ThemeId"
        },
        "featureScenario" : {
          "description" : "The optional scenario of the Feature Layer, if it was specified in the request. This scenario is used for displaying the Feature Layer, e.g. in the dashboard, and is also stored in the layer.",
          "$ref" : "#/definitions/FeatureScenario"
        },
        "tenant" : {
          "type" : "string",
          "description" : "The tenant is returned only for administrators."
        },
        "scope" : {
          "description" : "The user defined scope.",
          "$ref" : "#/definitions/ScopeName"
        },
        "createdAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "Indicates the date the Feature Layer was created."
        },
        "lastUsedAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "Indicates the date the Feature Layer was used the last time."
        },
        "size" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Indicates the size of the Feature Layer on the hard drive in bytes."
        },
        "providerInformation" : {
          "type" : "string",
          "description" : "Display information on the data providers of the map. This string consists of a comma-separated list of pairs of data provider name and provider version number, e.g. TomTom 2016.12. The string format can be changed at any time, it is for display purposes only."
        }
      },
      "description" : "This type represents meta data about a Feature Layer.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.FeatureLayerDescription"
    },
    "FeatureLayerFeature" : {
      "type" : "object",
      "properties" : {
        "segmentIds" : {
          "type" : "array",
          "items" : {
            "description" : "The segments.",
            "$ref" : "#/definitions/SegmentId"
          }
        },
        "direction" : {
          "description" : "The direction in which to use the segment.",
          "$ref" : "#/definitions/SegmentDirection"
        },
        "descriptions" : {
          "type" : "array",
          "items" : {
            "description" : "The descriptions.",
            "$ref" : "#/definitions/FeatureDescription"
          }
        }
      },
      "description" : "This type represents settings for the creation of a new Feature Layer.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.Feature"
    },
    "FeatureLayerInformation" : {
      "type" : "object",
      "properties" : {
        "featureLayerDescription" : {
          "description" : "Meta data that describes the Feature Layer.",
          "$ref" : "#/definitions/FeatureLayerDescription"
        },
        "listException" : {
          "description" : "Exception in case of an error querying a Feature Layer content ID.",
          "$ref" : "#/definitions/SuppressedXServerException"
        }
      },
      "description" : "The result that lists a description of a single Feature Layer or the exception that was returned querying the Feature Layer ID.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.FeatureLayerInformation"
    },
    "FeatureLayerMatchLimitation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResultLimitation"
      }, {
        "type" : "object",
        "required" : [ "themeId" ],
        "properties" : {
          "themeId" : {
            "description" : "ID of the Feature Layer theme which does not fit the map.",
            "$ref" : "#/definitions/ThemeId"
          },
          "countries" : {
            "type" : "array",
            "items" : {
              "description" : "Codes of countries whose Feature Layers of the theme referred to by the parameter above are not fitting the map.",
              "$ref" : "#/definitions/CountryCode"
            }
          }
        },
        "description" : "This result limitation indicates that one or more Feature Layers corresponding to a Feature Layer theme do not fit the currently used map. Such a situation could reduce the quality of the result. The user is requested to update the Feature Layer data for this theme or the map so that both have the same version. If in doubt, contact your PTV representative for help.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.service.FeatureLayerMatchLimitation"
      } ],
      "x-discriminator-value" : "FeatureLayerMatchLimitation",
      "x-ms-discriminator-value" : "FeatureLayerMatchLimitation"
    },
    "FeatureLayerNotAvailableLimitation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResultLimitation"
      }, {
        "type" : "object",
        "required" : [ "themeId" ],
        "properties" : {
          "themeId" : {
            "description" : "ID of the Feature Layer theme which does not exist.",
            "$ref" : "#/definitions/ThemeId"
          }
        },
        "description" : "This result limitation indicates that a certain Feature Layer is not available although content updates are enabled for it. This may happen right after starting PTV xServer or restarting a module when a request is processed before the content updates have finished, or when there is no data available for this Feature Layer.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.service.FeatureLayerNotAvailableLimitation"
      } ],
      "x-discriminator-value" : "FeatureLayerNotAvailableLimitation",
      "x-ms-discriminator-value" : "FeatureLayerNotAvailableLimitation"
    },
    "FeatureLayerProfile" : {
      "type" : "object",
      "properties" : {
        "parameters" : {
          "type" : "array",
          "items" : {
            "description" : "Defines the additional generic parameters. Normally it is not necessary to specify parameters here. A feature layer theme may be connected to such a generic parameter if there is no appropriate explicit profile parameter available. If in doubt, contact your PTV representative for help.",
            "$ref" : "#/definitions/KeyValuePair"
          }
        },
        "themes" : {
          "type" : "array",
          "items" : {
            "description" : "Defines the parameters of a specific theme. Countries, rules, properties and action types can be enabled or disabled from specified themes and/or countries.",
            "$ref" : "#/definitions/Theme"
          }
        }
      },
      "description" : "Defines Feature Layer parameters.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.featurelayerprofile.FeatureLayerProfile"
    },
    "FeatureLayerProperty" : {
      "type" : "object",
      "required" : [ "enabled", "id" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "The property ID. The special value \"ALL\" defines every property."
        },
        "enabled" : {
          "type" : "boolean",
          "description" : "Enables or disables the property. If disabled, the rules that possess the property will be disabled as well."
        }
      },
      "description" : "Defines the state of a property that is relative to this country, i.e. allows a subsequent property to be enabled or disabled from its ID.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.featurelayerprofile.FeatureLayerProperty"
    },
    "FeatureLayerResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "properties" : {
          "binaryFeatureLayer" : {
            "description" : "The binary representation of the Feature Layer, returned as an encoded string.",
            "$ref" : "#/definitions/EncodedContent"
          },
          "featureLayerDescription" : {
            "description" : "Meta information that describes the current Feature Layer content.",
            "$ref" : "#/definitions/FeatureLayerDescription"
          }
        },
        "description" : "This type represents the response when a Feature Layer is created.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.FeatureLayerResponse"
      } ],
      "x-discriminator-value" : "FeatureLayerResponse",
      "x-ms-discriminator-value" : "FeatureLayerResponse"
    },
    "FeatureLayerRule" : {
      "type" : "object",
      "required" : [ "enabled", "id" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "The rule ID. The special value \"ALL\" defines every rule."
        },
        "enabled" : {
          "type" : "boolean",
          "description" : "Enables or disables the rule. If disabled, every subsequent rule that is relative to this rule and every subsequent property will be disabled as well."
        }
      },
      "description" : "Defines the state of a rule that is relative to this country, i.e. allows a subsequent rule to be enabled or disabled from its ID.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.featurelayerprofile.FeatureLayerRule"
    },
    "FeatureLayerTheme" : {
      "type" : "object",
      "properties" : {
        "themeId" : {
          "description" : "The identifier of the theme.",
          "$ref" : "#/definitions/ThemeId"
        }
      },
      "description" : "Represents a single Feature Layer theme along with its properties. Country or subdivision specific properties can be found in RegionFeatureLayerTheme.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.FeatureLayerTheme"
    },
    "FeatureLayerThemeStyle" : {
      "type" : "object",
      "required" : [ "id" ],
      "properties" : {
        "defaultIcons" : {
          "type" : "array",
          "items" : {
            "description" : "Defines the default icon which is drawn if no other icon is specified through a style. It is possible to define different icons for different zoom levels.",
            "$ref" : "#/definitions/IconStyle"
          }
        },
        "groupIcons" : {
          "type" : "array",
          "items" : {
            "description" : "Defines how to render the group icon. The group icon is used if multiple icons are concentrated into a single icon due to lack of rendering space. It is possible to define different icons for different zoom levels.",
            "$ref" : "#/definitions/IconStyle"
          }
        },
        "labelingConflictResolution" : {
          "description" : "Defines the behavior when labels or icons overlap. In order to avoid overlapping with labels already drawn they can be displaced so that they do not overlap, anymore. This means that labels already drawn will not be repositioned but stay where they are.",
          "$ref" : "#/definitions/LabelingConflictResolution"
        },
        "timeDependencyStyle" : {
          "description" : "Defines how to modify the style of restricted features, e.g. time-dependent features or those not relevant by time.",
          "$ref" : "#/definitions/TimeDependencyStyle"
        },
        "styles" : {
          "type" : "array",
          "items" : {
            "description" : "Defines the styles for the objects of the current Feature Layer theme.",
            "$ref" : "#/definitions/RenderingStyle"
          }
        },
        "id" : {
          "description" : "The ID of the Feature Layer theme.",
          "$ref" : "#/definitions/ThemeId"
        }
      },
      "description" : "Defines styles for data of a Feature Layer theme in the corresponding set of countries.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.renderingprofile.FeatureLayerThemeStyle"
    },
    "FeatureLayersListResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "properties" : {
          "featureLayerInformation" : {
            "type" : "array",
            "items" : {
              "description" : "The result list containing information about each Feature Layer. If specific Feature Layer IDs have been requested there is one entry in the list for each requested ID in the same order.",
              "$ref" : "#/definitions/FeatureLayerInformation"
            }
          }
        },
        "description" : "This type represents a list of meta information on Feature Layers.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.FeatureLayersListResponse"
      } ],
      "x-discriminator-value" : "FeatureLayersListResponse",
      "x-ms-discriminator-value" : "FeatureLayersListResponse"
    },
    "FeatureNotAvailableLimitation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResultLimitation"
      }, {
        "type" : "object",
        "required" : [ "feature" ],
        "properties" : {
          "feature" : {
            "type" : "string",
            "description" : "Name of the requested feature"
          }
        },
        "description" : "This result limitation indicates that a certain feature is not available. For example it could occur in a situation where the API contains a list of entities but the business logic can only treat a single entity. In general it occurs when the API foresees a situation which is not recognized in the business logic yet but still allows a result to be created.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.service.FeatureNotAvailableLimitation"
      } ],
      "x-discriminator-value" : "FeatureNotAvailableLimitation",
      "x-ms-discriminator-value" : "FeatureNotAvailableLimitation"
    },
    "FeatureNotLicensedLimitation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResultLimitation"
      }, {
        "type" : "object",
        "required" : [ "key" ],
        "properties" : {
          "key" : {
            "type" : "string",
            "description" : "The name of the license key"
          }
        },
        "description" : "This result limitation indicates that some optional data content has not been used because it is not licensed. For example, if the routing type is routing.RoutingType.HIGH\\_PERFORMANCE\\_ROUTING\\_WITH\\_FALLBACK\\_CONVENTIONAL and high-performance routing is not licensed, a conventional routing is done and a result limitation is generated. Normally, if the data content is not optional, a SetupFault is returned.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.service.FeatureNotLicensedLimitation"
      } ],
      "x-discriminator-value" : "FeatureNotLicensedLimitation",
      "x-ms-discriminator-value" : "FeatureNotLicensedLimitation"
    },
    "FeatureResultProperty" : {
      "type" : "object",
      "required" : [ "enabled", "id" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "Defines the property ID. The special value \"ALL\" defines every property."
        },
        "enabled" : {
          "type" : "boolean",
          "description" : "Defines if the property has to be included or excluded in the list of features of a response."
        }
      },
      "description" : "Defines the contents of the features returned by the xMap and xRoute services. By default all properties are included.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.featurelayerprofile.FeatureResultProperty"
    },
    "FeatureScenario" : {
      "type" : "string",
      "description" : "The name of the Feature Layer scenario. The special values \"\\*\" or \"ALL\" are forbidden. Pattern: \\[^\\\\\\*\\]+.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.FeatureScenario"
    },
    "FieldWorker" : {
      "type" : "object",
      "required" : [ "id", "location" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "The unique identifier of this field worker."
        },
        "location" : {
          "description" : "The geographical position of this field worker.",
          "$ref" : "#/definitions/RouteLocation"
        }
      },
      "description" : "Represents the field worker for the visit planning use case.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.FieldWorker"
    },
    "FileName" : {
      "type" : "string",
      "description" : "Relative file path\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.FileName"
    },
    "FillStyle" : {
      "type" : "object",
      "properties" : {
        "hatch" : {
          "description" : "Defines how to render polygons with a hatch pattern. If you use the Leaflet toolkit together with a hatch configuration for Feature Layers, it works only with image standard sizes like 128x128, 256 x 256, 512x512 or 1024x1024. If you use other images sizes you will get a hatch displacement at the image border.",
          "$ref" : "#/definitions/HatchStyle"
        },
        "visible" : {
          "type" : "boolean",
          "description" : "Controls the visibility of the fill."
        },
        "color" : {
          "description" : "The RGB color of the fill of the geometry.",
          "$ref" : "#/definitions/Color"
        },
        "opacity" : {
          "description" : "The opacity of the fill of the geometry in \\[%\\]. 100 represents opaque, 0 represents completely transparent.",
          "$ref" : "#/definitions/Percent"
        }
      },
      "description" : "Defines how to fill the polygons.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.renderingprofile.FillStyle"
    },
    "FindChangeToursProposalsRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "required" : [ "proposalsQuery" ],
        "properties" : {
          "proposalsQuery" : {
            "description" : "A query that defines which ChangeToursActions to propose.",
            "$ref" : "#/definitions/ChangeToursProposalsQuery"
          },
          "proposalsOptions" : {
            "description" : "Contains options for the find change tours proposals use case.",
            "$ref" : "#/definitions/ChangeToursProposalsOptions"
          }
        },
        "description" : "The request object for the service method proposeChangeToursActions.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.FindChangeToursProposalsRequest"
      } ],
      "x-discriminator-value" : "FindChangeToursProposalsRequest",
      "x-ms-discriminator-value" : "FindChangeToursProposalsRequest"
    },
    "Fixation" : {
      "type" : "object",
      "required" : [ "fixationType", "id" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "ID of the object that should be fixed. The type of object and the characterization of the fixation depends on the fixation type."
        },
        "fixationType" : {
          "description" : "Different kinds of fixations.",
          "$ref" : "#/definitions/FixationType"
        }
      },
      "description" : "Different kinds of fixations that are considered during planning as additional restrictions.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.Fixation"
    },
    "FixationType" : {
      "type" : "string",
      "description" : "Different kinds of fixations.  \n * `VEHICLE_ORDERS` - All orders that are served by a vehicle must remain served by this vehicle. Additional orders can be assigned to this vehicle. In this case, the ID of the fixation corresponds to the vehicleId.  \n * `TRIP_TO_VEHICLE` - The trip is part of the input plan and must remain \"as is\". It also must remain served by the same vehicle as in the input plan. In this case, the ID of the fixation corresponds to the trip ID.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.xtour.FixationType",
      "enum" : [ "VEHICLE_ORDERS", "TRIP_TO_VEHICLE" ],
      "x-ms-enum" : {
        "name" : "FixationType",
        "modelAsString" : false
      }
    },
    "Fleet" : {
      "type" : "object",
      "properties" : {
        "vehicles" : {
          "type" : "array",
          "items" : {
            "description" : "A list of vehicles that can be used to transport goods or perform visits.",
            "$ref" : "#/definitions/Vehicle"
          }
        },
        "drivers" : {
          "type" : "array",
          "items" : {
            "description" : "A list of drivers. Vehicles without associated driver have no restrictions concerning driver operating intervals. All tour restrictions must be fulfilled by both vehicles with and without associated driver.",
            "$ref" : "#/definitions/Driver"
          }
        }
      },
      "description" : "A fleet consisting of vehicles that are available to transport goods or perform visits.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.Fleet"
    },
    "FuelType" : {
      "type" : "string",
      "description" : "Defines the fuel type of the vehicle.  \n * `GASOLINE` - Gasoline (also known as petrol or benzine).  \n * `DIESEL` - Diesel.  \n * `COMPRESSED_NATURAL_GAS` - Compressed natural gas.  \n * `LIQUEFIED_PETROLEUM_GAS` - Liquefied petroleum gas.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.vehicleprofile.FuelType",
      "enum" : [ "GASOLINE", "DIESEL", "COMPRESSED_NATURAL_GAS", "LIQUEFIED_PETROLEUM_GAS" ],
      "x-ms-enum" : {
        "name" : "FuelType",
        "modelAsString" : false
      }
    },
    "GDFTimeDomain" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Interval"
      }, {
        "type" : "object",
        "required" : [ "timeDomain" ],
        "properties" : {
          "timeDomain" : {
            "type" : "string",
            "description" : "Intervals in GDF time domain format. The string must be a valid time domain such as \\[(Starting Date)\\{Time duration\\}\\], i.e. \\[(y2016M2h10)\\{h2\\}\\] is interpreted as intervals on each day of february 2016 from 10am until 12am. For more details please have a look at the technical concept GDF time domains."
          }
        },
        "description" : "One or more segments of time specified by a GDF time domain string.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.time.GDFTimeDomain"
      } ],
      "x-discriminator-value" : "GDFTimeDomain",
      "x-ms-discriminator-value" : "GDFTimeDomain"
    },
    "GeocodingLocation" : {
      "type" : "object",
      "required" : [ "address", "referenceCoordinate" ],
      "properties" : {
        "referenceCoordinate" : {
          "description" : "The actual position of the object itself, such as the rooftop of a building, the center of a street, or the reference point of a city.\r\n\r\nIn rare cases (when missing in the map data) this may not be available for a building address. In such a case, there will be a roadAccessCoordinate.\r\n\r\nPlease refer to the documentation of waypoints for more information on how best to use this position in a route calculation.",
          "$ref" : "#/definitions/Coordinate"
        },
        "roadAccessCoordinate" : {
          "description" : "A position on or very close to a road network segment that marks the entry to the object. Available only for objects which represent buildings with a complete address and only if present in the data.\r\n\r\nThe road from which the object can be accessed is not necessarily the road which is closest to the object. When using the location as the input to a route calculation, pass the roadAccessCoordinate to the RouteLocation for best results.\r\n\r\nPlease refer to the documentation of waypoints for more information on how to use this position best in a route calculation.",
          "$ref" : "#/definitions/Coordinate"
        },
        "address" : {
          "description" : "The address of the object.",
          "$ref" : "#/definitions/Address"
        },
        "formattedAddress" : {
          "type" : "string",
          "description" : "A single string representing the address, typically consisting of the street, house number, postal code, city, and country. The precise format may differ based on what is appropriate for the address."
        }
      },
      "description" : "Represents a geographical object in terms of its position and its address.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xlocate.Location"
    },
    "GeographicRestrictions" : {
      "type" : "object",
      "properties" : {
        "searchSpaceBounds" : {
          "description" : "The area to which the search space should be restricted.",
          "$ref" : "#/definitions/SearchSpaceBounds"
        },
        "allowedCountries" : {
          "type" : "array",
          "items" : {
            "description" : "Specifies a list of country codes that are allowed for a routing. Unsupported country codes, i.e. codes representing a country not contained in the configured map or codes not assigned to any country, are ignored. The response will contain a CountryIgnoredLimitation. Unsupported subdivision codes for supported countries will be ignored, instead the whole country will be allowed. The response will contain a SubdivisionFallbackLimitation. Without any country code defined in this parameter, the list of allowed countries is set by default to the list of those contained in the configured map. When this list is not empty but contains only unsupported codes, route calculation will fail.\r\n\r\nThe effective list of countries authorized in the routing is computed as following:\r\n\r\n *  First, the countries of the GeographicRestrictions.allowedCountries list matching the ones in the map are added.\r\n *  Then, optionally, whether the GeographicRestrictions.prohibitedCountries list is not empty, the countries of the GeographicRestrictions.prohibitedCountries list matching the ones in the map are removed.",
            "$ref" : "#/definitions/CountryCode"
          }
        },
        "prohibitedCountries" : {
          "type" : "array",
          "items" : {
            "description" : "Specifies a list of country codes that are prohibited for a routing. Unsupported country codes will be ignored, supported country codes with unsupported subdivision codes will also be ignored. The response will contain a CountryIgnoredLimitation. For further explanation see the definition of GeographicRestrictions.allowedCountries.",
            "$ref" : "#/definitions/CountryCode"
          }
        },
        "prohibitedSegmentsByIntersectingPolylines" : {
          "type" : "array",
          "items" : {
            "description" : "Specifies a list of polylines from which the segments are extracted by intersection and then prohibited for the route calculation. Only geometries of type geometry.Polyline are allowed. In contrast to the other geographic restrictions the prohibited segments specified here can be violated if the violations are enabled in the routing profile. Such violations are reported also when a xroute.PathWaypoint is used.  \r\n**Limitation:** If the intersection of one polyline with the road network yields more than 5000 segments, the request is rejected with an exception.",
            "$ref" : "#/definitions/EncodedGeometry"
          }
        }
      },
      "description" : "Defines the geographic restrictions to be applied for route calculation. The effective routable area is determined by the intersection of the effective country list and the search space bounds.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.routing.GeographicRestrictions"
    },
    "GeographicRestrictionsIgnoredLimitation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResultLimitation"
      }, {
        "type" : "object",
        "required" : [ "ignoredParameter", "ignoredValue", "relatedParameter" ],
        "properties" : {
          "ignoredParameter" : {
            "type" : "string",
            "description" : "Identifies the geographic restrictions parameter (as an xPath path expression) which was ignored."
          },
          "relatedParameter" : {
            "type" : "string",
            "description" : "Identifies the parameter (as an xPath path expression) which caused the geographic restrictions parameter to be passed over."
          },
          "ignoredValue" : {
            "type" : "string",
            "description" : "The ignored geographic restrictions parameter value."
          },
          "relatedValue" : {
            "type" : "string",
            "description" : "The value which caused the geographic restrictions parameter to be passed over. Not present if the conflict is independent of the value."
          }
        },
        "description" : "This result limitation indicates that a GeographicRestrictions parameter was ignored due to an other parameter.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.routing.GeographicRestrictionsIgnoredLimitation"
      } ],
      "x-discriminator-value" : "GeographicRestrictionsIgnoredLimitation",
      "x-ms-discriminator-value" : "GeographicRestrictionsIgnoredLimitation"
    },
    "Geometry" : {
      "type" : "object",
      "required" : [ "$type" ],
      "discriminator" : "$type",
      "properties" : {
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "Geometry objects consist of (multi-dimensional) arrays of coordinate points\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.geometry.Geometry"
    },
    "GeometryCollection" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Geometry"
      }, {
        "type" : "object",
        "properties" : {
          "geometries" : {
            "type" : "array",
            "items" : {
              "description" : "a geometry collection consists of a set of geometries",
              "$ref" : "#/definitions/Geometry"
            }
          }
        },
        "description" : "A GeometryCollection is a geometry that is a collection of one or more geometries. All the elements in a GeometryCollection must be in the same spatial reference. This is also the reference for the GeometryCollection. GeometryCollection places no other constraints on its elements.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.geometry.GeometryCollection"
      } ],
      "x-discriminator-value" : "GeometryCollection",
      "x-ms-discriminator-value" : "GeometryCollection"
    },
    "GeometryOptions" : {
      "type" : "object",
      "properties" : {
        "responseGeometryTypes" : {
          "type" : "array",
          "items" : {
            "description" : "the target encodings of geometries",
            "$ref" : "#/definitions/EncodedGeometryType"
          }
        }
      },
      "description" : "Options for returned geometries.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.service.GeometryOptions"
    },
    "GeometryStyle" : {
      "type" : "object",
      "properties" : {
        "renderLevel" : {
          "description" : "Defines the level on which the geometry is rendered, i.e. on top or below what other objects.",
          "$ref" : "#/definitions/RenderLevel"
        },
        "stroke" : {
          "description" : "Defines how to render the stroke of the Geometry.",
          "$ref" : "#/definitions/StrokeStyle"
        },
        "polygon" : {
          "description" : "Defines how to render the polygons.",
          "$ref" : "#/definitions/PolygonStyle"
        },
        "displayRange" : {
          "description" : "The zoom range in which the specified style should be applied.",
          "$ref" : "#/definitions/ZoomLevelRange"
        }
      },
      "description" : "Defines how to render geometries.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.renderingprofile.GeometryStyle"
    },
    "GetDistanceMatrixByLocationsRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/GetDistanceMatrixRequest"
      }, {
        "type" : "object",
        "properties" : {
          "startLocations" : {
            "type" : "array",
            "items" : {
              "description" : "Specifies the start locations to be retrieved from the matrix.",
              "$ref" : "#/definitions/RouteLocation"
            }
          },
          "destinationLocations" : {
            "type" : "array",
            "items" : {
              "description" : "Specifies the destination locations to be retrieved from the matrix.",
              "$ref" : "#/definitions/RouteLocation"
            }
          }
        },
        "description" : "With this request, it is possible to query slices of matrices. If m start locations and n destination locations are requested, the first n elements of the array correspond to the relations between the first start location given in the request and all n destination locations in the same order as the destination locations are given in the request. The next n elements of the array correspond to the relations between the second start location given in the request and all n destination locations, and so on. Note that the maximum number of relations (i.e., the number of start locations times the number of destination locations) is internally limited to 250000 but it can be configured in the `xserver.conf` file (see here)\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdima.GetDistanceMatrixByLocationsRequest"
      } ],
      "x-discriminator-value" : "GetDistanceMatrixByLocationsRequest",
      "x-ms-discriminator-value" : "GetDistanceMatrixByLocationsRequest"
    },
    "GetDistanceMatrixByRelationsRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/GetDistanceMatrixRequest"
      }, {
        "type" : "object",
        "properties" : {
          "relations" : {
            "type" : "array",
            "items" : {
              "description" : "Specifies for which relations the distance matrix data should be returned.",
              "$ref" : "#/definitions/Relation"
            }
          }
        },
        "description" : "This request can be used to query specific relations. The output order in the response corresponds to the input order of the relations. Note that the maximum number of relations that can be retrieved is internally limited to 250000 but it can be configured in the `xserver.conf` file (see here)\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdima.GetDistanceMatrixByRelationsRequest"
      } ],
      "x-discriminator-value" : "GetDistanceMatrixByRelationsRequest",
      "x-ms-discriminator-value" : "GetDistanceMatrixByRelationsRequest"
    },
    "GetDistanceMatrixRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "required" : [ "id" ],
        "properties" : {
          "id" : {
            "type" : "string",
            "description" : "The ID of the distance matrix to be used."
          },
          "resultFields" : {
            "description" : "Specifies the result fields available in the response.",
            "$ref" : "#/definitions/DistanceMatrixResultFields"
          },
          "contentsOptions" : {
            "description" : "Specifies how to return the distance matrix contents.",
            "$ref" : "#/definitions/DistanceMatrixContentsOptions"
          }
        },
        "description" : "The service method getDistanceMatrix accommodates several use-cases. This abstract type is the common denominator of the corresponding request objects.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdima.GetDistanceMatrixRequest"
      } ],
      "x-discriminator-value" : "GetDistanceMatrixRequest",
      "x-ms-discriminator-value" : "GetDistanceMatrixRequest"
    },
    "Grams" : {
      "type" : "number",
      "format" : "double",
      "description" : "Defines the type for weights in \\[g\\]. Range: 0.0 ??? value.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.Grams"
    },
    "HatchStyle" : {
      "type" : "object",
      "properties" : {
        "color" : {
          "description" : "The RGB color of the hatch.",
          "$ref" : "#/definitions/Color"
        },
        "type" : {
          "description" : "The hatch type.",
          "$ref" : "#/definitions/HatchType"
        }
      },
      "description" : "Defines how to render polygons with a hatch pattern. If you use the Leaflet toolkit together with a hatch configuration for Feature Layers, it works only with image standard sizes like 128x128, 256 x 256, 512x512 or 1024x1024. If you use other images sizes you will get a hatch displacement at the image border.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.renderingprofile.HatchStyle"
    },
    "HatchType" : {
      "type" : "string",
      "description" : "A type of hatch to fill a geometry.  \n * `LEFT_INCLINED` - Hatch pattern inclined from top left to bottom right.  \n * `RIGHT_INCLINED` - Hatch pattern inclined from top right to bottom left.  \n * `VERTICAL` - Vertical hatch pattern.  \n * `HORIZONTAL` - Horizontal hatch pattern.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.renderingprofile.HatchType",
      "enum" : [ "LEFT_INCLINED", "RIGHT_INCLINED", "VERTICAL", "HORIZONTAL" ],
      "x-ms-enum" : {
        "name" : "HatchType",
        "modelAsString" : false
      }
    },
    "HeadingIgnoredLimitation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResultLimitation"
      }, {
        "type" : "object",
        "description" : "This result limitation indicates that PositionEnRoute linking to the road network has ignored specified heading. This happens if it is not possible to find a road, near the vehicle, that satisfy the defined heading.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.HeadingIgnoredLimitation"
      } ],
      "x-discriminator-value" : "HeadingIgnoredLimitation",
      "x-ms-discriminator-value" : "HeadingIgnoredLimitation"
    },
    "HeadingToleranceIgnoredLimitation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResultLimitation"
      }, {
        "type" : "object",
        "description" : "This result limitation indicates that PositionEnRoute linking to the road network has ignored specified heading tolerance. This happens if no heading has been provided.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.HeadingToleranceIgnoredLimitation"
      } ],
      "x-discriminator-value" : "HeadingToleranceIgnoredLimitation",
      "x-ms-discriminator-value" : "HeadingToleranceIgnoredLimitation"
    },
    "HighPerformanceRoutingNetworkAlreadyAvailableLimitation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResultLimitation"
      }, {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "string",
            "description" : "The ID of the high-performance routing network if it has been created by the user. An unitialized ID indicates that the user has requested a high-performance routing network which has been delivered with the map."
          }
        },
        "description" : "This result limitation indicates that a high-performance routing network already exists and hasn't been created as a result of the request.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.HighPerformanceRoutingNetworkAlreadyAvailableLimitation"
      } ],
      "x-discriminator-value" : "HighPerformanceRoutingNetworkAlreadyAvailableLimitation",
      "x-ms-discriminator-value" : "HighPerformanceRoutingNetworkAlreadyAvailableLimitation"
    },
    "HighPerformanceRoutingNetworkDescription" : {
      "type" : "object",
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "The ID of the network."
        },
        "label" : {
          "description" : "The optional label of the network, if it was specified in the request. This label is only used for displaying the network, e.g. in the dashboard, and is not considered in any other way.",
          "$ref" : "#/definitions/UserDefinedName"
        },
        "highPerformanceRoutingNetworkOptions" : {
          "description" : "The options used for this high-performance routing network.\r\n\r\nWarning: Options are removed from the response if they cannot be represented using the requested API version. This situation might occur if a more recent API version was used for the creation of the high-performance routing network than for this list request. In general, it is not recommended to mix different API versions.",
          "$ref" : "#/definitions/HighPerformanceRoutingNetworkOptions"
        },
        "profile" : {
          "description" : "Contains only the relevant profile parameters.\r\n\r\nWarning: Profile elements are removed from the response if they cannot be represented using the requested API version. This restriction also applies to elements of the stored profile used for calculation of this high-performance routing network. If the returned profile should be used as a request profile in a subsequent request (e.g. for creating another high-performance routing network or for a route calculation), it is recommended to specify the same stored profile as in the original create request. In general, it is not recommended to mix different API versions.",
          "$ref" : "#/definitions/RequestProfile"
        },
        "tenant" : {
          "type" : "string",
          "description" : "The tenant is returned only for administrators and only for user-created networks."
        },
        "scope" : {
          "description" : "The user defined scope. It is returned only for user-created networks.",
          "$ref" : "#/definitions/ScopeName"
        },
        "lastUsedAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "Indicates the date the network was used the last time."
        },
        "size" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Indicates the size of the network on the hard drive in bytes."
        }
      },
      "description" : "This type represents meta data about a high-performance routing network.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.HighPerformanceRoutingNetworkDescription"
    },
    "HighPerformanceRoutingNetworkInformation" : {
      "type" : "object",
      "properties" : {
        "highPerformanceRoutingNetworkDescription" : {
          "description" : "Meta data that describes the current network.",
          "$ref" : "#/definitions/HighPerformanceRoutingNetworkDescription"
        },
        "listException" : {
          "description" : "Exception in case of an error querying a network ID.",
          "$ref" : "#/definitions/SuppressedXServerException"
        }
      },
      "description" : "The result that lists a description of a single high-performance routing network or the exception that was returned querying the network.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.HighPerformanceRoutingNetworkInformation"
    },
    "HighPerformanceRoutingNetworkOptions" : {
      "type" : "object",
      "properties" : {
        "timeConsideration" : {
          "description" : "Set this parameter if time dependent features should be considered for the high-performance routing network calculation. The different scenarios of time consideration are explained in more detail in the technical concept about time consideration. Please note that the time consideration values ExactTimeConsiderationAtStart and ExactTimeConsiderationAtArrival are not available and if used an exception will be returned.",
          "$ref" : "#/definitions/TimeConsideration"
        },
        "contentSnapshotId" : {
          "type" : "string",
          "description" : "Specifies the content snapshot to use. If no snapshot ID is set, the most recent content is used."
        },
        "geographicRestrictions" : {
          "description" : "Specifies geographic restrictions that are considered during the high-performance routing network calculation.",
          "$ref" : "#/definitions/GeographicRestrictions"
        }
      },
      "description" : "This type represents additional options that are relevant for selection of a high-performance routing network besides the profile.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.HighPerformanceRoutingNetworkOptions"
    },
    "HighPerformanceRoutingNetworkProgress" : {
      "allOf" : [ {
        "$ref" : "#/definitions/JobProgress"
      }, {
        "type" : "object",
        "required" : [ "status" ],
        "properties" : {
          "status" : {
            "description" : "The action currently being performed.",
            "$ref" : "#/definitions/HighPerformanceRoutingNetworkProgressStatus"
          },
          "progress" : {
            "description" : "The progress of the actions PREPROCESSING and GENERATING\\_NETWORK.",
            "$ref" : "#/definitions/Percent"
          }
        },
        "description" : "The progress for a running high-performance routing network calculation.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.HighPerformanceRoutingNetworkProgress"
      } ],
      "x-discriminator-value" : "HighPerformanceRoutingNetworkProgress",
      "x-ms-discriminator-value" : "HighPerformanceRoutingNetworkProgress"
    },
    "HighPerformanceRoutingNetworkProgressStatus" : {
      "type" : "string",
      "description" : "Possible status values for the progress of a running high-performance routing network calculation.  \n * `PREPROCESSING` - Indicates that some tasks have to be done before generating the high-performance routing network. The actual progress of this state is available in HighPerformanceRoutingNetworkProgress.progress.  \n * `GENERATING_NETWORK` - Indicates the generation of the high-performance routing network is ongoing. The actual progress of this state is available in HighPerformanceRoutingNetworkProgress.progress.  \n * `DONE` - Indicates that the generation of the high-performance routing network is finished.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.xdata.HighPerformanceRoutingNetworkProgressStatus",
      "enum" : [ "PREPROCESSING", "GENERATING_NETWORK", "DONE" ],
      "x-ms-enum" : {
        "name" : "HighPerformanceRoutingNetworkProgressStatus",
        "modelAsString" : false
      }
    },
    "HighPerformanceRoutingNetworkResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "string",
            "description" : "The ID of the high-performance routing network which is generated when the network is created. Use this ID to reference the high-performance routing network for further use. The ID can be uninitialized. An uninitialized ID indicates that the requested high-performance routing network is already existing. In this case a HighPerformanceRoutingNetworkAlreadyAvailableLimitation is created. It may contain the ID of the already existing high-performance routing network. Otherwise an unitialized ID in the HighPerformanceRoutingNetworkAlreadyAvailableLimitation indicates that the user has requested a high-performance routing network which has been delivered with the map."
          }
        },
        "description" : "This type contains the ID of a high-performance routing network that has been created.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.HighPerformanceRoutingNetworkResponse"
      } ],
      "x-discriminator-value" : "HighPerformanceRoutingNetworkResponse",
      "x-ms-discriminator-value" : "HighPerformanceRoutingNetworkResponse"
    },
    "HighPerformanceRoutingNetworksListResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "properties" : {
          "highPerformanceRoutingNetworkInformation" : {
            "type" : "array",
            "items" : {
              "description" : "The result list containing information about each high-performance routing network. If specific high-performance routing network IDs have been requested there is one entry in the list for each requested ID in the same order.",
              "$ref" : "#/definitions/HighPerformanceRoutingNetworkInformation"
            }
          }
        },
        "description" : "This type represents a list of meta information on high-performance routing networks.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.HighPerformanceRoutingNetworksListResponse"
      } ],
      "x-discriminator-value" : "HighPerformanceRoutingNetworksListResponse",
      "x-ms-discriminator-value" : "HighPerformanceRoutingNetworksListResponse"
    },
    "Horizon" : {
      "type" : "object",
      "required" : [ "$type" ],
      "discriminator" : "$type",
      "properties" : {
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "The abstract base type for geographical horizons like the reachable circle around a point.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.routing.Horizon"
    },
    "Hotel" : {
      "type" : "object",
      "required" : [ "id", "location" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "The unique identifier of this hotel."
        },
        "location" : {
          "description" : "The geographical position of this hotel.",
          "$ref" : "#/definitions/RouteLocation"
        }
      },
      "description" : "Represents a hotel for visit planning use cases with overnight stays.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.Hotel"
    },
    "HotelStayOptions" : {
      "type" : "object",
      "properties" : {
        "maximumTravelDistanceToHotel" : {
          "description" : "Approximate upper bound on the distance in meters the field worker is willing to travel to a hotel after completing all visits of a day.",
          "type" : "number"
        },
        "maximumTravelDistanceFromHotel" : {
          "description" : "Approximate upper bound on the distance in meters the field worker is willing to travel from a hotel to the first visit of a day.",
          "type" : "number"
        }
      },
      "description" : "Options influencing use cases with overnight stays at hotels.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.HotelStayOptions"
    },
    "IconAnchor" : {
      "type" : "object",
      "required" : [ "x", "y" ],
      "properties" : {
        "x" : {
          "description" : "The x-coordinate of the anchor point in pixels.",
          "$ref" : "#/definitions/AnchorX"
        },
        "y" : {
          "description" : "The y-coordinate of the anchor point in pixels.",
          "$ref" : "#/definitions/AnchorY"
        }
      },
      "description" : "Defines the anchor point of the icon in pixels, i.e. the position of the icon which is placed on the geographical reference point on the map. If this field is specified, the alignment is ignored. It's also allowed to define an anchor point which is outside of the icon itself by using negative values. The minimal allowed values are (-16,-16) The maximum values are (66, 66) due to the maximum icon size of (50, 50)\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.renderingprofile.IconAnchor"
    },
    "IconStyle" : {
      "type" : "object",
      "properties" : {
        "renderLevel" : {
          "description" : "Defines the level on which the icon is rendered, i.e. on top or below what other objects.",
          "$ref" : "#/definitions/RenderLevel"
        },
        "anchor" : {
          "description" : "Defines the anchor point of the icon in pixels, i.e. the position of the icon which is placed on the geographical reference point on the map. If this field is specified, the alignment is ignored. It's also allowed to define an anchor point which is outside of the icon itself by using negative values. The minimal allowed values are (-16,-16) The maximum values are (66, 66) due to the maximum icon size of (50, 50)",
          "$ref" : "#/definitions/IconAnchor"
        },
        "alignment" : {
          "description" : "The alignment of the icon. The specified position within the icon is placed at its geographic reference point on the map. This setting can be overridden by specifying an anchor point.",
          "$ref" : "#/definitions/Alignment"
        },
        "url" : {
          "description" : "The relative or absolute url of the icon. A relative url refers to the configured icon folder. An absolute url must be an http url in order to download the icon from another server. If this represents a file name relative to the configured bitmap path, it must be encoded, i.e. special characters such as white spaces must be represented by %20. It is recommended to use only alphanumeric characters. If the icon exceeds the maximum height or width of 50 pixels, the default icon is rendered instead.",
          "$ref" : "#/definitions/Url"
        },
        "displayRange" : {
          "description" : "The zoom range in which the specified style should be applied.",
          "$ref" : "#/definitions/ZoomLevelRange"
        }
      },
      "description" : "Defines how to render the icon (e.g. a feature label).\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.renderingprofile.IconStyle"
    },
    "ImageFormat" : {
      "type" : "string",
      "description" : "Enumeration of the supported bitmap formats, which can be used for rendered map images.  \n * `PNG` - Image is provided in *Portable Network Graphics* format.  \n * `JPG` - Image is provided in  *Joint Photographic Experts Group* format.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.xmap.ImageFormat",
      "enum" : [ "PNG", "JPG" ],
      "x-ms-enum" : {
        "name" : "ImageFormat",
        "modelAsString" : false
      }
    },
    "ImageOptions" : {
      "type" : "object",
      "properties" : {
        "format" : {
          "description" : "The format of the image. In case of `JPG`, the backgrounds (like oceans and forests) must be part of the image content, because they guarantee an image without any transparent pixels. This is important, because for `JPG` semi-transparent pixels would be drawn in black erroneously. Therefore a ParameterConflictException is thrown in such a case.",
          "$ref" : "#/definitions/ImageFormat"
        },
        "height" : {
          "description" : "The height of the image in physical pixel. The maximum allowed value is 8192.",
          "$ref" : "#/definitions/PhysicalPixel"
        },
        "width" : {
          "description" : "The width of the image in physical pixel. The maximum allowed value is 8192.",
          "$ref" : "#/definitions/PhysicalPixel"
        }
      },
      "description" : "Describes the configuration of the rendered image. Some properties of this type are described in detail in the Image Generation concept.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xmap.ImageOptions"
    },
    "IncludedNetworkClasses" : {
      "type" : "object",
      "properties" : {
        "included" : {
          "type" : "array",
          "items" : {
            "type" : "boolean",
            "description" : "The network classes to include in the result."
          }
        }
      },
      "description" : "Defines a list of network classes to be included in the result. For more information about network classes see the type of the segment attribute network class.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.IncludedNetworkClasses"
    },
    "Index" : {
      "type" : "integer",
      "format" : "int32",
      "description" : "An index is always 0-based. Range: 0 ??? value.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.Index"
    },
    "IndexInterval" : {
      "type" : "object",
      "required" : [ "end", "start" ],
      "properties" : {
        "start" : {
          "description" : "the start index of the interval",
          "$ref" : "#/definitions/Index"
        },
        "end" : {
          "description" : "the end index of the interval",
          "$ref" : "#/definitions/Index"
        }
      },
      "description" : "Specifies an interval of indices \\[start, end\\] with both values included.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.types.IndexInterval"
    },
    "IndexPair" : {
      "type" : "object",
      "required" : [ "first", "second" ],
      "properties" : {
        "first" : {
          "description" : "the first index value",
          "$ref" : "#/definitions/Index"
        },
        "second" : {
          "description" : "the second index value",
          "$ref" : "#/definitions/Index"
        }
      },
      "description" : "Specifies a pair of indices. Could be used to denote a position in a matrix or a list of lists.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.types.IndexPair"
    },
    "IndexPairInterval" : {
      "type" : "object",
      "required" : [ "end", "start" ],
      "properties" : {
        "start" : {
          "description" : "the start index pair of the interval",
          "$ref" : "#/definitions/IndexPair"
        },
        "end" : {
          "description" : "the end index pair of the interval",
          "$ref" : "#/definitions/IndexPair"
        }
      },
      "description" : "Specifies an interval of index pairs \\[start, end\\] with both values included.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.types.IndexPairInterval"
    },
    "InputPlan" : {
      "type" : "object",
      "properties" : {
        "tours" : {
          "type" : "array",
          "items" : {
            "description" : "List of input tours.",
            "$ref" : "#/definitions/Tour"
          }
        },
        "fixations" : {
          "type" : "array",
          "items" : {
            "description" : "Fixations of input tours.",
            "$ref" : "#/definitions/Fixation"
          }
        },
        "tripStartIntervals" : {
          "type" : "array",
          "items" : {
            "description" : "If a trip start interval is set for a trip in a planToursRequest, a fixation of type trip to vehicle has to be explicitly set for this trip. It is possible however to remove the fixation via a removeFixationsAction and to use all ChangeToursActions or findChangeToursProposalsRequests. A PlanToursRequest with calculation mode EVALUATE also does not need a fixation.",
            "$ref" : "#/definitions/TripStartInterval"
          }
        }
      },
      "description" : "A list of tours that serves the algorithm as start solution (e.g. tours of previous responses). All tours of an input plan have to be structurally valid. See Tours and Trips for a description of valid tour structures. The input tours can generally be changed or dissolved except when they are fixed. Violated input tours cannot be changed and appear unchanged in the response with their tour events containing tour violations.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.InputPlan"
    },
    "InputWaypoint" : {
      "type" : "object",
      "required" : [ "$type" ],
      "discriminator" : "$type",
      "properties" : {
        "name" : {
          "type" : "string",
          "description" : "User-defined content to identify the waypoint in route response elements like Leg. Make sure that this name is unique even if a waypoint is visited more than once."
        },
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "Base for all waypoint types that can be provided as input in a RouteRequest.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.InputWaypoint"
    },
    "InsertionAfterSpecifiedPosition" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InsertionPosition"
      }, {
        "type" : "object",
        "required" : [ "position" ],
        "properties" : {
          "position" : {
            "description" : "Position to insert the task or trip after. The specified position is associated with a stop in a trip if this object is used in a MoveOrdersAction or MoveStopsAction. The specified position is associated with a trip in a tour if this object is used in a MoveTripsAction or a AddTripAction.",
            "$ref" : "#/definitions/Index"
          }
        },
        "description" : "This type defines the insertion position of a task, stop or trip after a specified position.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.InsertionAfterSpecifiedPosition"
      } ],
      "x-discriminator-value" : "InsertionAfterSpecifiedPosition",
      "x-ms-discriminator-value" : "InsertionAfterSpecifiedPosition"
    },
    "InsertionAtBestPosition" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InsertionPosition"
      }, {
        "type" : "object",
        "description" : "This type defines the insertion position of a task, stop or trip at the best position. If no valid position can be found, the IDs of the respective orders are added to orderIdsNotPlanned after performing the ChangeToursAction.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.InsertionAtBestPosition"
      } ],
      "x-discriminator-value" : "InsertionAtBestPosition",
      "x-ms-discriminator-value" : "InsertionAtBestPosition"
    },
    "InsertionBeforeSpecifiedPosition" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InsertionPosition"
      }, {
        "type" : "object",
        "required" : [ "position" ],
        "properties" : {
          "position" : {
            "description" : "Position to insert the task or trip before. The specified position is associated with a stop in a trip if this object is used in a MoveOrdersAction or MoveStopsAction. The specified position is associated with a trip in a tour if this object is used in a MoveTripsAction or a AddTripAction.",
            "$ref" : "#/definitions/Index"
          }
        },
        "description" : "This type defines the insertion position of a task, stop or trip before a specified position.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.InsertionBeforeSpecifiedPosition"
      } ],
      "x-discriminator-value" : "InsertionBeforeSpecifiedPosition",
      "x-ms-discriminator-value" : "InsertionBeforeSpecifiedPosition"
    },
    "InsertionIntoEmptyTour" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InsertionPosition"
      }, {
        "type" : "object",
        "description" : "This type defines the insertion position of a trip into an empty tour. It can be used in a MoveTripsAction to move a trip to an empty vehicle or by a AddTripAction to create a trip for an empty vehicle.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.InsertionIntoEmptyTour"
      } ],
      "x-discriminator-value" : "InsertionIntoEmptyTour",
      "x-ms-discriminator-value" : "InsertionIntoEmptyTour"
    },
    "InsertionPosition" : {
      "type" : "object",
      "required" : [ "$type" ],
      "discriminator" : "$type",
      "properties" : {
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "The abstract base type to define the insertion position of a task, stop or trip.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.InsertionPosition"
    },
    "InsertionPositionsForOrdersQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ChangeToursProposalsQuery"
      }, {
        "type" : "object",
        "properties" : {
          "orderIds" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "description" : "IDs of the orders to be inserted. All referenced orders need to be unplanned, otherwise an OrderAlreadyPlannedFault is thrown. At the moment, only one order is supported."
            }
          },
          "targetVehicleIds" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "description" : "Option to restrict target vehicles. If empty, all vehicles of different types of the plan are considered as target vehicles."
            }
          },
          "maximumNumberOfMoveOrdersActions" : {
            "description" : "Option to restrict the number of proposals which may reduce the calculation time of the request. At most the given number of MoveOrdersActions are proposed.",
            "$ref" : "#/definitions/NonNegativeInteger"
          },
          "maximumDistanceOfAdjacentStops" : {
            "description" : "Option to restrict the number of proposals which may reduce the calculation time of the request. A MoveOrdersAction is proposed only if the airline distance of the leg between the sites of the given order and the adjacent stops in the tour is less than the given value.",
            "type" : "number"
          }
        },
        "description" : "A query to propose insertion positions for unplanned orders. Only structurally valid positions are proposed, for details please have a look at tour structures. The proposed change tours actions are either add trip actions or move orders actions. If violated insertion positions shall be part of the proposals, set returnViolatedTours to true. The resulting tour is contained in the Tours and TourReports. This query may be used to analyze unscheduled orders, see the corresponding integration sample.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.InsertionPositionsForOrdersQuery"
      } ],
      "x-discriminator-value" : "InsertionPositionsForOrdersQuery",
      "x-ms-discriminator-value" : "InsertionPositionsForOrdersQuery"
    },
    "IntermediateResponseLimitation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResultLimitation"
      }, {
        "type" : "object",
        "properties" : {
          "reason" : {
            "description" : "The reason for this limitation.",
            "$ref" : "#/definitions/IntermediateResponseReason"
          }
        },
        "description" : "This result limitation indicates that the request has been stopped either by the user or due to a timeout. The returned response is an intermediate but valid response that usually differs from the final response.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.service.IntermediateResponseLimitation"
      } ],
      "x-discriminator-value" : "IntermediateResponseLimitation",
      "x-ms-discriminator-value" : "IntermediateResponseLimitation"
    },
    "IntermediateResponseReason" : {
      "type" : "string",
      "description" : "The reason for an intermediate response limitation.  \n * `REQUEST_STOPPED` - The request was stopped by calling the `stopRequest` method from xruntime.XRuntime for synchronous or a service specific `stopJob` method for asynchronous requests, respectively.  \n * `REQUEST_TIMED_OUT` - The request was stopped due to a timeout. For further information see Timeouts.computationTimeout.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.service.IntermediateResponseReason",
      "enum" : [ "REQUEST_STOPPED", "REQUEST_TIMED_OUT" ],
      "x-ms-enum" : {
        "name" : "IntermediateResponseReason",
        "modelAsString" : false
      }
    },
    "InternalErrorFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/XServerFault"
      }, {
        "type" : "object",
        "description" : "This fault is thrown if an unexpected internal error occurs. It may happen when a module runs out of memory or lacks an important resource. If the error persists, report it to PTV's xServer support.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.InternalErrorFault"
      } ],
      "x-discriminator-value" : "InternalErrorFault",
      "x-ms-discriminator-value" : "InternalErrorFault"
    },
    "IntersectionTurnCosts" : {
      "type" : "object",
      "properties" : {
        "turnStrategy" : {
          "description" : "Defines the turn strategy to adopt",
          "$ref" : "#/definitions/TurnStrategy"
        },
        "customTurnStrategy" : {
          "description" : "Defines a specific turn strategy configuration in an encoded form.",
          "$ref" : "#/definitions/EncodedContent"
        }
      },
      "description" : "Defines the cost of every turn for all kinds of intersection with a turn strategy.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.routingprofile.IntersectionTurnCosts"
    },
    "Interval" : {
      "type" : "object",
      "required" : [ "$type" ],
      "discriminator" : "$type",
      "properties" : {
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "Abstract base type for intervals.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.time.Interval"
    },
    "InvalidFetchTypeFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InvalidRequestFault"
      }, {
        "type" : "object",
        "required" : [ "jobId" ],
        "properties" : {
          "jobId" : {
            "type" : "string",
            "description" : "ID of the asynchronous job."
          }
        },
        "description" : "This fault is thrown if the type of a fetch request, to get the response of an asynchronous job, is invalid. For example if the response of a startPlanTours request is fetched with fetchDistanceMatrixResponse.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.InvalidFetchTypeFault"
      } ],
      "x-discriminator-value" : "InvalidFetchTypeFault",
      "x-ms-discriminator-value" : "InvalidFetchTypeFault"
    },
    "InvalidLoadingSequenceFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TripStructureFault"
      }, {
        "type" : "object",
        "required" : [ "siteId" ],
        "properties" : {
          "siteId" : {
            "type" : "string",
            "description" : "ID of the site that violates the loading sequence structure."
          }
        },
        "description" : "This fault is thrown if a site in an input tour is left although there is still load *for* it on the vehicle or is served although there is still load *from* it on the vehicle or a ChangeToursRequest would lead to this wrong loading sequence. For more information please have a look at the section valid loading sequence of the technical concept for tours and trips.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.InvalidLoadingSequenceFault"
      } ],
      "x-discriminator-value" : "InvalidLoadingSequenceFault",
      "x-ms-discriminator-value" : "InvalidLoadingSequenceFault"
    },
    "InvalidProfileNameFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InvalidRequestFault"
      }, {
        "type" : "object",
        "required" : [ "profile" ],
        "properties" : {
          "profile" : {
            "type" : "string",
            "description" : "The profile name."
          }
        },
        "description" : "This fault is thrown if an invalid profile name is passed\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.InvalidProfileNameFault"
      } ],
      "x-discriminator-value" : "InvalidProfileNameFault",
      "x-ms-discriminator-value" : "InvalidProfileNameFault"
    },
    "InvalidRequestFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/XServerFault"
      }, {
        "type" : "object",
        "description" : "This fault is thrown if a request is invalid, for instance if it does not fit the WSDL specification.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.InvalidRequestFault"
      } ],
      "x-discriminator-value" : "InvalidRequestFault",
      "x-ms-discriminator-value" : "InvalidRequestFault"
    },
    "InvalidTaskSequenceFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/StopStructureFault"
      }, {
        "type" : "object",
        "required" : [ "orderId", "taskIndex", "taskType" ],
        "properties" : {
          "orderId" : {
            "type" : "string",
            "description" : "ID of the transport order causing the exception."
          },
          "taskType" : {
            "description" : "Task type of the task causing the exception.",
            "$ref" : "#/definitions/TaskType"
          },
          "taskIndex" : {
            "description" : "Index of the task in tasks causing the wrong order sequence structure.",
            "$ref" : "#/definitions/Index"
          }
        },
        "description" : "This fault is thrown if a delivery task is not at the beginning of a stop or a pickup task is not at the end of a stop.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.InvalidTaskSequenceFault"
      } ],
      "x-discriminator-value" : "InvalidTaskSequenceFault",
      "x-ms-discriminator-value" : "InvalidTaskSequenceFault"
    },
    "InvalidTourRequestFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InvalidRequestFault"
      }, {
        "type" : "object",
        "description" : "This fault is thrown if a PlanToursRequest or a ChangeToursRequest is invalid.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.InvalidTourRequestFault"
      } ],
      "x-discriminator-value" : "InvalidTourRequestFault",
      "x-ms-discriminator-value" : "InvalidTourRequestFault"
    },
    "InvalidValueFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InvalidRequestFault"
      }, {
        "type" : "object",
        "required" : [ "parameter", "value" ],
        "properties" : {
          "parameter" : {
            "type" : "string",
            "description" : "An xPath like specification of the parameter that is set to an invalid value."
          },
          "value" : {
            "type" : "string",
            "description" : "The invalid value."
          }
        },
        "description" : "This fault is thrown if a request parameter is set to an invalid value.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.InvalidValueFault"
      } ],
      "x-discriminator-value" : "InvalidValueFault",
      "x-ms-discriminator-value" : "InvalidValueFault"
    },
    "ItemOrientation" : {
      "type" : "string",
      "description" : "Enumerates possible orientations. This is the full set of orientations that can lead to a unique shape of a cuboid object. Note that as only the shape is considered, things like whether an item is upside down have no influence on its orientation in this model. While we named the orientations, it might be simpler thinking of them as discrete orientations with no deeper meaning.  \n * `ORIGINAL` - Items is not re-oriented. Dimensions stay (x,y,z).  \n * `X` - Item is rotated around x-axis (widthwise) by +/-90 degrees compared to the original orientation. Dimensions are (x,z,y).  \n * `Y` - Item is rotated around y-axis (heightwise) by +/-90 degrees compared to the original orientation. Dimensions are (z,y,x).  \n * `Z` - Item is rotated around z-axis (lengthwise) by +/-90 degrees compared to the original orientation. Dimensions are (y,x,z).  \n * `XZ` - Item is rotated around x- then z-axis (width- then heightwise) by +/-90 degrees compared to the original orientation. Dimensions are (z,x,y).  \n * `YZ` - Item is rotated around its y- then z-axis (length- then heightwise) by +/-90 degrees compared to the original orientation. Dimensions are (y,z,x).\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.xload.ItemOrientation",
      "enum" : [ "ORIGINAL", "X", "Y", "Z", "XZ", "YZ" ],
      "x-ms-enum" : {
        "name" : "ItemOrientation",
        "modelAsString" : false
      }
    },
    "ItemPosition" : {
      "type" : "object",
      "required" : [ "x", "y", "z" ],
      "properties" : {
        "x" : {
          "description" : "Offset along x-axis. Equal to the shift along the width of the bin from left to right. Rounded to nearest full centimeter internally.",
          "$ref" : "#/definitions/Dimension"
        },
        "y" : {
          "description" : "Offset along y-axis. Equal to the height from the floor of the bin. Rounded to nearest full centimeter internally.",
          "$ref" : "#/definitions/Dimension"
        },
        "z" : {
          "description" : "Offset along z-axis. Equal to the shift along the length of the bin from back to front. Rounded to nearest full centimeter internally.",
          "$ref" : "#/definitions/Dimension"
        }
      },
      "description" : "Describes the position of an item in a bin. The coordinate system is right-handed with x extending to the right, y pointing up and z pointing towards you. In terms of a truck (0,0,0) would be at the lower-left-corner of the opposing wall when looking through the back doors. An item, for example a palette, placed there would be on the ground. It would also touch the left wall as well as the wall towards the drivers cabin.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xload.ItemPosition"
    },
    "ItemSurfaceLoads" : {
      "type" : "object",
      "properties" : {
        "x" : {
          "description" : "Surface load acting on the x-axis (width) of the item. Internally rounded to nearest full g/cm?? .",
          "$ref" : "#/definitions/SurfaceLoad"
        },
        "y" : {
          "description" : "Surface load acting on the y-axis (height) of the item. Internally rounded to nearest full g/cm?? .",
          "$ref" : "#/definitions/SurfaceLoad"
        },
        "z" : {
          "description" : "Surface load acting on the z-axis (length) of the item. Internally rounded to nearest full g/cm?? .",
          "$ref" : "#/definitions/SurfaceLoad"
        }
      },
      "description" : "Describes the surface loads in kg/m?? on an item acting on each of its axis. If an axis is not provided it is assumed to be irrelevant and/or non-restrictive.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xload.ItemSurfaceLoads"
    },
    "ItemType" : {
      "type" : "object",
      "required" : [ "dimensions", "id", "weight" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "User provided ID for this item type. Must be unique."
        },
        "dimensions" : {
          "description" : "Outer dimensions of this item. Please note that the sum of each dimension (i.e. x+y+z) should be greater than 50 cm.",
          "$ref" : "#/definitions/BoxDimensions"
        },
        "weight" : {
          "description" : "Weight of this item. Internally rounded to nearest full gram.",
          "$ref" : "#/definitions/Kilograms"
        },
        "maximumSurfaceLoads" : {
          "description" : "Maximum allowable load on this item. An item experiences load when other items are stacked on top of it. The load limit is defined for each axis as the item might be re-oriented. If not given no limitation based on surface load is made.",
          "$ref" : "#/definitions/ItemSurfaceLoads"
        },
        "allowedOrientations" : {
          "description" : "Allowed ways to orient this item when packing it into a bin. If not given all orientations will be allowed.",
          "$ref" : "#/definitions/AllowedItemOrientations"
        },
        "numberOfItems" : {
          "description" : "Number of items of this type that should be packed. Maximum number is 10000.",
          "$ref" : "#/definitions/PositiveInteger"
        }
      },
      "description" : "Describes a cuboid item which is to be packed into a bin. If there are many identical items that do not have to be differentiated by individual ItemType.id you should use the ItemType.numberOfItems field. This provides better performance and packing than specifying each item on its own when this is not needed.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xload.ItemType"
    },
    "ItemsToUnload" : {
      "type" : "object",
      "required" : [ "itemTypeId" ],
      "properties" : {
        "itemTypeId" : {
          "type" : "string",
          "description" : "ID of the ItemType."
        },
        "numberOfItems" : {
          "description" : "The amount of items to unload.",
          "$ref" : "#/definitions/PositiveInteger"
        }
      },
      "description" : "Defines the amount of items to unload.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xload.ItemsToUnload"
    },
    "Job" : {
      "type" : "object",
      "required" : [ "elapsedTime", "id", "status" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "Reference to jobs running in the background."
        },
        "status" : {
          "description" : "The current status of the job.",
          "$ref" : "#/definitions/JobStatus"
        },
        "progress" : {
          "description" : "The current progress of the job. Can be null at the very beginning or very end of the request execution.",
          "$ref" : "#/definitions/JobProgress"
        },
        "elapsedTime" : {
          "description" : "Elapsed time since this job has been queued.",
          "$ref" : "#/definitions/Milliseconds"
        }
      },
      "description" : "Reference to jobs running in the background.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.jobs.Job"
    },
    "JobProgress" : {
      "type" : "object",
      "required" : [ "$type" ],
      "discriminator" : "$type",
      "properties" : {
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "Abstract base type for progresses.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.jobs.JobProgress"
    },
    "JobRequest" : {
      "type" : "object",
      "required" : [ "id" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "The job's ID."
        }
      },
      "description" : "Request for stopping and deleting jobs.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.jobs.JobRequest"
    },
    "JobStatus" : {
      "type" : "string",
      "description" : "Specifies different job status values.  \n * `QUEUING` - Job has been enqueued.  \n * `RUNNING` - Job is currently running.  \n * `STOPPING` - Stop has been requested, the job will terminate its calculation as soon as possible.  \n * `SUCCEEDED` - Job has completed successfully.  \n * `FAILED` - Job has failed with an exception.  \n * `DELETED` - The job was deleted by the user.  \n * `UNKNOWN` - The job is in an unknown state. For example a given ID is unknown or the job has already been fetched and has therefore been deleted from the underlying persistent store.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.jobs.JobStatus",
      "enum" : [ "QUEUING", "RUNNING", "STOPPING", "SUCCEEDED", "FAILED", "DELETED", "UNKNOWN" ],
      "x-ms-enum" : {
        "name" : "JobStatus",
        "modelAsString" : false
      }
    },
    "KML" : {
      "type" : "object",
      "required" : [ "kml" ],
      "properties" : {
        "kml" : {
          "type" : "string",
          "description" : "the kml string itself"
        },
        "placemarks" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "description" : "The placemarks of the KML. If empty, all placemarks will be used. This will result in a GeometryCollection, if more than one exists."
          }
        }
      },
      "description" : "Represents a KML geometry.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.geometry.KML"
    },
    "KeyValuePair" : {
      "type" : "object",
      "required" : [ "key", "value" ],
      "properties" : {
        "key" : {
          "type" : "string",
          "description" : "Key identifying the value."
        },
        "value" : {
          "type" : "string",
          "description" : "Value identified by the key. Interpretation depends on point of use."
        }
      },
      "description" : "Type for storing a single untyped key value pair. Contains a string key and value. Interpretation of this type depends on the point of use. It is usually found in lists with keys being unique to the list unless otherwise mentioned.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.types.KeyValuePair"
    },
    "Kilograms" : {
      "type" : "number",
      "format" : "double",
      "description" : "Defines the type for weights in \\[kg\\]. Range: 0.0 ??? value.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.Kilograms"
    },
    "LabelingConflictResolution" : {
      "type" : "object",
      "properties" : {
        "scope" : {
          "description" : "Defines the scope of the overlapping resolution.",
          "$ref" : "#/definitions/Scope"
        },
        "forceDisplay" : {
          "type" : "boolean",
          "description" : "If the label cannot be drawn without overlapping another label, it will be drawn at its reference point if forceDisplay is true. Otherwise it will not be drawn."
        }
      },
      "description" : "Defines the behavior when labels or icons overlap. In order to avoid overlapping with labels already drawn they can be displaced so that they do not overlap, anymore. This means that labels already drawn will not be repositioned but stay where they are.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.renderingprofile.LabelingConflictResolution"
    },
    "Language" : {
      "type" : "object",
      "properties" : {
        "code" : {
          "description" : "The language code.",
          "$ref" : "#/definitions/LanguageCode"
        },
        "name" : {
          "type" : "string",
          "description" : "The language name in the respective language."
        }
      },
      "description" : "Specifies a language by its code and its name.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.types.Language"
    },
    "LanguageCode" : {
      "type" : "string",
      "description" : "Defines a language. Examples: \"en\" for English or \"de\" for German. See language codes for more details. Pattern: \\[a-zA-Z\\]\\{1,8\\}(-\\[a-zA-Z0-9\\]\\{1,8\\})\\*.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.LanguageCode"
    },
    "Leg" : {
      "type" : "object",
      "required" : [ "distance", "travelTime", "violated" ],
      "properties" : {
        "startWaypointName" : {
          "type" : "string",
          "description" : "The name of the start waypoint of the leg. This user-defined name is available only if InputWaypoint.name for the corresponding input waypoint is set."
        },
        "endWaypointName" : {
          "type" : "string",
          "description" : "The name of the end waypoint of the leg. This user-defined name is available only if InputWaypoint.name for the corresponding input waypoint is set."
        },
        "startSegmentIndex" : {
          "description" : "The index in the list of RouteResponse.segments of the start segment of the leg. It is available only if the list of segments is requested by ResultFields.segments.",
          "$ref" : "#/definitions/Index"
        },
        "endSegmentIndex" : {
          "description" : "The index in the list of RouteResponse.segments of the end segment of the leg. It is available only if the list of segments is requested by ResultFields.segments.",
          "$ref" : "#/definitions/Index"
        },
        "startNodeIndex" : {
          "description" : "The index in the list of RouteResponse.nodes of the start node of the leg. It is available only if the list of nodes is requested by ResultFields.nodes.",
          "$ref" : "#/definitions/Index"
        },
        "endNodeIndex" : {
          "description" : "The index in the list of RouteResponse.nodes of the end node of the leg. It is available only if the list of nodes is requested by ResultFields.nodes.",
          "$ref" : "#/definitions/Index"
        },
        "startTollSectionIndex" : {
          "description" : "The index in the list of Toll.sections of the first toll section of the leg. It is available only if the toll sections are requested in ResultFields.toll and if there is at least one toll section for the leg.",
          "$ref" : "#/definitions/Index"
        },
        "endTollSectionIndex" : {
          "description" : "The index in the list of Toll.sections of the last toll section of the leg. It is available only if the toll sections are requested in ResultFields.toll and if there is at least one toll section for the leg.",
          "$ref" : "#/definitions/Index"
        },
        "distance" : {
          "description" : "The travel distance for the leg. It is the sum of distances of all segments in the leg and hence is a whole number without decimal places (see Segment.distance).",
          "type" : "number"
        },
        "travelTime" : {
          "description" : "The travel time for the leg. It is the sum of travel times of all segments in the leg and hence has up to three decimal places (see Segment.travelTime).",
          "$ref" : "#/definitions/Duration"
        },
        "trafficDelay" : {
          "description" : "The total delay due to traffic incidents (traffic jams, construction sites etc.) on the leg.\r\n\r\nFor each section of the route where traffic incidents are present, the delay is calculated comparing the travel time for that section with and without traffic incidents. That means the delay contains the time that it takes longer to pass the traffic jam than usually at the same time and the same day of week. As an example, driving a section on a highway between two exits usually takes 15 minutes on an average Friday afternoon at 4 pm, but due to a road works there is a traffic jam on this specific Friday afternoon at 4 pm, and driving this section takes 30 minutes. The delay will be 15 minutes.\r\n\r\nThis value will be non-zero only when Feature Layer PTV\\_TrafficIncidents is enabled and one of the time-consideration scenarios ExactTimeConsiderationAtStart and ExactTimeConsiderationAtArrival is used.",
          "$ref" : "#/definitions/Duration"
        },
        "tollSummary" : {
          "description" : "The toll summary for the leg. The toll summary is only populated if requested by LegResultFields.tollSummary.",
          "$ref" : "#/definitions/TollSummary"
        },
        "emissions" : {
          "description" : "The emissions along the route.",
          "$ref" : "#/definitions/Emissions"
        },
        "polyline" : {
          "description" : "The polyline of the leg. This polyline consists of all coordinates representing the leg and can be used to draw the leg onto a map. It is available only if requested by LegResultFields.polyline and it contains elevations only if requested by xroute.PolylineOptions.elevations. If the elevations data do not cover the complete polyline, an xroute.ElevationsNotAvailableLimitation will be available which states which parts of the polyline are not covered.",
          "$ref" : "#/definitions/EncodedGeometry"
        },
        "violated" : {
          "type" : "boolean",
          "description" : "If set to true, indicates that this leg contains a violation for the chosen vehicle."
        }
      },
      "description" : "A leg is defined by a start- and an end-waypoint and the segment (s) between them. It is guaranteed that a leg consists of at least one segment. It is also guaranteed that the leg of index *n* connects waypoints of indices *n* and *n+1*, i.e. the number of response waypoints equals the number of the list of legs plus 1.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.Leg"
    },
    "LegReport" : {
      "type" : "object",
      "properties" : {
        "startTourEventIndex" : {
          "description" : "References the first driving event of this leg.",
          "$ref" : "#/definitions/Index"
        },
        "endTourEventIndex" : {
          "description" : "References the last driving event of this leg.",
          "$ref" : "#/definitions/Index"
        },
        "drivingTime" : {
          "description" : "The driving time between start and end location.",
          "$ref" : "#/definitions/Duration"
        },
        "distance" : {
          "description" : "The driven distance between start and end location.",
          "type" : "number"
        },
        "estimatedByDirectDistance" : {
          "type" : "boolean",
          "description" : "True if the driving time of this leg is estimated by direct distance instead of the road network.\r\n\r\nPossible causes:\r\n\r\n *  start or end not within boundaries of map,\r\n *  start or end too far from next road,\r\n *  no route found between start and end.\r\n\r\nIf EstimateByReferenceMatrix is used as distance mode, the leg is estimated by direct distance if and only if the according reference locations are estimated by direct distance. If DirectDistance is used as distance mode, this flag will always be set."
        },
        "routeViolated" : {
          "type" : "boolean",
          "description" : "True if the leg is calculated with route violations. If EstimateByReferenceMatrix is used as distance mode, the route is violated if and only if the route between the according reference locations is violated."
        },
        "transportQuantities" : {
          "type" : "array",
          "items" : {
            "description" : "Current load on the vehicle when driving between the two successive stops.",
            "$ref" : "#/definitions/TransportQuantityUnit"
          }
        },
        "maximumQuantityScenarioIndex" : {
          "description" : "Index of the used maximum quantity scenario of the vehicle. If the tour is violated, always index 0 is chosen. The quantity scenario is changed as late as possible given the allowed quantity scenario change position.",
          "$ref" : "#/definitions/Index"
        }
      },
      "description" : "Contains information for the route between two successive sites of a tour. A leg is either between two stops of a trip, between two trips, between the vehicle start location and the first stop of the tour or between the last stop of a tour and the vehicle end location. For further information please have a look at the technical concept Tours and Trips.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.LegReport"
    },
    "LegResultFields" : {
      "type" : "object",
      "properties" : {
        "enabled" : {
          "type" : "boolean",
          "description" : "Specifies if the legs shall be returned for the complete route."
        },
        "polyline" : {
          "type" : "boolean",
          "description" : "Specifies if the legs shall contain the polyline."
        },
        "tollSummary" : {
          "type" : "boolean",
          "description" : "Specifies if the legs shall contain the toll summary."
        },
        "emissions" : {
          "type" : "boolean",
          "description" : "Specifies if the legs shall contain the emissions."
        }
      },
      "description" : "Specifies if and to what extent the legs shall be returned for the complete route.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.LegResultFields"
    },
    "LegalCondition" : {
      "type" : "object",
      "properties" : {
        "isEmergency" : {
          "type" : "boolean",
          "description" : "True for emergency vehicles. If this condition is set to true, certain parts of the road network that are prohibited except that emergency vehicles are accessible for the routing algorithm, and these parts are then treated exactly the same way as normal parts of the road network that are not prohibited. This setting affects segments which have set segments.RoadAttributes.allowedForEmergency. (1)"
        },
        "isDelivery" : {
          "type" : "boolean",
          "description" : "True for vehicles which are intended to deliver something. If this condition is set to true, certain parts of the road network that are prohibited except for delivery vehicles are accessible for the routing algorithm. The treatment of such parts can be configured in the routing profile using the parameters SpecialAreas.deliveryOnlyPenalty and SpecialAreas.deliveryOnlyGateCost. These settings affect segments which have set segments.RoadAttributes.deliveryOnly. (1,4)"
        }
      },
      "description" : "Defines a legal condition of the vehicle, e.g. whether the vehicle is delivering goods or is an emergency vehicle.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.vehicleprofile.LegalCondition"
    },
    "Library" : {
      "type" : "object",
      "required" : [ "groupId", "id", "name", "version" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "The library ID."
        },
        "groupId" : {
          "type" : "string",
          "description" : "The group ID."
        },
        "name" : {
          "type" : "string",
          "description" : "The library name."
        },
        "version" : {
          "type" : "string",
          "description" : "The library version."
        },
        "licenses" : {
          "type" : "array",
          "items" : {
            "description" : "The licenses of the library.",
            "$ref" : "#/definitions/License"
          }
        },
        "url" : {
          "description" : "A url to the library, if present.",
          "$ref" : "#/definitions/Url"
        }
      },
      "description" : "Represents a 3rd party library used by the xServer.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.Library"
    },
    "License" : {
      "type" : "object",
      "required" : [ "name", "url" ],
      "properties" : {
        "name" : {
          "type" : "string",
          "description" : "The license name."
        },
        "url" : {
          "type" : "string",
          "description" : "The license url."
        }
      },
      "description" : "Represents a 3rd party library used by the xServer.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.License"
    },
    "LicenseFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/SetupFault"
      }, {
        "type" : "object",
        "properties" : {
          "unlicensedServices" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "description" : "A list of services that are unlicensed."
            }
          }
        },
        "description" : "This fault is thrown if a license is missing for some services or if some data content is unlicensed.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.LicenseFault"
      } ],
      "x-discriminator-value" : "LicenseFault",
      "x-ms-discriminator-value" : "LicenseFault"
    },
    "LicenseViolationFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InvalidRequestFault"
      }, {
        "type" : "object",
        "required" : [ "key" ],
        "properties" : {
          "key" : {
            "type" : "string",
            "description" : "The name of the license key that is violated."
          }
        },
        "description" : "This fault is thrown if a request exceeds the licensed range of a specific feature. For example if only data in Germany is licensed, but coordinates in Switzerland are requested.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.LicenseViolationFault"
      } ],
      "x-discriminator-value" : "LicenseViolationFault",
      "x-ms-discriminator-value" : "LicenseViolationFault"
    },
    "Linking" : {
      "type" : "object",
      "properties" : {
        "maximumDistanceToSegment" : {
          "description" : "The maximum distance to search for a road segment to link to.",
          "type" : "number"
        },
        "minimumNetworkClass" : {
          "description" : "Link only to roads that have a network class bigger or equal the minimumNetworkClass.",
          "$ref" : "#/definitions/NetworkClass"
        },
        "maximumNetworkClass" : {
          "description" : "Link only to roads that have a network class lower or equal the maximumNetworkClass.",
          "$ref" : "#/definitions/NetworkClass"
        }
      },
      "description" : "Defines the behavior of linking a route location to the road network. For example, finding the road segment with the smallest distance to the route location.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.routingprofile.Linking"
    },
    "ListContentSnapshotsRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "properties" : {
          "ids" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "description" : "The IDs of all content snapshots that should be listed. If the list is null or empty, all available snapshots will be listed."
            }
          }
        },
        "description" : "This type represents settings for listing meta information of content snapshots.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.ListContentSnapshotsRequest"
      } ],
      "x-discriminator-value" : "ListContentSnapshotsRequest",
      "x-ms-discriminator-value" : "ListContentSnapshotsRequest"
    },
    "ListDistanceMatricesRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "properties" : {
          "ids" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "description" : "The IDs of all distance matrices that should be listed. If the list is null or empty, all available distance matrices will be listed."
            }
          },
          "resultFields" : {
            "description" : "Specifies the result fields that will be available in the response.",
            "$ref" : "#/definitions/ListDistanceMatricesResultFields"
          }
        },
        "description" : "This type represents settings for listing meta information of distance matrices.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdima.ListDistanceMatricesRequest"
      } ],
      "x-discriminator-value" : "ListDistanceMatricesRequest",
      "x-ms-discriminator-value" : "ListDistanceMatricesRequest"
    },
    "ListDistanceMatricesResultFields" : {
      "type" : "object",
      "properties" : {
        "startLocations" : {
          "type" : "boolean",
          "description" : "Indicates if a list of start locations should be included in the result."
        },
        "destinationLocations" : {
          "type" : "boolean",
          "description" : "Indicates if a list of destination locations should be included in the result."
        },
        "directDistanceRelations" : {
          "type" : "boolean",
          "description" : "Indicates if a list of relations that are approximated by direct distance should be included in the result."
        },
        "distanceMatrixOptions" : {
          "type" : "boolean",
          "description" : "Indicates if the options of the distance matrices should be included in the result."
        },
        "profiles" : {
          "type" : "boolean",
          "description" : "Indicates if the profiles should be included in the result."
        }
      },
      "description" : "Settings for the result fields of the meta information of distance matrices.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdima.ListDistanceMatricesResultFields"
    },
    "ListFeatureLayersRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "properties" : {
          "themeIds" : {
            "type" : "array",
            "items" : {
              "description" : "The IDs of the Feature Layer themes.",
              "$ref" : "#/definitions/ThemeId"
            }
          }
        },
        "description" : "This type represents settings for listing meta information of Feature Layers.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.ListFeatureLayersRequest"
      } ],
      "x-discriminator-value" : "ListFeatureLayersRequest",
      "x-ms-discriminator-value" : "ListFeatureLayersRequest"
    },
    "ListHighPerformanceRoutingNetworksRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "properties" : {
          "ids" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "description" : "The IDs of all high-performance routing networks that should be listed. If the list is null or empty, all available networks will be listed."
            }
          },
          "returnOnlyMatchingNetworks" : {
            "type" : "boolean",
            "description" : "If this parameter is set to true then only the high-performance routing networks that match the given options and profile are returned. In this case the profile and options that shall match have to be set also in the request."
          },
          "highPerformanceRoutingNetworkOptions" : {
            "description" : "Specifies options that are also relevant for selection of a high-performance routing network besides the profile. If only the matching networks are requested these options are used to filter the networks. Otherwise they are ignored.",
            "$ref" : "#/definitions/HighPerformanceRoutingNetworkOptions"
          },
          "resultFields" : {
            "description" : "Specifies the result fields that will be available in the response.",
            "$ref" : "#/definitions/ListHighPerformanceRoutingNetworksResultFields"
          }
        },
        "description" : "This type represents settings for listing meta data about high-performance routing networks.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.ListHighPerformanceRoutingNetworksRequest"
      } ],
      "x-discriminator-value" : "ListHighPerformanceRoutingNetworksRequest",
      "x-ms-discriminator-value" : "ListHighPerformanceRoutingNetworksRequest"
    },
    "ListHighPerformanceRoutingNetworksResultFields" : {
      "type" : "object",
      "properties" : {
        "highPerformanceRoutingNetworkOptions" : {
          "type" : "boolean",
          "description" : "Indicates if the options of the high-performance routing networks should be included in the result."
        },
        "profiles" : {
          "type" : "boolean",
          "description" : "Indicates if the profiles should be included in the result."
        }
      },
      "description" : "Settings for the result fields of the meta data about high-performance routing networks.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.ListHighPerformanceRoutingNetworksResultFields"
    },
    "Load" : {
      "type" : "object",
      "properties" : {
        "hazardousGoodsTypes" : {
          "description" : "Specifies the hazardous goods types of the load as a comma-separated list (only if the feature layer PTV\\_TruckAttributes is enabled). The available types can be requested through the xRuntime service and are documented in the manual as layer-specific properties of the feature layer PTV\\_TruckAttributes. (4)",
          "$ref" : "#/definitions/CommaSeparatedList"
        },
        "loadType" : {
          "description" : "The load type of the vehicle, e.g. passengers or goods, etc. This parameter is important to derive the type of the vehicle. For example, if the vehicle's weight is about 10 tons, then the load type can help to determine whether the vehicle is a truck or a bus. (1,2,3,4)",
          "$ref" : "#/definitions/LoadType"
        },
        "tunnelRestrictionCode" : {
          "description" : "The tunnel restriction code for dangerous load. (4)",
          "$ref" : "#/definitions/TunnelRestrictionCode"
        }
      },
      "description" : "Defines the current load of the vehicle\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.vehicleprofile.Load"
    },
    "LoadType" : {
      "type" : "string",
      "description" : "Defines the type of load and is mainly used to differentiate between cars and trucks. This setting controls the road blocks in the road network and the calculation of other mostly vehicle-dependent values such as toll and emissions.  \n * `PASSENGER` - The vehicle transports passengers.  \n * `GOODS` - The vehicle transports goods.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.vehicleprofile.LoadType",
      "enum" : [ "PASSENGER", "GOODS" ],
      "x-ms-enum" : {
        "name" : "LoadType",
        "modelAsString" : false
      }
    },
    "LoadingMeter" : {
      "type" : "number",
      "format" : "double",
      "description" : "One meter of loading space of a truck's or container's length. Range: 0.0 ??? value.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.LoadingMeter"
    },
    "LocationType" : {
      "type" : "string",
      "description" : "Distinguishes different types of Locations.  \n * `LOCALITY` - Represents a locality (town, city, or place).  \n * `POSTAL_CODE` - Represents a postal code area.  \n * `STREET` - Represents a street, or a section of a street.  \n * `EXACT_ADDRESS` - An address that is contained exactly in the geocoding data.  \n * `INTERPOLATED_ADDRESS` - An address that was interpolated from an address range.  \n * `UNSPECIFIED` - Fallback value to be substituted for enumeration values which were added in an API version that is newer than the request version. When using the current API, this value will never be returned.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.xlocate.LocationType",
      "enum" : [ "LOCALITY", "POSTAL_CODE", "STREET", "EXACT_ADDRESS", "INTERPOLATED_ADDRESS", "UNSPECIFIED" ],
      "x-ms-enum" : {
        "name" : "LocationType",
        "modelAsString" : false
      }
    },
    "LocationsBulkResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "properties" : {
          "responseItems" : {
            "type" : "array",
            "items" : {
              "description" : "List of search results corresponding to the list of input addresses to search.",
              "$ref" : "#/definitions/LocationsBulkResponseItem"
            }
          }
        },
        "description" : "Response type for bulk geocoding requests.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xlocate.LocationsBulkResponse"
      } ],
      "x-discriminator-value" : "LocationsBulkResponse",
      "x-ms-discriminator-value" : "LocationsBulkResponse"
    },
    "LocationsBulkResponseItem" : {
      "type" : "object",
      "properties" : {
        "results" : {
          "type" : "array",
          "items" : {
            "description" : "The individual results corresponding to one input object, ordered by relevance. May be empty if the input could not be matched with the available map data.",
            "$ref" : "#/definitions/SearchLocationsResult"
          }
        },
        "searchException" : {
          "description" : "Exception that occurred while searching, if any.",
          "$ref" : "#/definitions/SuppressedXServerException"
        }
      },
      "description" : "The result of one element of a bulk search: either a list of SearchLocationsResults, or an exception if one was thrown.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xlocate.LocationsBulkResponseItem"
    },
    "LocationsResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "properties" : {
          "results" : {
            "type" : "array",
            "items" : {
              "description" : "The individual results for the request, ordered by relevance. May be empty if the request could not be matched with the available map data.",
              "$ref" : "#/definitions/SearchLocationsResult"
            }
          }
        },
        "description" : "Response type for geocoding requests.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xlocate.LocationsResponse"
      } ],
      "x-discriminator-value" : "LocationsResponse",
      "x-ms-discriminator-value" : "LocationsResponse"
    },
    "Maneuver" : {
      "type" : "object",
      "properties" : {
        "uTurnCost" : {
          "description" : "The additional cost for U-turns when the routing type CONVENTIONAL is used. Because of turning bans in the road network U-turns have to be considered. However, the U-turn is usually not the best alternative: in most cases it is better to accept a short detour instead (e.g. drive around the block). With the parameter uTurnCost the trade-off between U-turn and detour can be adjusted.",
          "$ref" : "#/definitions/MathematicalCost"
        },
        "highPerformanceRoutingUTurnCost" : {
          "description" : "The additional cost for U-turns when the routing type HIGH\\_PERFORMANCE\\_ROUTING is used. The value of this paramer is used for the creation of high-performance routing networks and their selection for uses in xdima or xroute. For conventional routing the default uTurnCost is 5000, however for high-performance routing we recommend a uTurnCost of 500, hence the additional parameter to use the default values for conventional routing and high-performance routing seamlessly.",
          "$ref" : "#/definitions/MathematicalCost"
        },
        "considerTurningBans" : {
          "type" : "boolean",
          "description" : "The consideration of turning bans."
        },
        "useFastTurningBanHeuristic" : {
          "type" : "boolean",
          "description" : "The fast turning ban heuristic is used by default. This heuristic can cause in rare cases suboptimal routes because then driving in both directions of roads is not always considered by the algorithm. Switching off the heuristic by setting this attribute to false yields better routes but can increase the runtime of the routing algorithm."
        },
        "intersectionTurnCosts" : {
          "description" : "The additional cost for all kinds of intersection",
          "$ref" : "#/definitions/IntersectionTurnCosts"
        }
      },
      "description" : "Defines the parameters that control how special maneuvers (turns) affect the route calculation.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.routingprofile.Maneuver"
    },
    "ManeuverEvent" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RouteEvent"
      }, {
        "type" : "object",
        "properties" : {
          "maneuverType" : {
            "description" : "The high-level type of the current maneuver, e.g. turning or entering / exiting a highway.",
            "$ref" : "#/definitions/ManeuverType"
          },
          "relativeDirection" : {
            "description" : "The direction of the outgoing road relative to continuing in the same direction as the incoming road (clockwise).",
            "$ref" : "#/definitions/RelativeDirection"
          },
          "absoluteDirection" : {
            "description" : "The absolute direction of the outgoing road (clockwise). North represents 0 degrees.",
            "$ref" : "#/definitions/AbsoluteDirectionInteger"
          },
          "directionDescription" : {
            "type" : "string",
            "description" : "A descriptive text for the current maneuver. The language can be specified by profile.RequestProfile.userLanguage. The profile.RequestProfile.mapLanguage will not be considered, geographical names such as road names are always given in the local language."
          },
          "directionDescriptionLanguage" : {
            "description" : "The language of the direction description. It is only populated if different from the requested profile.RequestProfile.userLanguage.",
            "$ref" : "#/definitions/LanguageCode"
          },
          "roadAhead" : {
            "description" : "The description of the road to which the current maneuver finally leads. This is not necessarily the name of the road segment right after the maneuver. Especially when exiting a highway there are ramps or distributor roads which do not have a description. This field is not present if there is no road description available (usually for the very last maneuver).",
            "$ref" : "#/definitions/RoadDescriptor"
          },
          "directionSignText" : {
            "type" : "string",
            "description" : "The city names and road numbers on a signpost at the current location to follow for the current maneuver. Empty if no signpost is present or the data is not available."
          },
          "exitNumber" : {
            "type" : "string",
            "description" : "The number of an exit or interchange of a highway or a freeway-like road. Only present if the maneuver type is CHANGE or EXIT. Empty if the data does not contain an exit number."
          },
          "exitName" : {
            "type" : "string",
            "description" : "The name of an exit or interchange of a highway or a freeway-like road. Only present if the maneuver type is CHANGE or EXIT. Empty if the data does not contain an exit name."
          },
          "roundaboutExit" : {
            "description" : "The exit number at a roundabout. Only drivable roads are counted. Only present if the maneuver type is TAKE\\_ROUNDABOUT.",
            "$ref" : "#/definitions/PositiveInteger"
          },
          "combinedTransportName" : {
            "type" : "string",
            "description" : "The name of the combined transport to take a the current location. Only present if the maneuver type is TAKE\\_COMBINED\\_TRANSPORT."
          },
          "combinedTransportType" : {
            "description" : "The type of the combined transport to take a the current location. Only present if the maneuver type is TAKE\\_COMBINED\\_TRANSPORT.",
            "$ref" : "#/definitions/CombinedTransportType"
          },
          "crossingRoadName" : {
            "type" : "string",
            "description" : "The name of the crossing road at which a U-turn has to be made. Only present if the maneuver type is MAKE\\_U\\_TURN and if the U-turn takes place at a crossing."
          }
        },
        "description" : "This event provides directions for the driver. A single event gives information on the maneuver to execute. The profile.RequestProfile.mapLanguage will not be considered, geographical names such as road names are always given in the local language.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.ManeuverEvent"
      } ],
      "x-discriminator-value" : "ManeuverEvent",
      "x-ms-discriminator-value" : "ManeuverEvent"
    },
    "ManeuverType" : {
      "type" : "string",
      "description" : "Describes the type of maneuver to execute.  \n * `START` - Denotes the departure at an OnRoadWaypoint.  \n * `START_LEFT` - Denotes the departure at an OffRoadWaypoint to begin the route to the left.  \n * `START_RIGHT` - Denotes the departure at an OffRoadWaypoint to begin the route to the right.  \n * `ARRIVE` - Denotes the arrival at an OnRoadWaypoint.  \n * `ARRIVE_LEFT` - Denotes the arrival at an OffRoadWaypoint if the waypoint is on the left.  \n * `ARRIVE_RIGHT` - Denotes the arrival at an OffRoadWaypoint if the waypoint is on the right.  \n * `CONTINUE` - Indicates to follow the current road. Usually such a maneuver occurs when the road attributation changes although the road goes straight.  \n * `KEEP_STRAIGHT` - Indicates to stay on the straight lane. This is usually in fork-shaped intersections with more than two spikes.  \n * `KEEP_LEFT` - Indicates to keep left or to take the left lanee. This usually occurs in Y-shaped intersections.  \n * `KEEP_RIGHT` - Indicates to keep right or to take the right lane. This usually occurs in Y-shaped intersections.  \n * `TURN_HALF_LEFT` - Indicates to turn half left at a crossing where at least one additional trailing road exists. Usually this occurs at T- or X-shaped crossings on urban or country roads. Even if the name of the turning road does not change a maneuver will be created.  \n * `TURN_LEFT` - Indicates to turn left at a crossing where at least one additional trailing road exists. Usually this occurs at T- or X-shaped crossings on urban or country roads. Even if the name of the turning road does not change a maneuver will be created.  \n * `TURN_SHARP_LEFT` - Indicates to turn sharp left at a crossing where at least one additional trailing road exists. Usually this occurs at T- or X-shaped crossings on urban or country roads. Even if the name of the turning road does not change a maneuver will be created.  \n * `TURN_HALF_RIGHT` - Indicates to turn half right at a crossing where at least one additional trailing road exists. Usually this occurs at T- or X-shaped crossings on urban or country roads. Even if the name of the turning road does not change a maneuver will be created.  \n * `TURN_RIGHT` - Indicates to turn right at a crossing where at least one additional trailing road exists. Usually this occurs at T- or X-shaped crossings on urban or country roads. Even if the name of the turning road does not change a maneuver will be created.  \n * `TURN_SHARP_RIGHT` - Indicates to turn sharp right at a crossing where at least one additional trailing road exists. Usually this occurs at T- or X-shaped crossings on urban or country roads. Even if the name of the turning road does not change a maneuver will be created.  \n * `MAKE_U_TURN` - Indicates to make a U-turn. Either at the same road or at structurally separated roads. The ManeuverEvent.relativeDirection indicates whether to turn left or right.  \n * `TAKE_ROUNDABOUT_LEFT` - Indicates to enter a roundabout to the left and leave it at the given roundaboutExit. Only drivable roads of the roundabout are counted.  \n * `TAKE_ROUNDABOUT_RIGHT` - Indicates to enter a roundabout to the right and leave it at the given roundaboutExit. Only drivable roads of the roundabout are counted.  \n * `TAKE_COMBINED_TRANSPORT` - Indicates to take a railferry or a ferryboat. There is no direction available in this case.  \n * `ENTER` - Indicates to enter a highway/freeway/major road straight.  \n * `ENTER_LEFT` - Indicates to enter a highway/freeway/major road to the left.  \n * `ENTER_RIGHT` - Indicates to enter a highway/freeway/major road to the right.  \n * `EXIT` - Indicates to leave a highway/freeway/major road straight.  \n * `EXIT_LEFT` - Indicates to leave a highway/freeway/major road to the left.  \n * `EXIT_RIGHT` - Indicates to leave a highway/freeway/major road to the right.  \n * `CHANGE` - Indicates to change straight to another highway/freeway at an interchange.  \n * `CHANGE_LEFT` - Indicates to change to the left to another highway/freeway at an interchange.  \n * `CHANGE_RIGHT` - Indicates to change to the right to another highway/freeway at an interchange.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.xroute.ManeuverType",
      "enum" : [ "START", "START_LEFT", "START_RIGHT", "ARRIVE", "ARRIVE_LEFT", "ARRIVE_RIGHT", "CONTINUE", "KEEP_STRAIGHT", "KEEP_LEFT", "KEEP_RIGHT", "TURN_HALF_LEFT", "TURN_LEFT", "TURN_SHARP_LEFT", "TURN_HALF_RIGHT", "TURN_RIGHT", "TURN_SHARP_RIGHT", "MAKE_U_TURN", "TAKE_ROUNDABOUT_LEFT", "TAKE_ROUNDABOUT_RIGHT", "TAKE_COMBINED_TRANSPORT", "ENTER", "ENTER_LEFT", "ENTER_RIGHT", "EXIT", "EXIT_LEFT", "EXIT_RIGHT", "CHANGE", "CHANGE_LEFT", "CHANGE_RIGHT" ],
      "x-ms-enum" : {
        "name" : "ManeuverType",
        "modelAsString" : false
      }
    },
    "ManipulateRouteWaypoint" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InputWaypoint"
      }, {
        "type" : "object",
        "required" : [ "coordinate", "radius" ],
        "properties" : {
          "coordinate" : {
            "description" : "The coordinate that the route shall pass by.",
            "$ref" : "#/definitions/Coordinate"
          },
          "radius" : {
            "description" : "A radius that specifies how close the route shall pass by the specified coordinate. This radius refers to the distance on the road network in meters.",
            "type" : "number"
          }
        },
        "description" : "Specifies an input waypoint in order to manipulate the course of the route. There is no output waypoint and there is no leg that ends at this waypoint. The route passes near the specified coordinate. This waypoint cannot be used as first or last input waypoint.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.ManipulateRouteWaypoint"
      } ],
      "x-discriminator-value" : "ManipulateRouteWaypoint",
      "x-ms-discriminator-value" : "ManipulateRouteWaypoint"
    },
    "MapDescription" : {
      "type" : "object",
      "properties" : {
        "displayName" : {
          "type" : "string",
          "description" : "The display name of the map, e.g. PTV Europe City Map Premium 2017.1H."
        },
        "providerInformation" : {
          "type" : "string",
          "description" : "Display information on the data providers of the map. This string consists of a comma-separated list of pairs of data provider name and provider version number, e.g. TomTom 2016.12. The string format can be changed at any time, it is for display purposes only. In order to obtain the provider names and data versions separately, use the entity RegionDescription."
        },
        "detailLevel" : {
          "description" : "The detail level of the map. According to this level, some data may not be available.",
          "$ref" : "#/definitions/MapDetailLevel"
        },
        "copyright" : {
          "description" : "The text fragments of the copyright text to be displayed on maps.",
          "$ref" : "#/definitions/Copyright"
        },
        "dataCompatibilityVersion" : {
          "description" : "The data compatibility version of the map. An exception is thrown if the stored profile defined in the request doesn't contain the same dataCompatibilityVersion. See Profile & Map Versions for details.",
          "$ref" : "#/definitions/PositiveInteger"
        }
      },
      "description" : "This type holds meta information on the installed map.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.MapDescription"
    },
    "MapDetailLevel" : {
      "type" : "string",
      "description" : "Specifies the detail level of a map.  \n * `DETAILED` - Full map coverage and functionality according to PTVs current state of technology and coverage status by the data supplier.  \n * `EXTRACTED` - Thinned out street network (less important streets are omitted), full town coverage and search functionality, street and house number search are not possible.  \n * `TRANSIT` - Only major road network, reduced town coverage, street and house number search are not possible, town search is only possible for included towns.  \n * `MIXED` - The map is composed of countries at different detail levels. Only used for the complete map, not for a country or a subdivision.  \n * `UNSPECIFIED` - The detail level is unknown. This is probably the case when the map version is newer than the xServer version and contains unsupported data.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.xruntime.MapDetailLevel",
      "enum" : [ "DETAILED", "EXTRACTED", "TRANSIT", "MIXED", "UNSPECIFIED" ],
      "x-ms-enum" : {
        "name" : "MapDetailLevel",
        "modelAsString" : false
      }
    },
    "MapFeature" : {
      "type" : "object",
      "required" : [ "themeId" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "The ID of the feature, if present."
        },
        "referenceCoordinate" : {
          "description" : "The reference point of the road segment in real world coordinates.",
          "$ref" : "#/definitions/Coordinate"
        },
        "referencePixelPoint" : {
          "description" : "The reference point of the road segment in pixel coordinates.",
          "$ref" : "#/definitions/PixelPoint"
        },
        "pixelBoundingBox" : {
          "description" : "The bounding box of the icon(s) in pixel coordinates. Empty if there is no icon.",
          "$ref" : "#/definitions/PixelBoundingBox"
        },
        "iconReference" : {
          "type" : "string",
          "description" : "The icon reference useful to request the icon through the xRuntime service."
        },
        "themeId" : {
          "description" : "The ID of the Feature Layer theme to which this feature belongs to.",
          "$ref" : "#/definitions/ThemeId"
        },
        "attributes" : {
          "type" : "array",
          "items" : {
            "description" : "The list of attributes of a segment. For each attribute its type (key) and value is provided via key-value pairs. See the documentation of the layer-specific attributes for more information on the type and the range of available attributes.",
            "$ref" : "#/definitions/KeyValuePair"
          }
        }
      },
      "description" : "Contains all Feature Layer attributes of a road segment rendered in the map.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xmap.Feature"
    },
    "MapFeatures" : {
      "type" : "object",
      "properties" : {
        "featureLayerThemes" : {
          "type" : "array",
          "items" : {
            "description" : "List of the available Feature Layer themes.",
            "$ref" : "#/definitions/FeatureLayerTheme"
          }
        },
        "directionDescriptionLanguages" : {
          "type" : "array",
          "items" : {
            "description" : "The languages available for the xroute.ManeuverEvent.directionDescription of a maneuver.",
            "$ref" : "#/definitions/Language"
          }
        },
        "tollFeatures" : {
          "description" : "Information about the toll features that are supported by the map.",
          "$ref" : "#/definitions/TollFeatures"
        }
      },
      "description" : "The list of features available or licensed for the map. An available feature might not be available for all countries. A feature is available for the map if it is available in at least one country, see RegionFeatures.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.MapFeatures"
    },
    "MapMatchingCalculationMode" : {
      "type" : "string",
      "description" : "Enumeration to define the calculation behaviour of the algorithm, i.e. if the focus of calculation is on performance, quality or both.  \n * `PERFORMANCE` - The algorithm's focus is on performance. This means to take into account a higher count of failed matches and in the case of track matching that the matched track may be split into several paths.  \n * `STANDARD` - The algorithm chooses a standard trade-off between quality and performance.  \n * `QUALITY` - The algorithm's focus is on high solution quality. This means that as much as possible of the input positions are matched and taken into account. Though the processing time of the request can be high.  \n * `CUSTOM` - The algorithm's focus is adapted to the customer's needs. It is necessary to define the MatchTrackOptions.customCalculationModeConfiguration or MatchPositionsOptions.customCalculationModeConfiguration accordingly.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.xmatch.CalculationMode",
      "enum" : [ "PERFORMANCE", "STANDARD", "QUALITY", "CUSTOM" ],
      "x-ms-enum" : {
        "name" : "MapMatchingCalculationMode",
        "modelAsString" : false
      }
    },
    "MapOptions" : {
      "type" : "object",
      "properties" : {
        "timeConsideration" : {
          "description" : "Specifies how to evaluate data which contain time restrictions. For the use cases see time consideration. If the object is NULL, all data which have time restrictions are not considered. For some scenarios a reference time is needed to match properties with a time domain against this reference time. If for this time no time zone is defined, i.e. it represents a local time, some exposed map locations are checked for their time zone offsets. If a time zone cannot be determined for such a location, this location is not taken into further consideration. So, in a first step a set of locations with calculated time zones is determined. If this set contains no elements, an exception is thrown. When the time zones differ for some locations, then the time zone containing most locations is used and a result limitation is added to the result. If all locations are in the same time zone, then this time zone is used and the result is calculated as usual.",
          "$ref" : "#/definitions/TimeConsideration"
        },
        "contentSnapshotId" : {
          "type" : "string",
          "description" : "Specifies the content snapshot to use. If no snapshot ID is set, the most recent content is used."
        },
        "showOnlyRelevantByTime" : {
          "type" : "boolean",
          "description" : "Specifies if the map show all attributes regardless of referenceTime (default), or only the attributes which are relevant for this referenceTime. For further details, see Relevance of Feature Layer attributes."
        },
        "layers" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "description" : "Specifies a list of layers which will be displayed on the map. If this parameter is specified, layers enabled in the stored profile are ignored. These layers can be the base layers `labels`, `transport`, and `background`, or any of the supported Feature Layer themes such as `PTV_TruckAttributes`. If this parameter is not present, the layers defined by the stored profile are displayed. For more information see Integration of custom data."
          }
        },
        "preferredRouteTypes" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "description" : "The road networks to be preferred by the routing algorithm as a comma-separated list (only if the Feature Layer PTV\\_PreferredRoutes is enabled). The available types can be requested through the xRuntime service and are documented in the manual as layer-specific properties of the Feature Layer PTV\\_PreferredRoutes. If this parameter is not present, all types of PTV\\_PreferredRoutes are displayed."
          }
        },
        "showCopyright" : {
          "type" : "boolean",
          "description" : "If showCopyright is true then it shows the copyright text in the lower right corner of the image. If showCopyright is false then no copyright text is shown."
        },
        "drawIcons" : {
          "type" : "boolean",
          "description" : "Specifies if the Feature Layer icons have to be drawn on the map."
        }
      },
      "description" : "Configures further parameters of the map.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xmap.MapOptions"
    },
    "MapRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "required" : [ "mapSection" ],
        "properties" : {
          "mapSection" : {
            "description" : "Map section to be rendered.",
            "$ref" : "#/definitions/MapSection"
          },
          "mapOptions" : {
            "description" : "Map options not contained in the profile.",
            "$ref" : "#/definitions/MapOptions"
          },
          "imageOptions" : {
            "description" : "Options of the rendered image.",
            "$ref" : "#/definitions/ImageOptions"
          },
          "resultFields" : {
            "description" : "Options to configure the result fields available in the response.",
            "$ref" : "#/definitions/RenderingResultFields"
          }
        },
        "description" : "Specifies the map image to be rendered.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xmap.MapRequest"
      } ],
      "x-discriminator-value" : "MapRequest",
      "x-ms-discriminator-value" : "MapRequest"
    },
    "MapResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "required" : [ "bounds", "zoom" ],
        "properties" : {
          "image" : {
            "type" : "string",
            "format" : "byte",
            "description" : "The image as a byte array if requested by ResultFields.image."
          },
          "zoom" : {
            "description" : "The zoom level of the map image.",
            "$ref" : "#/definitions/Zoom"
          },
          "bounds" : {
            "description" : "Visible section of the rendered map images.",
            "$ref" : "#/definitions/Bounds"
          },
          "features" : {
            "type" : "array",
            "items" : {
              "description" : "The features of all enabled Feature Layer themes rendered in the map, if requested by ResultFields.featureThemeIds.",
              "$ref" : "#/definitions/MapFeature"
            }
          }
        },
        "description" : "Contains the result of a map request, specifically the map image(s).\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xmap.MapResponse"
      } ],
      "x-discriminator-value" : "MapResponse",
      "x-ms-discriminator-value" : "MapResponse"
    },
    "MapSection" : {
      "type" : "object",
      "required" : [ "$type" ],
      "discriminator" : "$type",
      "properties" : {
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "Abstract base type for the map section to be rendered. A map section represents the part of a map which is visible to the user. It can be defined in multiple ways by several derived types. Further details concerning the generation of a map image can be found in here.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xmap.MapSection"
    },
    "MapSectionByBounds" : {
      "allOf" : [ {
        "$ref" : "#/definitions/MapSection"
      }, {
        "type" : "object",
        "required" : [ "bounds" ],
        "properties" : {
          "bounds" : {
            "description" : "The bounds of the rendered map section, their coordinate format is specified by RequestBase.coordinateFormat. The bounds will be extended either in width or height in order to guarantee a complete filling of the image without distortion.",
            "$ref" : "#/definitions/Bounds"
          }
        },
        "description" : "The required map section is described by its bounds. The map content is always rendered without distortion, even if bounds and image size have a different aspect ratio. Further details can be found in the Generating a Map Image description.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xmap.MapSectionByBounds"
      } ],
      "x-discriminator-value" : "MapSectionByBounds",
      "x-ms-discriminator-value" : "MapSectionByBounds"
    },
    "MapSectionByCenter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/MapSection"
      }, {
        "type" : "object",
        "required" : [ "centerCoordinate", "zoom" ],
        "properties" : {
          "centerCoordinate" : {
            "description" : "The coordinate of the center of the map, its coordinate format is specified by RequestBase.coordinateFormat.",
            "$ref" : "#/definitions/Coordinate"
          },
          "zoom" : {
            "description" : "The zoom into the map. This value may be fractional.",
            "$ref" : "#/definitions/Zoom"
          }
        },
        "description" : "The required map section is described by its center coordinate and its zooming. The zooming value can be set continuously. Further details can be found in the Generating a Map Image description.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xmap.MapSectionByCenter"
      } ],
      "x-discriminator-value" : "MapSectionByCenter",
      "x-ms-discriminator-value" : "MapSectionByCenter"
    },
    "MapSectionByTileKey" : {
      "allOf" : [ {
        "$ref" : "#/definitions/MapSection"
      }, {
        "type" : "object",
        "required" : [ "x", "y", "zoomLevel" ],
        "properties" : {
          "zoomLevel" : {
            "description" : "The zoom level according the specifications in Map Tile API.",
            "$ref" : "#/definitions/ZoomLevel"
          },
          "x" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "The tile's horizontal index within its zoom level."
          },
          "y" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "The tile's vertical index within its zoom level."
          }
        },
        "description" : "The required map section is described by its tile key. Tiles are addressed by zoom level, x as the horizontal and y as the vertical index. The tile key defines the area to be drawn and is independent of the coordinate format given in service.RequestBase.coordinateFormat. Further details can be found in the Map Tile API description and Generating a Map Image description. Because the tile key defines directly the area to be drawn, the coordinate format given in RequestBase.coordinateFormat is ignored for the map section.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xmap.MapSectionByTileKey"
      } ],
      "x-discriminator-value" : "MapSectionByTileKey",
      "x-ms-discriminator-value" : "MapSectionByTileKey"
    },
    "MapSegment" : {
      "type" : "object",
      "required" : [ "type" ],
      "properties" : {
        "type" : {
          "description" : "A segment may have different types, e.g. it may be a \"normal\" segment between two network nodes, a \"link segment\", a virtual segment which represents a border crossing or a waiting time, or a combined transport segment.",
          "$ref" : "#/definitions/SegmentType"
        },
        "polyline" : {
          "description" : "The polyline of the segment. This polyline consists of all coordinates representing the segment and can be used to draw the segment into a map. Not available for segments of type SegmentType.NOT\\_DRIVING.\r\n\r\nThe polyline is returned in the direction of traffic in the case of one-way.",
          "$ref" : "#/definitions/EncodedGeometry"
        },
        "descriptors" : {
          "description" : "Attributes which basically describe the segment such as road name and number.",
          "$ref" : "#/definitions/SegmentDescriptors"
        },
        "combinedTransport" : {
          "description" : "Attributes which describe the combined transport this segment represents. Available only for segments of type SegmentType.COMBINED\\_TRANSPORT.",
          "$ref" : "#/definitions/CombinedTransportAttributes"
        },
        "id" : {
          "description" : "The internal ID of the segment. Could then be used, for example, to create a FeatureLayer or calculate a route passing through a combined transport.",
          "$ref" : "#/definitions/SegmentId"
        }
      },
      "description" : "A segment on the map. It represents a geographic location on a map, specified by its segment-id and may contain a polyline representation and additional descriptors like road name and number or combined transport attributes .\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.MapSegment"
    },
    "MatchDetail" : {
      "type" : "string",
      "description" : "Describing the result of a match operation for a single position.  \n * `MATCH_SUCCESSFUL` - The position was matched successfully.  \n * `MATCH_FAILED` - The position could not be matched.  \n * `NOT_CONSIDERED` - The position was not considered. This can only occur for track matching and not for position matching.  \n * `UNSPECIFIED` - Fallback value to be substituted for enumeration values which were added in an API version that is newer than the request version. When using the current API, this value will never be returned.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.xmatch.MatchDetail",
      "enum" : [ "MATCH_SUCCESSFUL", "MATCH_FAILED", "NOT_CONSIDERED", "UNSPECIFIED" ],
      "x-ms-enum" : {
        "name" : "MatchDetail",
        "modelAsString" : false
      }
    },
    "MatchPositionsOptions" : {
      "type" : "object",
      "properties" : {
        "calculationMode" : {
          "description" : "Defines the calculation mode of the position matching algorithm.",
          "$ref" : "#/definitions/MapMatchingCalculationMode"
        },
        "customCalculationModeConfiguration" : {
          "description" : "Defines a specific configuration for calculation mode CUSTOM in an encoded form.",
          "$ref" : "#/definitions/EncodedContent"
        }
      },
      "description" : "Allows to influence the position matching algorithm.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xmatch.MatchPositionsOptions"
    },
    "MatchPositionsRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "properties" : {
          "positions" : {
            "type" : "array",
            "items" : {
              "description" : "The positions to be matched (independent of each other).",
              "$ref" : "#/definitions/Position"
            }
          },
          "matchPositionsOptions" : {
            "description" : "Allows to influence the position matching algorithm.",
            "$ref" : "#/definitions/MatchPositionsOptions"
          }
        },
        "description" : "Request to match unrelated positions on a map.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xmatch.MatchPositionsRequest"
      } ],
      "x-discriminator-value" : "MatchPositionsRequest",
      "x-ms-discriminator-value" : "MatchPositionsRequest"
    },
    "MatchQuality" : {
      "type" : "object",
      "properties" : {
        "totalScore" : {
          "description" : "Indicates the overall match quality for a geocoding request. 100 (percent) represents a perfect match between the input and the result.",
          "$ref" : "#/definitions/Percent"
        },
        "addressScores" : {
          "description" : "The respective match qualities for each field of the result Address.",
          "$ref" : "#/definitions/AddressScores"
        },
        "distance" : {
          "description" : "The spatial distance between the result and the input coordinate of a reverse geocoding request.",
          "type" : "number"
        }
      },
      "description" : "Indicates how well a result matches the search request.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xlocate.MatchQuality"
    },
    "MatchTrackOptions" : {
      "type" : "object",
      "properties" : {
        "calculationMode" : {
          "description" : "Defines the calculation mode of the track matching algorithm.",
          "$ref" : "#/definitions/MapMatchingCalculationMode"
        },
        "customCalculationModeConfiguration" : {
          "description" : "Defines a specific configuration for calculation mode CUSTOM in an encoded form.",
          "$ref" : "#/definitions/EncodedContent"
        }
      },
      "description" : "Allows to influence the track matching algorithm.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xmatch.MatchTrackOptions"
    },
    "MatchTrackRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "properties" : {
          "trackPositions" : {
            "type" : "array",
            "items" : {
              "description" : "The positions to be matched to a track (ordered). --",
              "$ref" : "#/definitions/TrackPosition"
            }
          },
          "resultFields" : {
            "description" : "Specifies which fields of the TrackResponse shall be returned.",
            "$ref" : "#/definitions/MatchTrackResultFields"
          },
          "matchTrackOptions" : {
            "description" : "Allows to influence the track matching algorithm.",
            "$ref" : "#/definitions/MatchTrackOptions"
          }
        },
        "description" : "Request to match positions describing a track on a map.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xmatch.MatchTrackRequest"
      } ],
      "x-discriminator-value" : "MatchTrackRequest",
      "x-ms-discriminator-value" : "MatchTrackRequest"
    },
    "MatchTrackResultFields" : {
      "type" : "object",
      "properties" : {
        "matchedPaths" : {
          "type" : "boolean",
          "description" : "Specifies if the TrackResponse.matchedPaths shall be returned for the track."
        },
        "geometry" : {
          "type" : "boolean",
          "description" : "Specifies if the TrackResponse.geometry shall be returned for the track."
        },
        "matchedTrackPositions" : {
          "type" : "boolean",
          "description" : "Specifies if the TrackResponse.matchedTrackPositions shall be returned for the track."
        },
        "encodedPath" : {
          "type" : "boolean",
          "description" : "Specifies if the MatchedPath.encodedPath shall be returned."
        }
      },
      "description" : "Request to match positions on a map which belong to a track.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xmatch.MatchTrackResultFields"
    },
    "MatchedPath" : {
      "type" : "object",
      "required" : [ "distance" ],
      "properties" : {
        "distance" : {
          "description" : "The distance of the complete path. It is the sum of distances of all TrackResponse.matchedPaths and hence is a whole number without decimal places.",
          "type" : "number"
        },
        "encodedPath" : {
          "description" : "Encoded string describing a complete track. Use this string as an input of a route request to calculate routing related information like toll prices or emissions. It is available only if the encodedPath is requested by MatchTrackResultFields.encodedPath.",
          "$ref" : "#/definitions/EncodedContent"
        },
        "startTrackPositionIndex" : {
          "description" : "The index in the list of TrackResponse.matchedTrackPositions of the start position of this path. It is available only if the list of matchedTrackPositions is requested by MatchTrackResultFields.matchedTrackPositions.",
          "$ref" : "#/definitions/Index"
        },
        "endTrackPositionIndex" : {
          "description" : "The index in the list of TrackResponse.matchedTrackPositions of the end position of this path. It is available only if the list of matchedTrackPositions is requested by MatchTrackResultFields.matchedTrackPositions.",
          "$ref" : "#/definitions/Index"
        }
      },
      "description" : "Detailed information about a continuous part of a matched track.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xmatch.MatchedPath"
    },
    "MatchedPosition" : {
      "type" : "object",
      "required" : [ "detail" ],
      "properties" : {
        "detail" : {
          "description" : "Gives information on the result of this match, i.e. whether the position was matched successfully or not. NOT\\_CONSIDERED will not occur here.",
          "$ref" : "#/definitions/MatchDetail"
        },
        "matchedSegment" : {
          "description" : "The segment to which the input position matches. It is available only if MatchedPosition.detail is MATCH\\_SUCCESSFUL.",
          "$ref" : "#/definitions/MatchedSegment"
        },
        "matchedCoordinate" : {
          "description" : "The coordinate on the segment to which the input position matches. It is available only if MatchedPosition.detail is MATCH\\_SUCCESSFUL.",
          "$ref" : "#/definitions/Coordinate"
        },
        "quality" : {
          "description" : "Some information on the quality of the match. It is available only if MatchedPosition.detail is MATCH\\_SUCCESSFUL.",
          "$ref" : "#/definitions/PositionQuality"
        }
      },
      "description" : "Detailed information about a position matched on a map\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xmatch.MatchedPosition"
    },
    "MatchedSegment" : {
      "type" : "object",
      "required" : [ "id", "polyline" ],
      "properties" : {
        "id" : {
          "description" : "The Id of the matched segment.",
          "$ref" : "#/definitions/SegmentId"
        },
        "polyline" : {
          "description" : "The polyline of the matched segment",
          "$ref" : "#/definitions/EncodedGeometry"
        }
      },
      "description" : "Describes details on how and which segment a position was matched to.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xmatch.MatchedSegment"
    },
    "MatchedTrackPosition" : {
      "type" : "object",
      "required" : [ "detail" ],
      "properties" : {
        "detail" : {
          "description" : "Gives information on the result of this match, i.e. whether the position was matched successfully or whether the position is considered as part of the track or not.",
          "$ref" : "#/definitions/MatchDetail"
        },
        "distanceFromPreviousMatch" : {
          "description" : "The travel distance from the MatchedPosition.matchedCoordinate of the previous matched position to the MatchedPosition.matchedCoordinate of this matched position. It is available only if MatchedTrackPosition.detail is MATCH\\_SUCCESSFUL.",
          "type" : "number"
        },
        "matchedSegment" : {
          "description" : "The segment to which the input position matches. It is available only if MatchedTrackPosition.detail is MATCH\\_SUCCESSFUL.",
          "$ref" : "#/definitions/MatchedSegment"
        },
        "matchedCoordinate" : {
          "description" : "The coordinate on the segment to which the input position matches. It is available only if MatchedTrackPosition.detail is MATCH\\_SUCCESSFUL.",
          "$ref" : "#/definitions/Coordinate"
        },
        "quality" : {
          "description" : "Some information on the quality of the match. It is available only if MatchedTrackPosition.detail is MATCH\\_SUCCESSFUL.",
          "$ref" : "#/definitions/PositionQuality"
        }
      },
      "description" : "Detailed information about a position on a track matched on a map\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xmatch.MatchedTrackPosition"
    },
    "MathematicalCost" : {
      "type" : "integer",
      "format" : "int32",
      "description" : "Defines the event-specific mathematical cost. The mathematical cost is an abstract value without a physical equivalent. Hence it can be used to model user-specific needs that symbolise a certain value, mostly in order to parameterize the objective function of an optimization algorithm.\r\n\r\nRoute calculation only: There are two ways to influence the cost of a route: absolute cost, which is added if an event occurs (defined by this type), and relative cost, which means increasing the cost of a segment by a percent value (Penalty type). The routing cost depends on many parameters and is an abstract value without a physical equivalent. As a rule of thumb the cost of x represents a detour of x \\[m\\] at a speed of 36 \\[km/h\\].\r\n\r\nRange: 0 ??? value.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.MathematicalCost"
    },
    "MaximumAllowedCostGoal" : {
      "allOf" : [ {
        "$ref" : "#/definitions/OptimizationGoal"
      }, {
        "type" : "object",
        "required" : [ "costLimit" ],
        "properties" : {
          "costLimit" : {
            "description" : "Defines the maximum acceptable cost of all clusters that are part of the solution.",
            "$ref" : "#/definitions/MathematicalCost"
          }
        },
        "description" : "Defines an optimization goal based on a limit of maximum allowed cost of all clusters that are part of the solution. The optimization algorithm terminates, if the maximum allowed cost is reached.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.MaximumAllowedCostGoal"
      } ],
      "x-discriminator-value" : "MaximumAllowedCostGoal",
      "x-ms-discriminator-value" : "MaximumAllowedCostGoal"
    },
    "MaximumNumberOfCustomerStopsViolation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TourViolation"
      }, {
        "type" : "object",
        "properties" : {
          "exceedance" : {
            "description" : "Number by which the limit is exceeded.",
            "$ref" : "#/definitions/PositiveInteger"
          }
        },
        "description" : "Specifies a violation that involves a stop limit. This violation has one of the following tour event violation types: MAXIMUM\\_NUMBER\\_OF\\_CUSTOMER\\_STOPS.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.tourplanning.MaximumNumberOfCustomerStopsViolation"
      } ],
      "x-discriminator-value" : "MaximumNumberOfCustomerStopsViolation",
      "x-ms-discriminator-value" : "MaximumNumberOfCustomerStopsViolation"
    },
    "MaximumQuantityScenario" : {
      "type" : "object",
      "properties" : {
        "quantities" : {
          "type" : "array",
          "items" : {
            "description" : "List of capacities for the different quantity dimensions of goods that can be transported. The maximum length of this list is 100. That is, up to 100 different quantity dimensions (e.g. number of pallets, weight, volume, etc.) can be distinguished. Transport orders can only be transported by a vehicle with a higher (or an equal) maximum quantity in every quantity dimension of at least one quantity scenario. The length of this list has to be the same for all transport orders and all maximum quantity scenarios of all vehicles.",
            "$ref" : "#/definitions/TransportQuantityUnit"
          }
        }
      },
      "description" : "A scenario for the maximum quantities of goods of different kind.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.MaximumQuantityScenario"
    },
    "MaximumQuantityScenarioViolation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TourViolation"
      }, {
        "type" : "object",
        "properties" : {
          "exceedance" : {
            "type" : "array",
            "items" : {
              "description" : "Exceedance of the maximum quantity scenario in each dimension.",
              "$ref" : "#/definitions/TransportQuantityUnit"
            }
          }
        },
        "description" : "Specifies a violation of the maximum quantity scenario of the used vehicle. This violation has one of the following tour event violation types: MAXIMUM\\_QUANTITY\\_SCENARIO.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.tourplanning.MaximumQuantityScenarioViolation"
      } ],
      "x-discriminator-value" : "MaximumQuantityScenarioViolation",
      "x-ms-discriminator-value" : "MaximumQuantityScenarioViolation"
    },
    "MemoryStatistics" : {
      "type" : "object",
      "required" : [ "committedVirtualMemorySize", "heapCommittedMemorySize", "heapUsedMemorySize", "nonHeapCommittedMemorySize", "nonHeapUsedMemorySize", "processCPUTime" ],
      "properties" : {
        "memoryUsage" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Process assignable (private) memory in bytes.\r\n\r\n *  Windows: Heap, Stack and Private Data\r\n *  Linux: Resident Set Size (RSS)"
        },
        "committedVirtualMemorySize" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Returns the amount of virtual memory that is guaranteed to be available to the running process in bytes."
        },
        "heapCommittedMemorySize" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Returns the current memory usage of the heap that is available for object allocation."
        },
        "heapUsedMemorySize" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Returns the current memory usage of the heap that is used for object allocation."
        },
        "nonHeapCommittedMemorySize" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Returns the current memory usage of the non-heap memory that is available for object allocation."
        },
        "nonHeapUsedMemorySize" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Returns the current memory usage of the non-heap memory that is used for object allocation."
        },
        "processCPUTime" : {
          "description" : "Used CPU time of this process.",
          "$ref" : "#/definitions/Nanoseconds"
        }
      },
      "description" : "Represents memory information on Java virtual machine. These values are operating-system dependent and may contain shared memory. High values are not critical as long as the performance does not drop. It may even happen that the total memory consumption of all modules exceeds the available physical memory.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.MemoryStatistics"
    },
    "Milliseconds" : {
      "type" : "integer",
      "format" : "int32",
      "description" : "Value in \\[ms\\]. Range: 0 ??? value.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.Milliseconds"
    },
    "MinimumCoverageGoal" : {
      "allOf" : [ {
        "$ref" : "#/definitions/OptimizationGoal"
      }, {
        "type" : "object",
        "required" : [ "minimumCoverage" ],
        "properties" : {
          "minimumCoverage" : {
            "description" : "Defines the minimum acceptable percentage of covered location activities.",
            "$ref" : "#/definitions/Percent"
          }
        },
        "description" : "Defines an optimization goal based on a minimal coverage of location activities that has to be reached by the solution. The optimization algorithm terminates, if the minimum coverage of location activities is reached.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.MinimumCoverageGoal"
      } ],
      "x-discriminator-value" : "MinimumCoverageGoal",
      "x-ms-discriminator-value" : "MinimumCoverageGoal"
    },
    "MinimumDistancesFromWaypoint" : {
      "type" : "string",
      "description" : "The approximate minimum distance from each waypoint in \\[km\\]. UNBOUNDED means that for the corresponding network class no road segment is excluded by this heuristic. Pattern: UNBOUNDED|\\\\d+.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.MinimumDistancesFromWaypoint"
    },
    "MinimumRelativeImprovement" : {
      "type" : "number",
      "format" : "double",
      "description" : "Valid percentages - Range: 1.0 ??? value ??? 10.0.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.MinimumRelativeImprovement"
    },
    "Minutes" : {
      "type" : "integer",
      "format" : "int32",
      "description" : "Value in \\[min\\]. Range: 0 ??? value.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.Minutes"
    },
    "MissingParameterFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InvalidRequestFault"
      }, {
        "type" : "object",
        "required" : [ "parameter" ],
        "properties" : {
          "parameter" : {
            "type" : "string",
            "description" : "The xPath to the missing parameter."
          }
        },
        "description" : "This fault is thrown if a required parameter is missing in the request.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.MissingParameterFault"
      } ],
      "x-discriminator-value" : "MissingParameterFault",
      "x-ms-discriminator-value" : "MissingParameterFault"
    },
    "MixedLoadingProhibition" : {
      "type" : "object",
      "required" : [ "conflictingCategory1", "conflictingCategory2" ],
      "properties" : {
        "conflictingCategory1" : {
          "type" : "string",
          "description" : "An order of this category is not allowed to be on the same trip as an order of the other category. The category can be any string but it must not be empty and not the same as the other conflicting category."
        },
        "conflictingCategory2" : {
          "type" : "string",
          "description" : "An order of this category is not allowed to be on the same trip as an order of the other category. The category can be any string but it must not be empty and not the same as the other conflicting category."
        }
      },
      "description" : "There may be some orders that shall not be mixed with some other orders on one trip. For instance, it may be prohibited to load certain dangerous goods together on the same trip, such as flammable solids on the one hand and explosive substances on the other hand. A mixed loading prohibition is a pair of two conflicting categories that prohibits orders of these categories to be mixed on the same trip. The category can be specified for every order. For a vehicle, there is a flag that lets the vehicle ignore this restriction.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.MixedLoadingProhibition"
    },
    "MixedLoadingProhibitionsViolation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TourViolation"
      }, {
        "type" : "object",
        "properties" : {
          "mixedLoadingProhibitions" : {
            "type" : "array",
            "items" : {
              "description" : "These are the mixed loading prohibitions that are violated by the current service event.",
              "$ref" : "#/definitions/MixedLoadingProhibition"
            }
          }
        },
        "description" : "Specifies a violation of one or more mixed loading prohibitions, that is, two (or more) orders in a trip have conflicting categories. This violation has the following tour violation type: MIXED\\_LOADING\\_PROHIBITION.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.tourplanning.MixedLoadingProhibitionsViolation"
      } ],
      "x-discriminator-value" : "MixedLoadingProhibitionsViolation",
      "x-ms-discriminator-value" : "MixedLoadingProhibitionsViolation"
    },
    "ModuleInstance" : {
      "type" : "object",
      "required" : [ "inUse", "numberOfRestarts", "uptime", "useCounter" ],
      "properties" : {
        "instanceId" : {
          "type" : "string",
          "description" : "Instance ID. Usually m0001, m0002, ..."
        },
        "services" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "description" : "Services provided by this instance."
          }
        },
        "uptime" : {
          "description" : "Uptime of this instance.",
          "$ref" : "#/definitions/Nanoseconds"
        },
        "numberOfRestarts" : {
          "description" : "Number of restarts.",
          "$ref" : "#/definitions/NonNegativeInteger"
        },
        "inUse" : {
          "type" : "boolean",
          "description" : "Is this instance currently in use?"
        },
        "useCounter" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "How often has this instance been used since last restart?"
        },
        "memoryStatistics" : {
          "description" : "Memory statistics on this instance.",
          "$ref" : "#/definitions/MemoryStatistics"
        },
        "state" : {
          "type" : "string",
          "description" : "Current state of this instance, e.g. STARTING, RUNNING, STOPPING, TERMINATED, FAILED."
        }
      },
      "description" : "Represents a single backend instance and provides useful information.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.ModuleInstance"
    },
    "MonetaryCostOptions" : {
      "type" : "object",
      "properties" : {
        "costPerKilometer" : {
          "type" : "number",
          "format" : "double",
          "description" : "Specifies the monetary cost per kilometer.  \r\nIf no value is provided a default of 1.2 EUR or the corresponding amount in the provided currency is used."
        },
        "workingCostPerHour" : {
          "type" : "number",
          "format" : "double",
          "description" : "Specifies the monetary cost per hour. It is applied to segments of types LINK\\_SEGMENT, NETWORK\\_SEGMENT and COMBINED\\_TRANSPORT. It is not applied to segments that represent service times or breaks and rests.  \r\nIf no value is provided a default of 20.5 EUR or the corresponding amount in the provided currency is used."
        }
      },
      "description" : "Specifies parameters for calculating monetary costs of a route. The parameters are explained in more detail in the section \"Route Selection by Monetary Costs\" of the technical concept on route selection.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.routing.MonetaryCostOptions"
    },
    "MonetaryCostsReport" : {
      "type" : "object",
      "properties" : {
        "totalCost" : {
          "type" : "number",
          "format" : "double",
          "description" : "The total monetary cost of the route."
        },
        "distanceCost" : {
          "type" : "number",
          "format" : "double",
          "description" : "The distance cost based on routing.MonetaryCostOptions.costPerKilometer."
        },
        "workingTimeCost" : {
          "type" : "number",
          "format" : "double",
          "description" : "The working time cost based on routing.MonetaryCostOptions.workingCostPerHour."
        },
        "tollCost" : {
          "type" : "number",
          "format" : "double",
          "description" : "The toll cost based on the route and the vehicle."
        }
      },
      "description" : "Contains the monetary costs of a route in the specified currency.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.MonetaryCostsReport"
    },
    "MoveOrdersAction" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ChangeToursAction"
      }, {
        "type" : "object",
        "required" : [ "targetTripId" ],
        "properties" : {
          "orderIds" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "description" : "IDs of the orders to be moved."
            }
          },
          "targetTripId" : {
            "type" : "string",
            "description" : "ID of the trip to insert the orders into."
          },
          "visitInsertionPosition" : {
            "description" : "Insertion position for visit orders. Currently this should be set if and only if all referenced orders in orderIds are visit orders.",
            "$ref" : "#/definitions/InsertionPosition"
          },
          "pickupInsertionPosition" : {
            "description" : "Insertion position for pickup tasks of transport orders. Currently this should be set if and only if all referenced orders in orderIds are transport orders.",
            "$ref" : "#/definitions/InsertionPosition"
          },
          "deliveryInsertionPosition" : {
            "description" : "Insertion position for delivery tasks of transport orders. Currently this should be set if and only if all referenced orders in orderIds are transport orders.",
            "$ref" : "#/definitions/InsertionPosition"
          }
        },
        "description" : "A specific action to move orders from unplanned orders or existing trips to an existing trip. Currently, a MoveOrdersAction cannot both contain visit and transport orders. If multiple orders of a stop shall be moved, use a MoveStopsAction. All specified insertion positions refer to the trip before performing this MoveOrdersAction.\r\n\r\nThe following conditions must be fulfilled or an exception will be thrown:\r\n\r\n *  If any order referenced by orderIds is a visit order, visitInsertionPosition must be set.\r\n *  If any order referenced by orderIds is a transport order, pickupInsertionPosition and deliveryInsertionPosition must be set.\r\n *  Unless the task's insertion position is of type insertion at best position, every task must have the same site unless the site is\r\n    \r\n     *  equal to the site of the stop directly before the insertion position, or\r\n     *  equal to the site of the stop directly after the insertion position.\r\n\r\nIn case of moving an order of type OrderWithAlternativePickupDepots or OrderWithAlternativeDeliveryDepots the depot of the order can change if it is better to serve the order at a different depot.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.MoveOrdersAction"
      } ],
      "x-discriminator-value" : "MoveOrdersAction",
      "x-ms-discriminator-value" : "MoveOrdersAction"
    },
    "MoveStopsAction" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ChangeToursAction"
      }, {
        "type" : "object",
        "required" : [ "insertionPosition", "targetTripId" ],
        "properties" : {
          "stopIdentifiers" : {
            "type" : "array",
            "items" : {
              "description" : "Defines the stops to be moved.",
              "$ref" : "#/definitions/StopIdentifier"
            }
          },
          "targetTripId" : {
            "type" : "string",
            "description" : "ID of the trip to insert the stop into."
          },
          "insertionPosition" : {
            "description" : "Insertion position of the stop in the trip. InsertionAtBestPosition is not supported for this ChangeToursAction yet and its usage causes an exception.",
            "$ref" : "#/definitions/InsertionPosition"
          }
        },
        "description" : "A specific action to move consecutive stops from an existing trip to another existing trip. The stops may be moved within their original trip or to another trip. If the stops are moved to another trip, all partner tasks of tasks of the moved stops will be moved too. The insertion positions of the partner tasks in the target tour are implicitly defined. They are inserted at the closest existing stop at the according location or a new start/end depot is created. A new start/end depot may only be created if it is unambiguous, i.e. there is no other start/end depot already. For all other partner tasks, it is necessary that all their locations are already in the target trip. If the insertion position of the partner task is ambiguous, an AmbiguousInsertionPositionFault is thrown. If the stops are moved within their original trip, the partner tasks stay at their old position.\r\n\r\nIn case of moving stops that contain orders of type OrderWithAlternativePickupDepots or OrderWithAlternativeDeliveryDepots the depot of the order can change if it is better to serve the order at a different depot.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.MoveStopsAction"
      } ],
      "x-discriminator-value" : "MoveStopsAction",
      "x-ms-discriminator-value" : "MoveStopsAction"
    },
    "MoveTripsAction" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ChangeToursAction"
      }, {
        "type" : "object",
        "required" : [ "insertionPosition", "targetVehicleId" ],
        "properties" : {
          "tripIds" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "description" : "IDs of the trips to be moved. At the moment, only one trip is supported."
            }
          },
          "targetVehicleId" : {
            "type" : "string",
            "description" : "ID of the vehicle corresponding to the tour to insert the trip into or ID of an unused vehicle to move the trip onto. At the moment, only one trip is supported."
          },
          "insertionPosition" : {
            "description" : "Insertion position of the trip in the tour. If InsertionPosition is of type InsertionAtBestPosition, a trip is only moved if the target vehicle is different from the vehicle that currently serves the trip. Trips in tripIds that can not be moved to the target vehicle are not changed and are listed in a NoValidInsertionPositionFoundLimitation as objectIds.",
            "$ref" : "#/definitions/InsertionPosition"
          }
        },
        "description" : "A specific action to move a trip to a specified position in an existing tour or to an empty vehicle. The trip may be moved within its original tour or to another tour. For certain special tour structures moving a trip could cause adjacent trips to become one trip. Such MoveTripsActions are currently not supported and throw an exception.\r\n\r\nIn case of moving a trip that contains orders of type OrderWithAlternativePickupDepots or OrderWithAlternativeDeliveryDepots the depot of the order can change if it is better to serve the order at a different depot.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.MoveTripsAction"
      } ],
      "x-discriminator-value" : "MoveTripsAction",
      "x-ms-discriminator-value" : "MoveTripsAction"
    },
    "MultiCoordinateOnRoadWaypoint" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InputWaypoint"
      }, {
        "type" : "object",
        "properties" : {
          "coordinates" : {
            "type" : "array",
            "items" : {
              "description" : "Specifies the coordinates for the waypoint. At least one coordinate must be given. A route actually reaches only the nearest road of one of the given coordinates, and the coordinates are not linked to the road by a segment of type segments.SegmentType.LINK\\_SEGMENT.",
              "$ref" : "#/definitions/Coordinate"
            }
          }
        },
        "description" : "Specifies an input waypoint as a list of coordinates. It is similar to an on-road waypoint but can have multiple coordinates. For example, the destination of a route can consist of different entries to a certain parking area. The resulting route will end at one of the entries. This waypoint can be used only as first or last waypoint of a route request.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.MultiCoordinateOnRoadWaypoint"
      } ],
      "x-discriminator-value" : "MultiCoordinateOnRoadWaypoint",
      "x-ms-discriminator-value" : "MultiCoordinateOnRoadWaypoint"
    },
    "MultiDayWorkingHours" : {
      "allOf" : [ {
        "$ref" : "#/definitions/WorkingHours"
      }, {
        "type" : "object",
        "properties" : {
          "dailyRestPositions" : {
            "description" : "Indicates at which positions of a tour daily rests are planned.",
            "$ref" : "#/definitions/RestPositions"
          }
        },
        "description" : "Defines which rules regarding drivers' working hours need to be met in a multi day planning scenario.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.tourplanning.MultiDayWorkingHours"
      } ],
      "x-discriminator-value" : "MultiDayWorkingHours",
      "x-ms-discriminator-value" : "MultiDayWorkingHours"
    },
    "MultipleTravelTimesConsideration" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TimeConsideration"
      }, {
        "type" : "object",
        "required" : [ "horizon" ],
        "properties" : {
          "horizon" : {
            "description" : "Defines the horizon for this request, described by start and end date. Every calculation will be executed within this interval. The horizon is restricted to a maximum duration of 24 hours. When used in XTour, the planning horizon and the driver operating intervals must be completely contained within this horizon.",
            "$ref" : "#/definitions/StartEndInterval"
          }
        },
        "description" : "This time-consideration scenario evaluates all data which have time restrictions using several starting dates in the interval. For each point in time, the EXACT time-consideration is used to take into account the attributes. Only available for xDima xdima.CreateDistanceMatrixRequest, xData xdata.CreateHighPerformanceRoutingNetworkRequest and xdata.ListHighPerformanceRoutingNetworksRequest. For xdima.CreateAndGetDistanceMatrixRequest and all other services (rendering, routing, etc.) this mode is not available.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.timeconsideration.MultipleTravelTimesConsideration"
      } ],
      "x-discriminator-value" : "MultipleTravelTimesConsideration",
      "x-ms-discriminator-value" : "MultipleTravelTimesConsideration"
    },
    "Nanoseconds" : {
      "type" : "integer",
      "format" : "int64",
      "description" : "Value in \\[ns\\]. Range: 0 ??? value.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.Nanoseconds"
    },
    "Network" : {
      "type" : "object",
      "properties" : {
        "penaltiesByNetworkClass" : {
          "description" : "Defines the general penalty value for each network class. This is useful in order to force the routing algorithm to favor freeways over smaller roads. For more information about network classes see the type of the segment attribute network class.",
          "$ref" : "#/definitions/PenaltiesByNetworkClass"
        },
        "rampPenalty" : {
          "description" : "The penalty for each segment that is marked as a ramp. This setting affects segments which have set segments.RoadAttributes.ramp.",
          "$ref" : "#/definitions/Penalty"
        }
      },
      "description" : "Defines the parameters that concern network specific segment attributes, e.g. penalties for road segments of a certain network class.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.routingprofile.Network"
    },
    "NetworkClass" : {
      "type" : "integer",
      "format" : "int32",
      "description" : "Defines the network class of a road. The road segments are divided into eight network classes by importance of the roads they represent. The network class 0 represents the most important roads, for example highways, while road segments of network class 7 are the least important roads, for example pedestrian paths. Range: 0 ??? value ??? 7.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.NetworkClass"
    },
    "NoValidInsertionPositionsFoundLimitation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResultLimitation"
      }, {
        "type" : "object",
        "properties" : {
          "objectIds" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "description" : "IDs of the objects that could not be moved to a valid position.\r\n\r\nThe object type depends on the action type of the ChangeToursRequest:\r\n\r\n *  MoveOrdersAction: Order IDs\r\n *  MoveTripsAction: Trip IDs\r\n *  AddTripAction: Order IDs"
            }
          }
        },
        "description" : "This result limitation indicates that a request could not be properly moved for the objects listed in objectIds because no valid position was found.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.NoValidInsertionPositionsFoundLimitation"
      } ],
      "x-discriminator-value" : "NoValidInsertionPositionsFoundLimitation",
      "x-ms-discriminator-value" : "NoValidInsertionPositionsFoundLimitation"
    },
    "Node" : {
      "type" : "object",
      "required" : [ "coordinate", "type" ],
      "properties" : {
        "coordinate" : {
          "description" : "Location of the node. It never contains the z-coordinate, refer to the polyline instead to obtain the z-coordinate.",
          "$ref" : "#/definitions/Coordinate"
        },
        "type" : {
          "description" : "Type of the node (e.g. NodeType.NETWORK\\_NODE).",
          "$ref" : "#/definitions/NodeType"
        },
        "eventIndices" : {
          "type" : "array",
          "items" : {
            "description" : "The list of indices in the RouteResponse.events list containing all route events which occur at this node. An event may be present in consecutive nodes if it covers a sequence of nodes. The list is only populated if route events are requested by ResultFields.eventTypes.",
            "$ref" : "#/definitions/Index"
          }
        },
        "polylineIndex" : {
          "description" : "Index of the polyline point corresponding to this node in RouteResponse.polyline. Only available if a polyline is requested using ResultFields.polyline.",
          "$ref" : "#/definitions/Index"
        },
        "violated" : {
          "type" : "boolean",
          "description" : "If set to true, indicates that this node contains a violation for the chosen vehicle."
        }
      },
      "description" : "Represents a real or virtual node along a route. See NodeType for the possible types.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.Node"
    },
    "NodeType" : {
      "type" : "string",
      "description" : "Enumeration of the different Node types returned by a routing operation. While a NodeType.NETWORK\\_NODE is an actual node in the routing network, other virtual node types are also created. For example a NodeType.INPUT\\_NODE might represent an arbitrary user supplied InputWaypoint. A corresponding NodeType.LINK\\_NODE is then required to represent the point where the segment from the user supplied waypoint is connected to the actual routing network.  \n * `NETWORK_NODE` - Node is present in the underlying routing network.  \n * `LINK_NODE` - Virtual node on a segment in the underlying routing network to which an NodeType.INPUT\\_NODE is linked.  \n * `INPUT_NODE` - Virtual node representing a user provided input waypoint.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.xroute.NodeType",
      "enum" : [ "NETWORK_NODE", "LINK_NODE", "INPUT_NODE" ],
      "x-ms-enum" : {
        "name" : "NodeType",
        "modelAsString" : false
      }
    },
    "NonNegativeInteger" : {
      "type" : "integer",
      "format" : "int32",
      "description" : "Defines a non-negative integer value. Range: 0 ??? value.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.NonNegativeInteger"
    },
    "NumberOfNearestNeighbors" : {
      "type" : "integer",
      "format" : "int32",
      "description" : "Valid numbers of nearest neighbors - Range: 3 ??? value ??? 40.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.NumberOfNearestNeighbors"
    },
    "ObjectNotStoredLimitation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResultLimitation"
      }, {
        "type" : "object",
        "description" : "This result limitation indicates that an object could not be stored in the session storage.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.service.ObjectNotStoredLimitation"
      } ],
      "x-discriminator-value" : "ObjectNotStoredLimitation",
      "x-ms-discriminator-value" : "ObjectNotStoredLimitation"
    },
    "OffRoadRouteLocation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RouteLocation"
      }, {
        "type" : "object",
        "required" : [ "offRoadCoordinate" ],
        "properties" : {
          "offRoadCoordinate" : {
            "description" : "Specifies the coordinate off the road that the route actually reaches. If OffRoadRouteLocation.roadAccessCoordinate is not specified then this coordinate is used to determine the nearest road on the road network.\r\n\r\nWhen using the PTV xLocate service, enter the xlocate.Location.referenceCoordinate here.",
            "$ref" : "#/definitions/Coordinate"
          },
          "roadAccessCoordinate" : {
            "description" : "Specifies an optional coordinate to specify to which road the OffRoadRouteLocation.offRoadCoordinate is connected to. This is especially useful if location is not connected to the geographically closest road but to some road further away.\r\n\r\nWhen using the PTV xLocate service, enter the xlocate.Location.roadAccessCoordinate here.",
            "$ref" : "#/definitions/Coordinate"
          },
          "sideOfStreetRestriction" : {
            "description" : "Specifies how the street at which the location is located can be used. With this parameter it's possible to use the side of the street on which the OffRoadRouteLocation.offRoadCoordinate is located.\r\n\r\nWill be ignored when used with calculateReachableAreas or calculateReachableLocations.",
            "$ref" : "#/definitions/SideOfStreetRestriction"
          }
        },
        "description" : "Specifies a route location based on a coordinate that is usually located off the road network. A route actually reaches this coordinate, and the distance and the assumed travel time from that location to the road network is included in the route totals. Optionally another coordinate on the road network can be given to specify more precisely to which road the coordinate off the road shall be connected. The behavior which road will be chosen in such a case is influenced by the violations parameters. See route locations documentation for details.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.routing.OffRoadRouteLocation"
      } ],
      "x-discriminator-value" : "OffRoadRouteLocation",
      "x-ms-discriminator-value" : "OffRoadRouteLocation"
    },
    "OffRoadWaypoint" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InputWaypoint"
      }, {
        "type" : "object",
        "required" : [ "location" ],
        "properties" : {
          "location" : {
            "description" : "Specifies the route location for this waypoint. The given routing.OffRoadRouteLocation.offRoadCoordinate is part of the route polyline. A route actually reaches this coordinate and is connected to the road network by a segment of type segments.SegmentType.LINK\\_SEGMENT. The routing.OffRoadRouteLocation.roadAccessCoordinate is usually not part of the route polyline, as it is only used to find the proper road to link to.",
            "$ref" : "#/definitions/OffRoadRouteLocation"
          },
          "tourStopOptions" : {
            "description" : "The logistic information on a waypoint.",
            "$ref" : "#/definitions/TourStopOptions"
          }
        },
        "description" : "Specifies an input waypoint based on an routing.OffRoadRouteLocation. There is a corresponding Waypoint in the route response, and a route leg starts or ends at that waypoint. In case the nearest road cannot be reached due to road restrictions for the specified vehicle a result limitation will be returned. See waypoints documentation for details.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.OffRoadWaypoint"
      } ],
      "x-discriminator-value" : "OffRoadWaypoint",
      "x-ms-discriminator-value" : "OffRoadWaypoint"
    },
    "OnRoadRouteLocation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RouteLocation"
      }, {
        "type" : "object",
        "required" : [ "coordinate" ],
        "properties" : {
          "coordinate" : {
            "description" : "Specifies the coordinate which is used to determine the nearest road on the road network.\r\n\r\nWhen using the PTV xLocate service, enter the xlocate.Location.referenceCoordinate here",
            "$ref" : "#/definitions/Coordinate"
          },
          "considerAlternativeNearByRoads" : {
            "type" : "boolean",
            "description" : "If true, roads within a radius of 500 meters around the location are considered as alternative start/end points of the route. Otherwise, the route always starts/ends at the nearest road. Note that this feature is currently available only for the xRoute calculateRoute service for the first and last waypoint. If it is set to true for an intermediate xRoute via waypoint this parameter is ignored and always the nearest road is used. All other services return an exception if this parameter is set to true."
          },
          "sideOfStreetRestriction" : {
            "description" : "Specifies how the street at which the location is located can be used. With this parameter it's possible to use the side of the street on which the OnRoadRouteLocation.coordinate is located.\r\n\r\nWill be ignored when used with calculateReachableAreas or calculateReachableLocations.",
            "$ref" : "#/definitions/SideOfStreetRestriction"
          }
        },
        "description" : "Specifies a route location based on a coordinate will be treated as if it was located on the road network. The route actually reaches its link point on the road network, but usually not the given coordinate. The behavior which road will be chosen is influenced by the violations parameters. See route locations documentation for details.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.routing.OnRoadRouteLocation"
      } ],
      "x-discriminator-value" : "OnRoadRouteLocation",
      "x-ms-discriminator-value" : "OnRoadRouteLocation"
    },
    "OnRoadWaypoint" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InputWaypoint"
      }, {
        "type" : "object",
        "required" : [ "location" ],
        "properties" : {
          "location" : {
            "description" : "Specifies the route location for this waypoint. If the given routing.OnRoadRouteLocation.coordinate is off the road this location itself is not part of the route, its polyline nor the route totals. A route actually reaches only the nearest road, and the coordinate is not linked to the road by a segment of type segments.SegmentType.LINK\\_SEGMENT.",
            "$ref" : "#/definitions/OnRoadRouteLocation"
          },
          "tourStopOptions" : {
            "description" : "The logistic information on a waypoint.",
            "$ref" : "#/definitions/TourStopOptions"
          }
        },
        "description" : "Specifies an input waypoint based on an routing.OnRoadRouteLocation. There is a corresponding waypoint in the route response, and a route leg starts or ends on the nearest road. There is no segments.SegmentType.LINK\\_SEGMENT. See waypoints documentation for details.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.OnRoadWaypoint"
      } ],
      "x-discriminator-value" : "OnRoadWaypoint",
      "x-ms-discriminator-value" : "OnRoadWaypoint"
    },
    "OptimisticTimeConsideration" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TimeConsideration"
      }, {
        "type" : "object",
        "description" : "This time-consideration scenario evaluates all data which have time restrictions, by taking the most optimistic behaviour. For rendering this means that the map shows the most optimistic traffic. For routing this means that each segment of the route is evaluated by taking the most optimistic speed.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.timeconsideration.OptimisticTimeConsideration"
      } ],
      "x-discriminator-value" : "OptimisticTimeConsideration",
      "x-ms-discriminator-value" : "OptimisticTimeConsideration"
    },
    "OptimizationGoal" : {
      "type" : "object",
      "required" : [ "$type" ],
      "discriminator" : "$type",
      "properties" : {
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "Defines the goal for the optimization algorithm. If the goal is reached in a running algorithm iteration, the algorithm terminates and returns the current solution.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.OptimizationGoal"
    },
    "OptimizeStopSequenceAction" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ChangeToursAction"
      }, {
        "type" : "object",
        "properties" : {
          "tripIds" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "description" : "IDs of the trips to be optimized concerning their stop sequence."
            }
          }
        },
        "description" : "A specific action to optimize the stop sequence of trips. Keep in mind that the optimization goal is to minimize the travel and driving time of the overall tour.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.OptimizeStopSequenceAction"
      } ],
      "x-discriminator-value" : "OptimizeStopSequenceAction",
      "x-ms-discriminator-value" : "OptimizeStopSequenceAction"
    },
    "OptimizeVisitSequenceOptions" : {
      "type" : "object",
      "properties" : {
        "optimizationGoal" : {
          "description" : "Determines what attribute of the sequence to optimize for.",
          "$ref" : "#/definitions/VisitSequenceOptimizationGoal"
        }
      },
      "description" : "Additional parameters for visit sequence optimization.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.OptimizeVisitSequenceOptions"
    },
    "OptimizeVisitSequenceRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "required" : [ "distanceMode" ],
        "properties" : {
          "locations" : {
            "type" : "array",
            "items" : {
              "description" : "Set of customer locations that should be visited.",
              "$ref" : "#/definitions/ClusterPlanningLocation"
            }
          },
          "startLocationId" : {
            "type" : "string",
            "description" : "If given, the location from OptimizeVisitSequenceRequest.locations with this ID is used as the start of the tour. It can be the same as OptimizeVisitSequenceRequest.endLocationId. If not given, the algorithm can freely choose the start of the tour from the given locations."
          },
          "endLocationId" : {
            "type" : "string",
            "description" : "If given, the location from OptimizeVisitSequenceRequest.locations with this ID is used as the end of the tour. Can be the same as OptimizeVisitSequenceRequest.startLocationId. If not given, the algorithm can freely choose the end of the tour from the given locations."
          },
          "optimizeVisitSequenceOptions" : {
            "description" : "Additional parameters for visit sequence optimization.",
            "$ref" : "#/definitions/OptimizeVisitSequenceOptions"
          },
          "distanceMode" : {
            "description" : "Contains settings that specify how distances between locations are retrieved. When using direct distance the driven distances are estimated with a detour factor of 1.38 and for the duration a speed of 60 km/h is assumed. Only the following distance modes are supported: DirectDistance and ExistingDistanceMatrix.",
            "$ref" : "#/definitions/DistanceMode"
          }
        },
        "description" : "Describes a visit sequencing problem.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.OptimizeVisitSequenceRequest"
      } ],
      "x-discriminator-value" : "OptimizeVisitSequenceRequest",
      "x-ms-discriminator-value" : "OptimizeVisitSequenceRequest"
    },
    "Order" : {
      "type" : "object",
      "required" : [ "$type", "id" ],
      "discriminator" : "$type",
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "An unique ID used to identify the order."
        },
        "priority" : {
          "description" : "Priority of this order. 0 is the lowest priority, 9 the highest. This field is only considered during automatic planning if considerOrderPriorities is set. In this case every order must have an order priority set otherwise an exception is thrown - if considerOrderPriorities is set to false either every or no order may have a priority set. If the algorithm can plan all orders during automatic planning this field does not affect the result. Otherwise the algorithm considers the priorities according to the following rule: If an order cannot be planned without removing an order with higher priority, it will remain unplanned. Please keep in mind that using multiple priorities will increase the computation time of the algorithm. See technical concept Order Priorities for further details.",
          "$ref" : "#/definitions/OrderPriority"
        },
        "groupId" : {
          "type" : "string",
          "description" : "The unique identifier of an order group. The preferences that apply to orders with the same group ID are specified in the order group consideration. Order groups may be referenced in the order group IDs of a vehicle. See technical concept Order Groups for further details."
        },
        "requiredVehicleEquipment" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "description" : "List of required vehicle equipment. A vehicle can only be assigned to the order if this list is a subset of (or equal to) the vehicle's equipment."
          }
        },
        "category" : {
          "type" : "string",
          "description" : "Category of an order. To specify a category is useful if there are orders of one category that shall not be mixed with orders of another category on one trip. If two categories are mutually exclusive on a trip, this can be specified as a mixed loading prohibition. Orders of conflicting categories will not be planned together on one trip."
        },
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "Base type for orders that should be carried out in the tours. See Orders, Locations, and Stops.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.Order"
    },
    "OrderAlreadyPlannedFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InvalidTourRequestFault"
      }, {
        "type" : "object",
        "required" : [ "orderId" ],
        "properties" : {
          "orderId" : {
            "type" : "string",
            "description" : "ID of the order in the AddTripAction or InsertionPositionsForOrdersQuery that is already planned."
          }
        },
        "description" : "This fault is thrown if a AddTripAction or InsertionPositionsForOrdersQuery contains an order that is not an unplanned order.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.OrderAlreadyPlannedFault"
      } ],
      "x-discriminator-value" : "OrderAlreadyPlannedFault",
      "x-ms-discriminator-value" : "OrderAlreadyPlannedFault"
    },
    "OrderGroupConsideration" : {
      "type" : "object",
      "properties" : {
        "oneGroupPerTrip" : {
          "type" : "boolean",
          "description" : "If set to true, orders of a specific group cannot be planned together with orders of another group into a trip and orders without groupIds remain unplanned."
        },
        "oneTripPerGroup" : {
          "type" : "boolean",
          "description" : "If set to true, orders of a specific group must be planned together in one trip."
        }
      },
      "description" : "Defines strong preferences concerning order groups. They are considered in automatic planning. If these preferences are not met for an input plan or for a change tours action, they are not reported as a violation. For further information please have a look at the technical concept Order Groups. Currently, oneTripPerGroup can only be activated if oneGroupPerTrip is also activated, otherwise an exception is thrown.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.OrderGroupConsideration"
    },
    "OrderPriority" : {
      "type" : "integer",
      "format" : "int32",
      "description" : "Valid order priorities. 0 is the lowest priority, 9 the highest. - Range: 0 ??? value ??? 9.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.OrderPriority"
    },
    "OrderScoreWeight" : {
      "type" : "integer",
      "format" : "int32",
      "description" : "Valid values - Range: 1 ??? value ??? 100.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.OrderScoreWeight"
    },
    "OrderTask" : {
      "type" : "object",
      "required" : [ "orderId", "taskType" ],
      "properties" : {
        "orderId" : {
          "type" : "string",
          "description" : "The reference to the order of this task."
        },
        "taskType" : {
          "description" : "Type of task that is carried out, for example picking up an order.",
          "$ref" : "#/definitions/TaskType"
        }
      },
      "description" : "Each task of an order is carried out at a stop of a tour.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.Task"
    },
    "OrderWithAlternativeDeliveryDepots" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TransportOrder"
      }, {
        "type" : "object",
        "required" : [ "pickupLocationId" ],
        "properties" : {
          "pickupLocationId" : {
            "type" : "string",
            "description" : "ID of the location where the goods should be picked up. Only a customer site is allowed as pickup location."
          },
          "deliveryLocationIds" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "description" : "IDs of alternative depot sites where the goods should be delivered to. All delivery depots are treated equally and only one of the depots is chosen for the resulting tour. If the list is empty, all depots are considered as possible delivery locations."
            }
          }
        },
        "description" : "A specific transport order that allows the goods to be delivered to alternative depot sites.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.OrderWithAlternativeDeliveryDepots"
      } ],
      "x-discriminator-value" : "OrderWithAlternativeDeliveryDepots",
      "x-ms-discriminator-value" : "OrderWithAlternativeDeliveryDepots"
    },
    "OrderWithAlternativePickupDepots" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TransportOrder"
      }, {
        "type" : "object",
        "required" : [ "deliveryLocationId" ],
        "properties" : {
          "pickupLocationIds" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "description" : "IDs of alternative depot sites where the goods should be picked up. All pickup depots are treated equally and only one of the depots is chosen for the resulting tour. If the list is empty, all depots are considered as possible pickup locations."
            }
          },
          "deliveryLocationId" : {
            "type" : "string",
            "description" : "ID of the location where the goods should be delivered to. Only a customer site is allowed as delivery location."
          }
        },
        "description" : "A specific transport order that allows the goods to be picked up at alternative depot sites.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.OrderWithAlternativePickupDepots"
      } ],
      "x-discriminator-value" : "OrderWithAlternativePickupDepots",
      "x-ms-discriminator-value" : "OrderWithAlternativePickupDepots"
    },
    "OvernightStay" : {
      "type" : "object",
      "properties" : {
        "approximationTolerance" : {
          "description" : "Defines (in percent) how close to the optimal solution value the solver should come before exiting an iteration. For instance, compared to 10% the value of 5% means better solution at the cost of higher running time.",
          "$ref" : "#/definitions/ApproximationTolerance"
        },
        "performPreprocessingStep" : {
          "type" : "boolean",
          "description" : "Perform preprocessing to reduce the complexity of the optimization problem, for example by excluding forbidden or redundant combinations. For large problems the preprocessing itself can be very time-consuming."
        },
        "maximumNumberOfIterations" : {
          "description" : "The maximum number of iterations the solver may use to iterate on its overnight plan. A higher number might lead to a better solution at the cost of higher running time.",
          "$ref" : "#/definitions/PositiveInteger"
        },
        "numberOfNearestNeighbors" : {
          "description" : "The number of nearest neighbors used for estimating travel times between visits.",
          "$ref" : "#/definitions/PositiveInteger"
        }
      },
      "description" : "Contains parameter values for use cases in which the visit plan is calculated with overnight stays.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.clusterplanningprofile.OvernightStay"
    },
    "OvernightStayOptions" : {
      "type" : "object",
      "properties" : {
        "minimumTravelTimeToFieldWorkerLocation" : {
          "description" : "The minimum travel time from the overnight location to the field worker location in seconds. Prevents overnight stays \"too close to home\". Zero means the field worker can stay overnight at any of the given locations.",
          "$ref" : "#/definitions/Duration"
        },
        "maximumOvernightStaysPerWeek" : {
          "description" : "Maximum number of overnight stays per week. Overnight stays will be disabled if zero is given here.",
          "$ref" : "#/definitions/NonNegativeInteger"
        },
        "forbiddenDays" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date",
            "description" : "Days on which no overnight stays may occur. Besides the days specified here, overnight stays do not occur on the last day of a work week or on the last day of the planning period."
          }
        },
        "minimumTimeSavingPerOvernightStay" : {
          "description" : "Minimum travel time in seconds saved by the overnight stay before it may be considered. This is a soft constraint and might not be fully satisfied in all situations.",
          "$ref" : "#/definitions/Duration"
        },
        "maximumTravelTimeBetweenDays" : {
          "description" : "Maximum time we may take to travel to reach the visits for the next day after an overnight stay. This is a soft constraint and might not be fully satisfied in all situations.",
          "$ref" : "#/definitions/Duration"
        },
        "hotelStayOptions" : {
          "description" : "Holds options influencing only use cases with overnight stays at hotels.",
          "$ref" : "#/definitions/HotelStayOptions"
        }
      },
      "description" : "Options influencing the choice of overnight stays in visit planning. This feature is only available for the Gurobi solver type. It can be enabled by allowing one or more overnights per week using maximumOvernightStaysPerWeek. This will implicitely enable determineShortestVisitSequencePerDay. Considering overnights will impact calculation time and can not be combined with improveDailyWorkloadBalance at this point in time. Per default, overnight stays are planned at the last visit location of a day. If workloadOptions are enabled, one can define hotels for potential overnight stays. See Plan Visits with Workload Options for details on overnight stays combined with enabled workloadOptions.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.OvernightStayOptions"
    },
    "PackBinsFocus" : {
      "type" : "string",
      "description" : "Algorithmic focus for the packBins function.  \n * `BUILD_LAYERS` - Focus on building horizontal layers of similar items. This will freely use available floor space with no special regard to loading meters.  \n * `REDUCE_LOADING_METERS` - Focus on reducing loading meters. This might result in less efficient use of overall volume.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.xload.PackBinsFocus",
      "enum" : [ "BUILD_LAYERS", "REDUCE_LOADING_METERS" ],
      "x-ms-enum" : {
        "name" : "PackBinsFocus",
        "modelAsString" : false
      }
    },
    "PackBinsOptions" : {
      "type" : "object",
      "properties" : {
        "focus" : {
          "description" : "Specifies the focus for this request. Can be used to guide algorithm behavior.",
          "$ref" : "#/definitions/PackBinsFocus"
        },
        "unloadingSequence" : {
          "type" : "array",
          "items" : {
            "description" : "Specifies the sequence of Stop to unload. The first group will be unloaded first (and loaded last). Please note that this option can be used if only one bin is defined.",
            "$ref" : "#/definitions/UnloadingStop"
          }
        },
        "stackingOptions" : {
          "description" : "Specifies the stacking options to be considered during the packing algorithm.",
          "$ref" : "#/definitions/StackingOptions"
        }
      },
      "description" : "Allows customization of packBins operations.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xload.PackBinsOptions"
    },
    "PackBinsRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "properties" : {
          "items" : {
            "type" : "array",
            "items" : {
              "description" : "List of item types that are to be packed into the given bins.",
              "$ref" : "#/definitions/ItemType"
            }
          },
          "bins" : {
            "type" : "array",
            "items" : {
              "description" : "List of available bin types into which items can be packed.",
              "$ref" : "#/definitions/BinType"
            }
          },
          "options" : {
            "description" : "Request specific options.",
            "$ref" : "#/definitions/PackBinsOptions"
          }
        },
        "description" : "Specifies a packing problem consisting of a number of items of various types that get packed into a number of bins of various types. Items as well as bins are always of cuboid shape.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xload.PackBinsRequest"
      } ],
      "x-discriminator-value" : "PackBinsRequest",
      "x-ms-discriminator-value" : "PackBinsRequest"
    },
    "PackedBin" : {
      "type" : "object",
      "required" : [ "binTypeId", "loadingMeters", "totalItemsVolume", "totalItemsWeight", "usedVolumeCapacity" ],
      "properties" : {
        "binTypeId" : {
          "type" : "string",
          "description" : "ID of the BinType"
        },
        "packedItems" : {
          "type" : "array",
          "items" : {
            "description" : "List of items that were packed into this bin.",
            "$ref" : "#/definitions/PackedItem"
          }
        },
        "totalItemsVolume" : {
          "description" : "Accumulated volume of the items packed into the bin. This is the raw sum and does not try to capture wasted volume (e.g. gaps).",
          "$ref" : "#/definitions/Volume"
        },
        "totalItemsWeight" : {
          "description" : "Accumulated weight of items packed into this bin.",
          "$ref" : "#/definitions/Kilograms"
        },
        "usedWeightCapacity" : {
          "description" : "Percent of BinType.maximumWeightCapacity used by PackedBin.totalItemsWeight. Not returned if no maximumWeightCapacity was given for bin.",
          "$ref" : "#/definitions/Percent"
        },
        "usedVolumeCapacity" : {
          "description" : "Percent of BinType.maximumVolumeCapacity used by PackedBin.totalItemsVolume. If no explicit maximum volume is given it is calculated from the container dimensions.",
          "$ref" : "#/definitions/Percent"
        },
        "loadingMeters" : {
          "description" : "Item extent along the z-axis (length) from the back wall of the bin. When looking through the back doors of a truck this is the distance from the opposing wall to the end of the load closest to the doors.",
          "$ref" : "#/definitions/LoadingMeter"
        }
      },
      "description" : "Describes a bin packed with items. If BinType.numberOfBins is greater than one, multiple packed bins with the same PackedBin.binTypeId might be part of a response.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xload.PackedBin"
    },
    "PackedBinsResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "properties" : {
          "packedBins" : {
            "type" : "array",
            "items" : {
              "description" : "List with one entry for each bin that was used for packing items in this solution.",
              "$ref" : "#/definitions/PackedBin"
            }
          },
          "itemsNotPacked" : {
            "type" : "array",
            "items" : {
              "description" : "If some or part of the quantity of an item type specified in the PackBinsRequest could not be placed into a bin they are returned here. For example if you have 20 items of a type and only 15 could be packed you will find an ItemType in this list that has the same ID as the input type but with the number of items reduced to 5. Note that ItemType is the same type used for input in PackBinsRequest so remaining items can easily be used in further packing operations.",
              "$ref" : "#/definitions/ItemType"
            }
          }
        },
        "description" : "Describes a packing solution.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xload.PackedBinsResponse"
      } ],
      "x-discriminator-value" : "PackedBinsResponse",
      "x-ms-discriminator-value" : "PackedBinsResponse"
    },
    "PackedItem" : {
      "type" : "object",
      "required" : [ "dimensions", "itemTypeId", "orientation", "position" ],
      "properties" : {
        "itemTypeId" : {
          "type" : "string",
          "description" : "ID of the ItemType."
        },
        "position" : {
          "description" : "ItemPosition of the item in the bin.",
          "$ref" : "#/definitions/ItemPosition"
        },
        "dimensions" : {
          "description" : "Packed item dimensions after orientation.",
          "$ref" : "#/definitions/BoxDimensions"
        },
        "orientation" : {
          "description" : "ItemOrientation with which the item was placed in the bin.",
          "$ref" : "#/definitions/ItemOrientation"
        }
      },
      "description" : "Describes one item of a type that was packed into a PackedBin. If ItemType.numberOfItems is greater than one, multiple packed items with the same PackedItem.itemTypeId might be in a PackedBin.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xload.PackedItem"
    },
    "ParameterConflictFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InvalidRequestFault"
      }, {
        "type" : "object",
        "required" : [ "parameterA", "parameterB", "valueA", "valueB" ],
        "properties" : {
          "parameterA" : {
            "type" : "string",
            "description" : "The xPath to the first conflicting parameter."
          },
          "parameterB" : {
            "type" : "string",
            "description" : "The xPath to the second conflicting parameter."
          },
          "valueA" : {
            "type" : "string",
            "description" : "The value of the first conflicting parameter."
          },
          "valueB" : {
            "type" : "string",
            "description" : "The value of the second conflicting parameter."
          }
        },
        "description" : "This fault is thrown if two parameters are in conflict with each other.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.ParameterConflictFault"
      } ],
      "x-discriminator-value" : "ParameterConflictFault",
      "x-ms-discriminator-value" : "ParameterConflictFault"
    },
    "ParameterIgnoredLimitation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResultLimitation"
      }, {
        "type" : "object",
        "required" : [ "ignoredParameter", "requiredParameter" ],
        "properties" : {
          "ignoredParameter" : {
            "type" : "string",
            "description" : "Identifies the parameter which was ignored as an XPath path expression."
          },
          "requiredParameter" : {
            "type" : "string",
            "description" : "Identifies a parameter which is required to be specified in order to process the ignored parameter as an XPath path expression."
          }
        },
        "description" : "This result limitation indicates that a parameter was ignored.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.service.ParameterIgnoredLimitation"
      } ],
      "x-discriminator-value" : "ParameterIgnoredLimitation",
      "x-ms-discriminator-value" : "ParameterIgnoredLimitation"
    },
    "ParameterInconsistencyLimitation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResultLimitation"
      }, {
        "type" : "object",
        "required" : [ "parameter", "value" ],
        "properties" : {
          "parameter" : {
            "type" : "string",
            "description" : "Identifies the parameter as an XPath path expression. For example, `vehicleProfile/weight/@totalPermittedWeight`."
          },
          "value" : {
            "type" : "string",
            "description" : "The value of the parameter."
          }
        },
        "description" : "This result limitation indicates that a parameter is not consistent with other parameters. For example, the actual weight of a vehicle is larger than the total permitted weight.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.service.ParameterInconsistencyLimitation"
      } ],
      "x-discriminator-value" : "ParameterInconsistencyLimitation",
      "x-ms-discriminator-value" : "ParameterInconsistencyLimitation"
    },
    "ParticleReductionClass" : {
      "type" : "string",
      "description" : "Defines the particle reduction class (Partikelminderungsklasse) according to \"Anlage XIV zu ?? 48 StVZO\" (German law).  \n * `PMK_0` - Particle reduction class PMK 0.  \n * `PMK_1` - Particle reduction class PMK 1.  \n * `PMK_2` - Particle reduction class PMK 2.  \n * `PMK_3` - Particle reduction class PMK 3.  \n * `PMK_4` - Particle reduction class PMK 4.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.vehicleprofile.ParticleReductionClass",
      "enum" : [ "PMK_0", "PMK_1", "PMK_2", "PMK_3", "PMK_4" ],
      "x-ms-enum" : {
        "name" : "ParticleReductionClass",
        "modelAsString" : false
      }
    },
    "PathWaypoint" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InputWaypoint"
      }, {
        "type" : "object",
        "required" : [ "encodedPath" ],
        "properties" : {
          "encodedPath" : {
            "description" : "Encoded string describing a complete route. Use this parameter to calculate information on a previously calculated route.  \r\nLimitation: The encoded path must have been created using the same map and xServer version.",
            "$ref" : "#/definitions/EncodedContent"
          }
        },
        "description" : "Specifies a complete path as a part of the final route. This path contains information on all waypoints and the course of the route. This comprises the waypoint names. Assigning a name to this instance will overwrite the original waypoint names.  \r\nLimitation: Only one path waypoint can be specified as input waypoint, and a path waypoint can not be mixed with other input waypoints.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.PathWaypoint"
      } ],
      "x-discriminator-value" : "PathWaypoint",
      "x-ms-discriminator-value" : "PathWaypoint"
    },
    "PaymentMethod" : {
      "type" : "string",
      "description" : "Represents payment methods for toll costs.  \n * `ELECTRONIC_TOLL_COLLECTION_SUBSCRIPTION` - Pay with an electronic toll collection system for which a subscription is required.  \n * `ELECTRONIC_TOLL_COLLECTION` - Pay with some electronic toll collection system for which no prior subscription is required.  \n * `CASH` - Pay with cash at a toll booth.  \n * `CREDIT_CARD` - Pay with credit card at a toll booth.  \n * `UNSPECIFIED` - Fallback value to be substituted for enumeration values which were added in an API version that is newer than the request version. When using the current API, this value will never be returned.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.xroute.PaymentMethod",
      "enum" : [ "ELECTRONIC_TOLL_COLLECTION_SUBSCRIPTION", "ELECTRONIC_TOLL_COLLECTION", "CASH", "CREDIT_CARD", "UNSPECIFIED" ],
      "x-ms-enum" : {
        "name" : "PaymentMethod",
        "modelAsString" : false
      }
    },
    "PenaltiesByNetworkClass" : {
      "type" : "object",
      "properties" : {
        "penalties" : {
          "type" : "array",
          "items" : {
            "description" : "The array of penalties for each network class. The 0-based index into this array corresponds to the network class segment attribute. Default values: 0,0,0,0,15,50,100,100.",
            "$ref" : "#/definitions/Penalty"
          }
        }
      },
      "description" : "Defines the general penalty value for each network class. This is useful in order to force the routing algorithm to favor freeways over smaller roads. For more information about network classes see the type of the segment attribute network class.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.routingprofile.PenaltiesByNetworkClass"
    },
    "Penalty" : {
      "type" : "integer",
      "format" : "int32",
      "description" : "Defines the segment-specific penalty values in percent for controlling the course of the route based on special needs. There are two special penalty values: 2501 blocks all segments with the property in question (e.g. toll roads), and -99 prefers them over all other segments. Use a value in between to increase or decrease the mathematical cost for the segments in the routing algorithm. Use a positive value to increase the initial mathematical cost of the segment and a negative value decreases the cost by the given percentage. For example, 100 increases the costs by a factor of two and -50 decreases the costs by a factor of two. 2500 is the proper value when segments must not be used unless there is no other option (consider a ferry being the only way to leave an island, residential areas at start or destination). Range: -99 ??? value ??? 2501.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.Penalty"
    },
    "Percent" : {
      "type" : "number",
      "format" : "double",
      "description" : "Defines a percent value. Range: 0.0 ??? value ??? 100.0.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.Percent"
    },
    "PhysicalPixel" : {
      "type" : "integer",
      "format" : "int32",
      "description" : "Absolute number of pixels independent of any resolution aspects such as image width or height.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.PhysicalPixel"
    },
    "PickupDeliveryOrder" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TransportOrder"
      }, {
        "type" : "object",
        "required" : [ "deliveryLocationId", "pickupLocationId" ],
        "properties" : {
          "pickupLocationId" : {
            "type" : "string",
            "description" : "ID of the location where the goods should be picked up. This location is either a customer site or a depot site."
          },
          "deliveryLocationId" : {
            "type" : "string",
            "description" : "ID of the location where the goods should be delivered to. This location is either a customer site or a depot site."
          }
        },
        "description" : "A specific transport order that allows the goods to be picked up at one location and be delivered to a different location.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.PickupDeliveryOrder"
      } ],
      "x-discriminator-value" : "PickupDeliveryOrder",
      "x-ms-discriminator-value" : "PickupDeliveryOrder"
    },
    "PixelBoundingBox" : {
      "type" : "object",
      "required" : [ "bottom", "left", "right", "top" ],
      "properties" : {
        "left" : {
          "description" : "Lower bound of the rectangle area on the X-axis in pixels, orientation from left to right.",
          "$ref" : "#/definitions/PhysicalPixel"
        },
        "top" : {
          "description" : "Lower bound of the rectangle area on the Y-axis in pixels, orientation from top to bottom.",
          "$ref" : "#/definitions/PhysicalPixel"
        },
        "right" : {
          "description" : "Upper bound of the rectangle area on the X-axis in pixels, orientation from left to right.",
          "$ref" : "#/definitions/PhysicalPixel"
        },
        "bottom" : {
          "description" : "Upper bound of the rectangle area on the Y-axis in pixels, orientation from top to bottom.",
          "$ref" : "#/definitions/PhysicalPixel"
        }
      },
      "description" : "Defines a bounding box (rectangle) in a pixel-based medium. This type is part of the concept for Generating a Map Image.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xmap.PixelBoundingBox"
    },
    "PixelPoint" : {
      "type" : "object",
      "required" : [ "x", "y" ],
      "properties" : {
        "x" : {
          "description" : "X-axis, horizontal pixel position, orientation from left to right.",
          "$ref" : "#/definitions/PhysicalPixel"
        },
        "y" : {
          "description" : "Y-axis, vertical pixel position, orientation from top to bottom.",
          "$ref" : "#/definitions/PhysicalPixel"
        }
      },
      "description" : "Locates the position on a pixel-based medium. This type is part of the concept for Generating a Map Image.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xmap.PixelPoint"
    },
    "PlanClustersOptions" : {
      "type" : "object",
      "required" : [ "numberOfClusters" ],
      "properties" : {
        "numberOfClusters" : {
          "description" : "The number of clusters that should be returned by the planning algorithm. If this parameter differs from the number of clusters that are set in the request, the number of clusters is changed to the value specified here.",
          "$ref" : "#/definitions/PositiveInteger"
        },
        "ignoreImbalanceTolerance" : {
          "type" : "boolean",
          "description" : "If false, the imbalanceTolerance parameter will be considered by the planning algorithm. If true, the imbalanceTolerance will be ignored and a probably imbalanced solution is returned."
        },
        "imbalanceTolerance" : {
          "description" : "Represents the maximal deviation from the average total activity per cluster which is tolerated for each cluster. The imbalanceTolerance is used as exit criterion for the algorithm: as soon as all clusters are sufficiently balanced, the algorithm stops. For CalculationMode PERFORMANCE this value is more a guidance level than a maximal value. Locations may be assigned to a cluster after the algorithm stops. Therefore it cannot be guaranteed that the actual imbalance lies within the value set as imbalanceTolerance.",
          "$ref" : "#/definitions/Tolerance"
        },
        "optionalClusterIds" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "description" : "A list of clusters, referenced by their ID, that are marked as optional. That means they are allowed to be left out of the solution. Setting this list, only makes sense if the number of clusters to plan is smaller than the number of clusters given in the request."
          }
        },
        "reduceOverlappingInClusters" : {
          "type" : "boolean",
          "description" : "Clusters are always optimized towards compactness and towards minimal driving times from the reference point to each location. Depending on the routing profile used for driving time calculation, clusters may be stretched along major roads and it is possible that two clusters visually overlap. Furthermore, a high variance among activities might also lead to overlaps. If reduceOverlappingInClusters is set to true, the algorithm tries to reduce overlapping among clusters. If there is no valid solution that avoids overlapping clusters, a valid solution with overlapping clusters is returned. Setting this parameter to true usually increases runtime because additional steps have to be executed. In addition, the activity-imbalance among clusters and the overall driving time per cluster may increase."
        },
        "considerActivitiesAsServiceTimes" : {
          "type" : "boolean",
          "description" : "If this parameter is set to true, all activity values set at a location are considered to be service times in seconds. Using service periods as activity means that estimated tour durations are balanced for each cluster instead of the total sum of activity. Therefore the value of ClusterReport.totalActivity represents the estimated tour duration for the corresponding cluster."
        },
        "activityCapacities" : {
          "type" : "array",
          "items" : {
            "description" : "Target activity capacities for the output clusters. If not empty must contain one entry for each requested cluster. numberOfClusters in total. Cluster activity capacities will be under or overutilized proportionally. For example assume you have a problem with two clusters A and B. A having an activity capacity of 10. B having one of 20. If the planning location activity to be distributed sums up to 60, the A cluster would end up being assigned 20, the B cluster 40 of this activity. On the other hand if there was only 15 to distribute A would receive 5 and B 15 of this activity. The configured imbalanceTolerance is interpreted taking this into account.",
            "$ref" : "#/definitions/ActivityCapacity"
          }
        },
        "activityCapacitiesAreAbsolute" : {
          "type" : "boolean",
          "description" : "This feature can be used only when clusters are specified. If set to true, activity capacities are taken as absolute upper bounds for specified clusters according to their input sequence. The parameter imbalanceTolerance does not play any role. This means, it could happen, that a planning location remains unplanned in the end. Furthermore, it could happen, that a cluster facility is not allocated to any planning location, i.e. the respective ClusterReport.numberOfLocations is zero and the respective ClusteredLocations.locationIds is empty."
        },
        "calculationMode" : {
          "description" : "Required solution quality of the calculation.",
          "$ref" : "#/definitions/ClusterPlanningCalculationMode"
        },
        "useTravelDistance" : {
          "type" : "boolean",
          "description" : "If set to true, travel distances and not travel times are used for calculations. The value of this parameter coupled with the choice of DistanceMode in PlanClustersRequest affects the result obtained in response."
        }
      },
      "description" : "Input parameters for the planning algorithm.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.PlanClustersOptions"
    },
    "PlanClustersRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "required" : [ "distanceMode", "planClustersOptions" ],
        "properties" : {
          "planningLocations" : {
            "type" : "array",
            "items" : {
              "description" : "Set of locations that should be clustered.",
              "$ref" : "#/definitions/PlanningLocation"
            }
          },
          "clusters" : {
            "type" : "array",
            "items" : {
              "description" : "Set of clusters represented by their reference points to which the locations will be assigned. A cluster may marked as optional in the planClustersOptions. Otherwise it is ensured that the cluster is included in the returned solution. If there are more clusters given in the request, than are defined to be planned by PlanClustersOptions.numberOfClusters, some of the given clusters have to be marked as optional.",
              "$ref" : "#/definitions/Cluster"
            }
          },
          "planClustersOptions" : {
            "description" : "Parameters for the planning algorithm.",
            "$ref" : "#/definitions/PlanClustersOptions"
          },
          "distanceMode" : {
            "description" : "Contains settings that specify how distances between locations are retrieved. When using direct distance the driven distances are estimated with a detour factor of 1.38 and for the duration a speed of 60 km/h is assumed. Only the following distance modes are supported: DirectDistance and ExistingDistanceMatrix.",
            "$ref" : "#/definitions/DistanceMode"
          }
        },
        "description" : "Input for the use case plan clusters.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.PlanClustersRequest"
      } ],
      "x-discriminator-value" : "PlanClustersRequest",
      "x-ms-discriminator-value" : "PlanClustersRequest"
    },
    "PlanToursOptions" : {
      "type" : "object",
      "properties" : {
        "planningHorizon" : {
          "description" : "Defines the planning horizon for this request, described by start and end date. It restricts all tours which means their beginning and end need to be in this planning horizon. All opening intervals outside of this planning horizon are not considered during the tour planning process. If the opening intervals, driver operating intervals or break intervals contain GDF time domains, the planning horizon is a required parameter to limit the number of recurring intervals of the time domains. The planning horizon is restricted to a maximum duration of two weeks.",
          "$ref" : "#/definitions/StartEndInterval"
        },
        "restrictions" : {
          "description" : "Defines restrictions for the planning algorithm.",
          "$ref" : "#/definitions/TourRestrictions"
        },
        "calculationMode" : {
          "description" : "Defines the calculation mode of the planning algorithm.",
          "$ref" : "#/definitions/TourPlanningCalculationMode"
        },
        "customCalculationModeConfiguration" : {
          "description" : "Defines a specific configuration for calculation mode CUSTOM in an encoded form.",
          "$ref" : "#/definitions/EncodedContent"
        },
        "tweaksToObjective" : {
          "description" : "Defines specific tweaks to the objective of the algorithm.",
          "$ref" : "#/definitions/TweaksToObjective"
        },
        "orderGroupConsideration" : {
          "description" : "Defines strong preferences concerning order groups. They are considered in automatic planning. If these preferences are not met for an input plan or for a change tours action, they are not reported as a violation.",
          "$ref" : "#/definitions/OrderGroupConsideration"
        },
        "singleStopPerCustomerSite" : {
          "type" : "boolean",
          "description" : "Defines a strong preference that all tasks of orders for the same customer site are carried out at the same stop if possible. If this is not possible, all unplanned orders for that customer site remain unplanned. Transport orders between two customer sites are ignored here. This preference is only considered in automatic planning. If this preference is not met for an input plan or for a change tours action, it is not reported as a violation."
        },
        "considerOrderPriorities" : {
          "type" : "boolean",
          "description" : "If set to true order priorities are considered during automatic planning. Please keep in mind that using multiple priorities will increase the computation time of the algorithm. See technical concept Order Priorities for further details."
        },
        "ignoreRouteViolations" : {
          "type" : "boolean",
          "description" : "If this field is set to true, route violations are ignored. No route violation is reported at the tour events. If this field is set to false, automatic planning will not create a tour with a route violation. Input tours with a route violation will be treated as violated tours and therefore will not be changed by the automatic planning. At the leg report and at the tours response route violated is set regardless of this field."
        },
        "ignoreReachabilityViolations" : {
          "type" : "boolean",
          "description" : "If this field is set to true, reachability violations are ignored. No reachability violation is reported at the tour events. If this field is set to false, automatic planning will not create a tour with a reachability violation. Input tours with a reachability violation will be treated as violated tours and therefore will not be changed by the automatic planning. At the leg report estimated by direct distance is set regardless of this field."
        }
      },
      "description" : "Contains global planning settings.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.PlanToursOptions"
    },
    "PlanToursRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "required" : [ "distanceMode", "fleet" ],
        "properties" : {
          "locations" : {
            "type" : "array",
            "items" : {
              "description" : "A list of vehicle locations, depot sites or customer sites that should be served or visited.",
              "$ref" : "#/definitions/TourPlanningLocation"
            }
          },
          "orders" : {
            "type" : "array",
            "items" : {
              "description" : "A list of orders that should be planned into tours.",
              "$ref" : "#/definitions/Order"
            }
          },
          "fleet" : {
            "description" : "The fleet that should be used to conduct the planned tours.",
            "$ref" : "#/definitions/Fleet"
          },
          "inputPlan" : {
            "description" : "A list of tours that serves the algorithm as start solution (e.g. tours of previous responses). The input tours can generally be changed or dissolved except when they are fixed. To evaluate an input plan without changing it, use calculation mode EVALUATE.",
            "$ref" : "#/definitions/InputPlan"
          },
          "planToursOptions" : {
            "description" : "Contains planning options.",
            "$ref" : "#/definitions/PlanToursOptions"
          },
          "distanceMode" : {
            "description" : "Contains settings that specify how distances are retrieved for tour planning. These settings apply to all vehicles in the request. When using direct distance the driven distances are estimated with a detour factor of 1.38 and for the duration a speed of 60 km/h is assumed. Time dependent and non time dependent distance matrices must not be used together in a request. If time dependent distance matrices are used, no driving time regulation must be set.",
            "$ref" : "#/definitions/DistanceMode"
          },
          "storeRequest" : {
            "type" : "boolean",
            "description" : "Defines if the request should be stored in the session storage. Note that if there occur problems with the session storage, an ObjectNotStoredLimitation is generated and the stored request ID in the response is null."
          }
        },
        "description" : "The request object for the service method planTours.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.PlanToursRequest"
      } ],
      "x-discriminator-value" : "PlanToursRequest",
      "x-ms-discriminator-value" : "PlanToursRequest"
    },
    "PlanVisitsOptions" : {
      "type" : "object",
      "required" : [ "planningPeriod", "workDays" ],
      "properties" : {
        "planningPeriod" : {
          "description" : "Planning period of the request. The start date of this period defines the first day of a work week. For example, if the start date is a saturday and the workdays are set to monday, wednesday and saturday, a work week is considered in the order saturday, monday, wednesday.",
          "$ref" : "#/definitions/PlanningPeriod"
        },
        "workDays" : {
          "description" : "Work days of a week.",
          "$ref" : "#/definitions/Week"
        },
        "ignoreWeeklyImbalanceTolerance" : {
          "type" : "boolean",
          "description" : "If false, the weeklyImbalanceTolerance parameter will be considered by the planning algorithm. If true, the weeklyImbalanceTolerance will be ignored and a probably imbalanced solution is returned. This parameter is ignored if workLoadOptions are used."
        },
        "weeklyImbalanceTolerance" : {
          "description" : "Maximal deviation from the average weekly service workload of the field worker. The average workload is thereby determined from the given service times of the orders. This parameter is ignored if workLoadOptions are used.",
          "$ref" : "#/definitions/Tolerance"
        },
        "ignoreDailyImbalanceTolerance" : {
          "type" : "boolean",
          "description" : "If false, the dailyImbalanceTolerance parameter will be considered by the planning algorithm. If true, the dailyImbalanceTolerance will be ignored and a probably imbalanced solution is returned. This parameter is ignored if workLoadOptions are used."
        },
        "dailyImbalanceTolerance" : {
          "description" : "Maximal deviation from the average daily service workload of the field worker. The average workload is thereby determined from the given service times of the orders. This parameter is ignored if workLoadOptions are used.",
          "$ref" : "#/definitions/Tolerance"
        },
        "determineShortestVisitSequencePerDay" : {
          "type" : "boolean",
          "description" : "If true, the visits are returned in an optimal sequence that leads to a shortest tour with respect to travel time for each visit day. The calculation of these shortest tours is allowed to take up to 100 seconds of calculation time on top of the configured solverTimeLimit per day in the result but is usually much quicker. If the parameter is false, visits are sorted by visit day but the sequence of visits within a visit day has no special meaning."
        },
        "improveDailyWorkloadBalance" : {
          "type" : "boolean",
          "description" : "This feature is only available for the Gurobi solver type. If true, xcluster attempts to further minimize workload imbalances between days. In contrast to the dailyImbalanceTolerance this option considers the workload to not only consist of service time, but also of the travel time between customers on the day. This additional improvement may take up to solverTimeLimit of additional processing time. As the daily workload is calculated based on the shortest visit sequence for the day, determineShortestVisitSequencePerDay is implied to be true. If improveDailyWorkloadBalance is false, balancing will only be performed based on service time according to the given tolerances. This parameter is ignored if workLoadOptions are used."
        },
        "overnightStayOptions" : {
          "description" : "Options to control overnight stays. This feature is currently not available combined with workloadOptions. This feature is only available for the Gurobi solver type.",
          "$ref" : "#/definitions/OvernightStayOptions"
        },
        "workloadOptions" : {
          "description" : "Options to control workload. When using this feature, workload is balanced implicitly and the balancing parameters for weekly and daily imbalance tolerance and for improving daily workload balance will be ignored. This feature is currently not available combined with overnightStayOptions. This feature is only available for the Gurobi solver type.",
          "$ref" : "#/definitions/WorkloadOptions"
        }
      },
      "description" : "Input parameters for the visit planning algorithm.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.PlanVisitsOptions"
    },
    "PlanVisitsRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "required" : [ "distanceMode", "fieldWorker", "planVisitsOptions" ],
        "properties" : {
          "fieldWorker" : {
            "description" : "Field worker who shall handle the orders.",
            "$ref" : "#/definitions/FieldWorker"
          },
          "locations" : {
            "type" : "array",
            "items" : {
              "description" : "Set of customer locations that should be visited.",
              "$ref" : "#/definitions/ClusterPlanningLocation"
            }
          },
          "orders" : {
            "type" : "array",
            "items" : {
              "description" : "Set of orders to be handled by the field worker.",
              "$ref" : "#/definitions/VisitPlanningOrder"
            }
          },
          "planVisitsOptions" : {
            "description" : "Parameters for the visit planning algorithm.",
            "$ref" : "#/definitions/PlanVisitsOptions"
          },
          "distanceMode" : {
            "description" : "Contains settings that specify how distances between locations are retrieved. When using direct distance the driven distances are estimated with a detour factor of 1.38 and for the duration a speed of 60 km/h is assumed. Only the following distance modes are supported: DirectDistance and ExistingDistanceMatrix.",
            "$ref" : "#/definitions/DistanceMode"
          },
          "hotels" : {
            "type" : "array",
            "items" : {
              "description" : "Represents a list of hotels to be used for overnight stays. Can only be used together with overnightStayOptions and workloadOptions. This feature is only available for the Gurobi solver type.",
              "$ref" : "#/definitions/Hotel"
            }
          }
        },
        "description" : "Input for the use case visit planning.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.PlanVisitsRequest"
      } ],
      "x-discriminator-value" : "PlanVisitsRequest",
      "x-ms-discriminator-value" : "PlanVisitsRequest"
    },
    "PlanningLocation" : {
      "type" : "object",
      "required" : [ "activity", "location" ],
      "properties" : {
        "location" : {
          "description" : "The geographic location that is represented by this planning location.",
          "$ref" : "#/definitions/ClusterPlanningLocation"
        },
        "activity" : {
          "type" : "number",
          "format" : "double",
          "description" : "Represents an absolute value of constant activity. Activity values of all locations in a cluster are accumulated to the totalActivity of the cluster. Arbitrary numerical values can be used as activity measure. Typical examples are sales figures, enterprise sizes, or population figures. If estimated tour durations should be balanced, activities can be considered as service times in seconds that have to be done at the corresponding location. In this case, considerActivitiesAsServiceTimes has to be enabled. The resulting tour duration of a cluster consists of the sum of given service times and estimated driving times."
        },
        "groupId" : {
          "type" : "string",
          "description" : "Unique identifier of a group of locations this location belongs to. Locations that are in the same group will be assigned to the same cluster."
        },
        "clusterCompatibility" : {
          "description" : "Either compatible or incompatible clusters for this location. A compatibility list either contains only compatible clusters or only incompatible clusters for this location. Setting only one compatible cluster, fixes the location to this cluster.",
          "$ref" : "#/definitions/ClusterCompatibility"
        }
      },
      "description" : "Represents a location that should be assigned to a cluster.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.PlanningLocation"
    },
    "PlanningPeriod" : {
      "type" : "object",
      "required" : [ "numberOfWeeks", "startDate" ],
      "properties" : {
        "startDate" : {
          "type" : "string",
          "format" : "date",
          "description" : "The start date of the period. It defines the first day of a work week. For example, if the start date is a saturday and the workdays are set to monday, wednesday and saturday, a work week is considered in the order saturday, monday, wednesday. This needs to be a valid workDay of a week."
        },
        "numberOfWeeks" : {
          "description" : "The number of weeks contained in this period from startDate on.",
          "$ref" : "#/definitions/PositiveInteger"
        }
      },
      "description" : "Represents a period of weeks.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.PlanningPeriod"
    },
    "Polygon" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Geometry"
      }, {
        "type" : "object",
        "properties" : {
          "polygonRings" : {
            "type" : "array",
            "items" : {
              "description" : "A polygon consists of a set of linear rings (polylines that are simple and closed). The first ring specifies the shell of the polygon, all other rings specify holes.",
              "$ref" : "#/definitions/Polyline"
            }
          }
        },
        "description" : "A polygon is a planar two-dimensional geometric object, defined by one exterior boundary and zero or more interior boundaries. Each interior boundary defines a hole in the polygon.\r\n\r\nAssertions:\r\n\r\n1.  Polygons are topologically closed.\r\n2.  The boundary of a polygon consists of a set of linear rings that make up its exterior and interior boundaries.\r\n3.  No two rings in the boundary cross, they may intersect at a point but only as a tangent.\r\n4.  A polygon may not have cut lines, spikes or punctures.\r\n5.  The interior of every polygon is a connected coint set.\r\n6.  The exterior of a polygon with one or more holes is not connected. Each hole defines a connected component of the exterior.\r\n\r\n(Open GIS Standard)\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.geometry.Polygon"
      } ],
      "x-discriminator-value" : "Polygon",
      "x-ms-discriminator-value" : "Polygon"
    },
    "PolygonStyle" : {
      "type" : "object",
      "properties" : {
        "stroke" : {
          "description" : "Defines how to render the stroke, i.e. the edge, of the polygon.",
          "$ref" : "#/definitions/StrokeStyle"
        },
        "fill" : {
          "description" : "Defines how to fill the polygons.",
          "$ref" : "#/definitions/FillStyle"
        }
      },
      "description" : "Defines how to render a polygon.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.renderingprofile.PolygonStyle"
    },
    "Polyline" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Geometry"
      }, {
        "type" : "object",
        "properties" : {
          "polyline" : {
            "type" : "array",
            "items" : {
              "description" : "A Polyline consists of at least two points, it is closed if first and last coordinate are equal.",
              "$ref" : "#/definitions/Coordinate"
            }
          }
        },
        "description" : "A polyline is a one-dimensional geometric object (sequence of points) with linear interpolation between points. Each consecutive pair of points defines a line segment. (Open GIS Standard) A linear ring is a polyline that is both closed and simple (no intersections allowed).\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.geometry.Polyline"
      } ],
      "x-discriminator-value" : "Polyline",
      "x-ms-discriminator-value" : "Polyline"
    },
    "PolylineOptions" : {
      "type" : "object",
      "properties" : {
        "elevations" : {
          "type" : "boolean",
          "description" : "If true, the polyline will contain the elevations, i.e. each Coordinate will contain the z-coordinate. This setting applies to all requested polylines, e.g. complete route, legs, and segments. If elevation data are not available, the z-coordinate is 0, and there is an ElevationsNotAvailableLimitation which contains the indices of the polyline with a missing z-coordinate."
        }
      },
      "description" : "Specifies how the polyline shall be calculated.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.PolylineOptions"
    },
    "Position" : {
      "type" : "object",
      "required" : [ "$type", "coordinate" ],
      "discriminator" : "$type",
      "properties" : {
        "coordinate" : {
          "description" : "The coordinate of the position to be matched",
          "$ref" : "#/definitions/Coordinate"
        },
        "heading" : {
          "description" : "The angle of the direction of travel",
          "$ref" : "#/definitions/AbsoluteDirection"
        },
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "Describes a position in terms of a coordinate and additional attributes to help matching it on a map.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xmatch.Position"
    },
    "PositionAtStop" : {
      "allOf" : [ {
        "$ref" : "#/definitions/VehiclePosition"
      }, {
        "type" : "object",
        "required" : [ "serviceStatus", "stopIndex", "tripId" ],
        "properties" : {
          "serviceStatus" : {
            "description" : "Specifies if service has not started yet, service is currently being performed or if service is completed.",
            "$ref" : "#/definitions/ServiceStatus"
          },
          "tripId" : {
            "type" : "string",
            "description" : "Trip ID of the current stop."
          },
          "stopIndex" : {
            "description" : "Zero based index of current stop in the tour. Counting of stops starts at the first stop of the specified trip.",
            "$ref" : "#/definitions/Index"
          }
        },
        "description" : "Driver and his vehicle are at a stop of the tour. If the trip with the given id starts at the given stop and the driver has arrived at the stop, then the corresponding TRIP\\_START event is returned in the tour events. If the trip with the given id ends at the given stop and the driver has completed his service, then the corresponding TRIP\\_END event is not returned and no trip report is created for this trip.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.PositionAtStop"
      } ],
      "x-discriminator-value" : "PositionAtStop",
      "x-ms-discriminator-value" : "PositionAtStop"
    },
    "PositionAtVehicleStartLocation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/VehiclePosition"
      }, {
        "type" : "object",
        "description" : "Position of the driver and his vehicle is still at the start of the tour.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.PositionAtVehicleStartLocation"
      } ],
      "x-discriminator-value" : "PositionAtVehicleStartLocation",
      "x-ms-discriminator-value" : "PositionAtVehicleStartLocation"
    },
    "PositionEnRoute" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RoutingVehiclePosition"
      }, {
        "type" : "object",
        "required" : [ "currentLocation", "indexOfNextWaypoint" ],
        "properties" : {
          "currentLocation" : {
            "description" : "Current geographic location of the vehicle. The route is recalculated from this position. The part of the path before is ignored.",
            "$ref" : "#/definitions/Coordinate"
          },
          "indexOfNextWaypoint" : {
            "description" : "Zero based index of the next waypoint of the route.",
            "$ref" : "#/definitions/Index"
          },
          "heading" : {
            "description" : "The absolute direction of the vehicle. North represents 0 degrees. For more information, pleaser refer to the technical concept Estimated Time of Arrival.",
            "$ref" : "#/definitions/AbsoluteDirectionInteger"
          },
          "headingTolerance" : {
            "description" : "The tolerance around the heading direction of the vehicle.",
            "$ref" : "#/definitions/DirectionToleranceInteger"
          }
        },
        "description" : "The vehicle is located on the route, between 2 waypoints. In this use case, xroute will use the vehicle's coordinates to find the nearest position on the path, and recalculate the route from this position. If the vehicle is too far from the path, a complete route calculation is performed, starting from the current position of the vehicle.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.PositionEnRoute"
      } ],
      "x-discriminator-value" : "PositionEnRoute",
      "x-ms-discriminator-value" : "PositionEnRoute"
    },
    "PositionEnRouteToStop" : {
      "allOf" : [ {
        "$ref" : "#/definitions/VehiclePosition"
      }, {
        "type" : "object",
        "required" : [ "currentLocation", "indexOfNextStop", "tripId" ],
        "properties" : {
          "currentLocation" : {
            "description" : "Current geographic location of driver and his vehicle.",
            "$ref" : "#/definitions/Coordinate"
          },
          "tripId" : {
            "type" : "string",
            "description" : "Trip ID of the the next stop."
          },
          "indexOfNextStop" : {
            "description" : "Zero based index of next stop in the trip. Counting of stops starts at the first stop of the specified trip.",
            "$ref" : "#/definitions/Index"
          }
        },
        "description" : "Driver and his vehicle are currently en route between stops or between the vehicle start location and the first stop of the first trip. PositionEnRouteToStop may not be used before the first stop of the first trip if the tour does not start before this stop. An exception is thrown otherwise.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.PositionEnRouteToStop"
      } ],
      "x-discriminator-value" : "PositionEnRouteToStop",
      "x-ms-discriminator-value" : "PositionEnRouteToStop"
    },
    "PositionEnRouteToVehicleEndLocation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/VehiclePosition"
      }, {
        "type" : "object",
        "required" : [ "currentLocation" ],
        "properties" : {
          "currentLocation" : {
            "description" : "Current geographic location of driver and his vehicle.",
            "$ref" : "#/definitions/Coordinate"
          }
        },
        "description" : "Driver and his vehicle are currently en route between the last stop of the tour and the vehicle end location. PositionEnRouteToVehicleEndLocation may not be used after the last stop of the last trip if the tour ends at this stop. An exception is thrown otherwise.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.PositionEnRouteToVehicleEndLocation"
      } ],
      "x-discriminator-value" : "PositionEnRouteToVehicleEndLocation",
      "x-ms-discriminator-value" : "PositionEnRouteToVehicleEndLocation"
    },
    "PositionInTrip" : {
      "type" : "string",
      "description" : "Type of a specified position of a stop at a customer site within its trip.  \n * `FIRST_CUSTOMER_STOP` - A stop at a customer site with this position type has to be the very first customer stop in its trip.  \n * `LAST_CUSTOMER_STOP` - A stop at a customer site with this position type has to be the very last customer stop in its trip.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.xtour.PositionInTrip",
      "enum" : [ "FIRST_CUSTOMER_STOP", "LAST_CUSTOMER_STOP" ],
      "x-ms-enum" : {
        "name" : "PositionInTrip",
        "modelAsString" : false
      }
    },
    "PositionQuality" : {
      "type" : "object",
      "required" : [ "matchDistance" ],
      "properties" : {
        "matchDistance" : {
          "description" : "The straight-line distance (Euclidean distance) from the input position to the matching segment",
          "type" : "number"
        },
        "angleDifference" : {
          "description" : "The difference between the angle of the heading of the input position and the angle of the matching segment",
          "$ref" : "#/definitions/AngleDifference"
        }
      },
      "description" : "Describes the quality of the position match.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xmatch.PositionQuality"
    },
    "PositionViolation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TourViolation"
      }, {
        "type" : "object",
        "description" : "Specifies a violation for any event that is not at the expected position. This violation has one of the following tour event violation types: REST\\_POSITION, CUSTOMER\\_STOP\\_POSITION\\_IN\\_TRIP, TRIP\\_SECTION.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.tourplanning.PositionViolation"
      } ],
      "x-discriminator-value" : "PositionViolation",
      "x-ms-discriminator-value" : "PositionViolation"
    },
    "PositionsResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "properties" : {
          "matchedPositions" : {
            "type" : "array",
            "items" : {
              "description" : "Detailed information about the matches of the input positions. There is one matched position for every input position.",
              "$ref" : "#/definitions/MatchedPosition"
            }
          }
        },
        "description" : "Response of a matchPositions request which contains all matched segments.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xmatch.PositionsResponse"
      } ],
      "x-discriminator-value" : "PositionsResponse",
      "x-ms-discriminator-value" : "PositionsResponse"
    },
    "PositiveInteger" : {
      "type" : "integer",
      "format" : "int32",
      "description" : "Defines a positive integer value. Range: 1 ??? value.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.PositiveInteger"
    },
    "ProcessingFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/XServerFault"
      }, {
        "type" : "object",
        "description" : "This fault is thrown if the request could not be processed by the service.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.ProcessingFault"
      } ],
      "x-discriminator-value" : "ProcessingFault",
      "x-ms-discriminator-value" : "ProcessingFault"
    },
    "ProcessingTimedOutFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ProcessingFault"
      }, {
        "type" : "object",
        "description" : "This fault is thrown if the processing of a request is aborted by an internal timeout. In contrast to exceptions.RequestTimedOutException, there is no user-configurable timeout value that could be changed to prevent this. An internal timeout is meant to control corner cases where an algorithm behaves poorly.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.ProcessingTimedOutFault"
      } ],
      "x-discriminator-value" : "ProcessingTimedOutFault",
      "x-ms-discriminator-value" : "ProcessingTimedOutFault"
    },
    "ProfileDescription" : {
      "type" : "object",
      "required" : [ "name" ],
      "properties" : {
        "name" : {
          "type" : "string",
          "description" : "The profile name. It represents the file name without the extension and can be used with service.RequestBase.storedProfile for every request."
        },
        "description" : {
          "type" : "string",
          "description" : "The profile description. Can be empty if not set in the profile."
        },
        "useCases" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "description" : "The list of use cases as specified in the profile. If no use cases are set in the profile it is omitted."
          }
        },
        "displayName" : {
          "type" : "string",
          "description" : "The display name of the profile. Can be empty if not set in the profile."
        }
      },
      "description" : "Represents a profile.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.ProfileDescription"
    },
    "ProfileRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "description" : "Specifies the profile to be returned.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.ProfileRequest"
      } ],
      "x-discriminator-value" : "ProfileRequest",
      "x-ms-discriminator-value" : "ProfileRequest"
    },
    "ProfileResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "properties" : {
          "vehicleProfile" : {
            "description" : "The vehicle profile.",
            "$ref" : "#/definitions/VehicleProfile"
          },
          "featureLayerProfile" : {
            "description" : "The Feature Layer profile.",
            "$ref" : "#/definitions/FeatureLayerProfile"
          },
          "routingProfile" : {
            "description" : "The routing profile.",
            "$ref" : "#/definitions/RoutingProfile"
          },
          "mapLanguage" : {
            "description" : "The language used for geographic names that are part of the map. The default x-ptv-DFT means that names are given in the language spoken in that country or region.",
            "$ref" : "#/definitions/LanguageCode"
          },
          "userLanguage" : {
            "description" : "The language of texts such as maneuver or traffic-incident descriptions. If the specified language is not supported, the following fallback languages are used: First, if subtags are present, the primary language is used. Second, English is used. As an example pt-BR ? pt ? en. The language of geographic names can be set by the field mapLanguage. As an example the description of a maneuver should be readable by the user but city names which can be found on local signs should be available in that language in order to be recognized.",
            "$ref" : "#/definitions/LanguageCode"
          }
        },
        "description" : "Contains the effective profile.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.ProfileResponse"
      } ],
      "x-discriminator-value" : "ProfileResponse",
      "x-ms-discriminator-value" : "ProfileResponse"
    },
    "ProfilesResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "properties" : {
          "profiles" : {
            "type" : "array",
            "items" : {
              "description" : "Available profiles ordered by displayName.",
              "$ref" : "#/definitions/ProfileDescription"
            }
          }
        },
        "description" : "This type holds information on the available profiles.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.ProfilesResponse"
      } ],
      "x-discriminator-value" : "ProfilesResponse",
      "x-ms-discriminator-value" : "ProfilesResponse"
    },
    "QualificationViolation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TourViolation"
      }, {
        "type" : "object",
        "properties" : {
          "qualifications" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "description" : "Required qualifications that are missing. For example, this can be missing equipment of the used vehicle that is required by the tour."
            }
          }
        },
        "description" : "Specifies a violation for missing qualification (e.g. missing equipment of the used vehicle) that is required by the tour. This violation has one of the following tour event violation types: VEHICLE\\_EQUIPMENT.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.tourplanning.QualificationViolation"
      } ],
      "x-discriminator-value" : "QualificationViolation",
      "x-ms-discriminator-value" : "QualificationViolation"
    },
    "QuantityScenarioChangePosition" : {
      "type" : "string",
      "description" : "Position at which a quantity scenario of a vehicle may be changed.  \n * `AT_STOP` - The scenario may be changed between unloading and loading at a stop.  \n * `BETWEEN_TRIPS` - The scenario may only be changed between a trip end and a trip start.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.xtour.QuantityScenarioChangePosition",
      "enum" : [ "AT_STOP", "BETWEEN_TRIPS" ],
      "x-ms-enum" : {
        "name" : "QuantityScenarioChangePosition",
        "modelAsString" : false
      }
    },
    "QueueOverflowFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RejectedRequestFault"
      }, {
        "type" : "object",
        "description" : "This fault is thrown if there are too many requests in the xServer's request queue. If this happens frequently, you may have to increase the size of the request queue in the xServer configuration.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.QueueOverflowFault"
      } ],
      "x-discriminator-value" : "QueueOverflowFault",
      "x-ms-discriminator-value" : "QueueOverflowFault"
    },
    "Range" : {
      "type" : "object",
      "required" : [ "from" ],
      "properties" : {
        "from" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "The start value of the integer range."
        },
        "to" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "The end value of the integer range. Must be greater or equal to 'from'. Can be omitted to specify a range consisting only of the 'from' value."
        }
      },
      "description" : "Defines the ranges of the display class values for which this style shall apply. Ranges must not be overlapping, that means the 'to' value of the lower range has to be smaller than the 'from' value of the higher range. For example 0-50 and 51-100. If empty, the style applies to all values. It is possible to specity both a style with a range (e.g. 0-50) and another one without a range. Values 0-50 will then apply to the style with the range, all others to the one without the range.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.renderingprofile.Range"
    },
    "ReachabilityViolation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TourViolation"
      }, {
        "type" : "object",
        "description" : "Specifies a violation where the route between two locations is estimated by direct distance instead of the road network, e.g. because one location is not within boundaries of map. For more information, see estimatedByDirectDistance. This violation can only occur if ignore reachability violations is not set and if distance mode is not set to direct distance. This violation has the following tour violation type: REACHABILITY.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.tourplanning.ReachabilityViolation"
      } ],
      "x-discriminator-value" : "ReachabilityViolation",
      "x-ms-discriminator-value" : "ReachabilityViolation"
    },
    "ReachableAreasCalculationMode" : {
      "type" : "string",
      "description" : "Specifies the calculation mode of a reachable areas calculation.  \n * `PERFORMANCE` - The calculation is fast but produces a polygon which gives only a rough overview on the reachable areas. Use this mode to get a quick response on large horizons.  \n * `QUALITY` - The calculation produces an exact polygon for the reachable areas including minor roads but is less performant. Use this mode to get good results and with small horizons. It is strongly recommended to call the operation asynchronously as the response times tend to be much longer.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.xroute.ReachableAreasCalculationMode",
      "enum" : [ "PERFORMANCE", "QUALITY" ],
      "x-ms-enum" : {
        "name" : "ReachableAreasCalculationMode",
        "modelAsString" : false
      }
    },
    "ReachableAreasDrivingDirection" : {
      "type" : "string",
      "description" : "Specifies the driving direction, i.e. from start to destination or from destination to start.  \n * `INBOUND` - Indicates an inbound routing from destination to start, i.e. from where the location can be reached within the given horizon. Use this value to calculate the catchment area, e.g. of a school or a hospital.  \n * `OUTBOUND` - Indicates an outbound routing from start to destination, i.e. what area can be reached from the location within the given horizon. Use this value to calculate which can be covered e.g. by an emergency service such as a fire department.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.xroute.ReachableAreasDrivingDirection",
      "enum" : [ "INBOUND", "OUTBOUND" ],
      "x-ms-enum" : {
        "name" : "ReachableAreasDrivingDirection",
        "modelAsString" : false
      }
    },
    "ReachableAreasOptions" : {
      "type" : "object",
      "properties" : {
        "horizons" : {
          "type" : "array",
          "items" : {
            "description" : "The reachability of an area is defined by one or more horizons either by travel time or by distance. If there are no roads within the horizon, the resulting polygon will be empty. If more than one horizon is specified, they have all to be either by travel time or by distance. Furthermore, the values have to be in an ascending order. Otherwise an exceptions.InvalidValueException is thrown. The maximum values for distance-based and travel-time-based horizons can be configured in xserver.conf. By default the calculation is limited to 200 km or 2 hours.",
            "$ref" : "#/definitions/Horizon"
          }
        },
        "calculationMode" : {
          "description" : "Defines the focus of the algorithm, either quality or performance.",
          "$ref" : "#/definitions/ReachableAreasCalculationMode"
        },
        "drivingDirection" : {
          "description" : "Defines whether to calculate the areas which can be reached from the location within the horizons or to calculate the areas from which the location can be reached within the horizons. If exact time consideration is used, use OUTBOUND only with timeconsideration.ExactTimeConsiderationAtStart and INBOUND only with timeconsideration.ExactTimeConsiderationAtArrival. Otherwise a exceptions.ParameterConflictException is thrown.",
          "$ref" : "#/definitions/ReachableAreasDrivingDirection"
        },
        "timeConsideration" : {
          "description" : "Specifies how to evaluate data which contain time restrictions. For the use cases see time consideration. If the object is NULL, all data which have time restrictions are not considered. For some scenarios a reference time is needed to match properties with a time domain against this reference time. If for this time no time zone is defined, i.e. it represents a local time, all waypoints with their dedicated locations are checked for their time zone offsets. If a time zone cannot be determined for such a location, this location is not taken into further consideration. So, in a first step a set of locations with calculated time zones is determined. If this set contains no elements, an exception is thrown. When the time zones differ for some locations, then the time zone containing most locations is used and a result limitation is added to the result. If all locations are in the same time zone, then this time zone is used and the result is calculated as usual.",
          "$ref" : "#/definitions/TimeConsideration"
        },
        "contentSnapshotId" : {
          "type" : "string",
          "description" : "Speficies the content snapshot to use. If no snapshot ID is set, the latest content is used."
        },
        "geographicRestrictions" : {
          "description" : "Specifies geographic restrictions that are considered during the reachable areas calculation.",
          "$ref" : "#/definitions/GeographicRestrictions"
        }
      },
      "description" : "Specifies the options for a reachable areas calculation.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.ReachableAreasOptions"
    },
    "ReachableAreasRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "required" : [ "reachableAreasOptions" ],
        "properties" : {
          "location" : {
            "description" : "The start or destination location. Deprecated: Please use the attribute waypoint offering more possibilities.",
            "$ref" : "#/definitions/RouteLocation"
          },
          "waypoint" : {
            "description" : "The start or destination waypoint. Only the types OffRoadWaypoint, OnRoadWaypoint and PathWaypoint are supported.",
            "$ref" : "#/definitions/InputWaypoint"
          },
          "reachableAreasOptions" : {
            "description" : "The options for the calculation.",
            "$ref" : "#/definitions/ReachableAreasOptions"
          },
          "reachableAreasResultFields" : {
            "description" : "Specifies which fields of the ReachableAreasResponse shall be returned. ReachableAreasResponse.segments can only be retrieved using ReachableAreasOptions.calculationMode QUALITY.",
            "$ref" : "#/definitions/ReachableAreasResultFields"
          }
        },
        "description" : "Specifies the parameters of a reachable areas calculation. The sideOfStreetRestriction will be ignored with any of the given waypoints, a SideOfStreetRestrictionIgnoredLimitation will be returned in that case.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.ReachableAreasRequest"
      } ],
      "x-discriminator-value" : "ReachableAreasRequest",
      "x-ms-discriminator-value" : "ReachableAreasRequest"
    },
    "ReachableAreasResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "properties" : {
          "polygons" : {
            "type" : "array",
            "items" : {
              "description" : "The polygons which represent the reachable areas. For each horizon there is a separate polygon at the same index. If there are no roads within the horizon, the resulting polygon will be empty. In particular, this is the case if the distance or travel time from the location to the next road segment is greater than the horizon when using an routing.OffRoadRouteLocation.",
              "$ref" : "#/definitions/EncodedGeometry"
            }
          },
          "segments" : {
            "type" : "array",
            "items" : {
              "description" : "The consecutive list of all visited segments along the route.\r\n\r\nThe list of segments is only populated if requested by ReachableAreasResultFields.segments.",
              "$ref" : "#/definitions/ReachableAreasSegment"
            }
          }
        },
        "description" : "Contains the result of the calculation of reachable areas for every given horizon.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.ReachableAreasResponse"
      } ],
      "x-discriminator-value" : "ReachableAreasResponse",
      "x-ms-discriminator-value" : "ReachableAreasResponse"
    },
    "ReachableAreasResultFields" : {
      "type" : "object",
      "properties" : {
        "segments" : {
          "description" : "Specifies if and to what extent the ReachableAreasResponse.segments shall be returned. ReachableAreasResponse.segments can only be retrieved using ReachableAreasOptions.calculationMode QUALITY.",
          "$ref" : "#/definitions/ReachableAreasSegmentResultFields"
        },
        "polygons" : {
          "type" : "boolean",
          "description" : "Specifies if ReachableAreasResponse.polygons shall be returned."
        }
      },
      "description" : "Specifies which fields of the ReachableAreasResponse shall be returned\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.ReachableAreasResultFields"
    },
    "ReachableAreasSegment" : {
      "type" : "object",
      "required" : [ "distance", "travelTime" ],
      "properties" : {
        "distance" : {
          "description" : "The accumulated distance of the segment during reachable areas calculation.",
          "type" : "number"
        },
        "travelTime" : {
          "description" : "The accumulated travel time of the segment during reachable areas calculation.",
          "$ref" : "#/definitions/Duration"
        },
        "polyline" : {
          "description" : "The polyline of the segment.",
          "$ref" : "#/definitions/EncodedGeometry"
        },
        "id" : {
          "description" : "The id of the segment.",
          "$ref" : "#/definitions/SegmentId"
        },
        "predecessorIndex" : {
          "description" : "The index of the predecessor segment. Returns -1 if segment has no predecessor.",
          "$ref" : "#/definitions/Index"
        }
      },
      "description" : "A simplified version of a segment, returned by ReachableAreasResponse.segments.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.ReachableAreasSegment"
    },
    "ReachableAreasSegmentResultFields" : {
      "type" : "object",
      "properties" : {
        "enabled" : {
          "type" : "boolean",
          "description" : "Specifies if ReachableAreasResponse.segments shall be returned."
        },
        "polyline" : {
          "type" : "boolean",
          "description" : "Specifies if the segments shall contain the polyline."
        },
        "id" : {
          "type" : "boolean",
          "description" : "Specifies if the segments shall contain the ID."
        },
        "predecessorIndex" : {
          "type" : "boolean",
          "description" : "Specifies if the segments shall contain the predecessor segment index."
        }
      },
      "description" : "Specifies if and to what extent the ReachableAreasResponse.segments shall be returned.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.ReachableAreasSegmentResultFields"
    },
    "ReachableLocation" : {
      "type" : "object",
      "properties" : {
        "distance" : {
          "description" : "The distance from the input waypoint to this location or vice versa.",
          "type" : "number"
        },
        "travelTime" : {
          "description" : "The travel time from the input waypoint to this location or vice versa.",
          "$ref" : "#/definitions/Duration"
        },
        "inputLocationIndex" : {
          "description" : "The index of the reached input location.",
          "$ref" : "#/definitions/Index"
        }
      },
      "description" : "Contains the distance and travel time from the input waypoint to a reached location or vice versa (depending on the request search type).\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.ReachableLocation"
    },
    "ReachableLocationsOptions" : {
      "type" : "object",
      "required" : [ "horizon" ],
      "properties" : {
        "horizon" : {
          "description" : "Specifies the maximum horizon either by travel time or by distance in which the locations should be reached. The maximum values for distance-based and travel-time-based horizons can be configured in xserver.conf. By default the calculation is limited to 200 km or 2 hours.",
          "$ref" : "#/definitions/Horizon"
        },
        "searchType" : {
          "description" : "Specifies the search type to determine the reachable locations.",
          "$ref" : "#/definitions/ReachableLocationsSearchType"
        },
        "timeConsideration" : {
          "description" : "Specifies how to evaluate data which contain time restrictions. For the use cases see time consideration. If the object is NULL, all data which have time restrictions are not considered. For some scenarios a reference time is needed to match properties with a time domain against this reference time. If for this time no time zone is defined, i.e. it represents a local time, all waypoints with their dedicated locations are checked for their time zone offsets. If a time zone cannot be determined for such a location, this location is not taken into further consideration. So, in a first step a set of locations with calculated time zones is determined. If this set contains no elements, an exception is thrown. When the time zones differ for some locations, then the time zone containing most locations is used and a result limitation is added to the result. If all locations are in the same time zone, then this time zone is used and the result is calculated as usual.",
          "$ref" : "#/definitions/TimeConsideration"
        },
        "contentSnapshotId" : {
          "type" : "string",
          "description" : "Specifies the content snapshot to use. If no snapshot ID is set, the latest content is used."
        },
        "geographicRestrictions" : {
          "description" : "Specifies geographic restrictions that are considered during the reachable locations calculation.",
          "$ref" : "#/definitions/GeographicRestrictions"
        }
      },
      "description" : "Specifies the options of a reachability request.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.ReachableLocationsOptions"
    },
    "ReachableLocationsRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "required" : [ "reachableLocationsOptions", "waypoint" ],
        "properties" : {
          "waypoint" : {
            "description" : "The waypoint from which the locations should be checked. Only the types OffRoadWaypoint, OnRoadWaypoint and PathWaypoint are supported.",
            "$ref" : "#/definitions/InputWaypoint"
          },
          "locations" : {
            "type" : "array",
            "items" : {
              "description" : "Locations to be checked to be within the horizon.",
              "$ref" : "#/definitions/RouteLocation"
            }
          },
          "reachableLocationsOptions" : {
            "description" : "The options for the calculation.",
            "$ref" : "#/definitions/ReachableLocationsOptions"
          }
        },
        "description" : "Specifies the parameters of a reachable locations calculation. The sideOfStreetRestriction will be ignored with any of the given waypoints, a SideOfStreetRestrictionIgnoredLimitation will be returned in that case.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.ReachableLocationsRequest"
      } ],
      "x-discriminator-value" : "ReachableLocationsRequest",
      "x-ms-discriminator-value" : "ReachableLocationsRequest"
    },
    "ReachableLocationsResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "properties" : {
          "reachableLocations" : {
            "type" : "array",
            "items" : {
              "description" : "Reachable locations ordered by distance or travel time (depending on the request horizon type)",
              "$ref" : "#/definitions/ReachableLocation"
            }
          },
          "unreachableLocations" : {
            "type" : "array",
            "items" : {
              "description" : "Indexes of the unreachable locations as given in the request locations",
              "$ref" : "#/definitions/Index"
            }
          }
        },
        "description" : "Contains the result of the reachability calculation.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.ReachableLocationsResponse"
      } ],
      "x-discriminator-value" : "ReachableLocationsResponse",
      "x-ms-discriminator-value" : "ReachableLocationsResponse"
    },
    "ReachableLocationsSearchType" : {
      "type" : "string",
      "description" : "Represents the different available search types for calculating the reachable locations.  \n * `LOCATION_REACHABLE_FROM_WAYPOINT` - The location should be reachable from the waypoint in a certain horizon.  \n * `WAYPOINT_REACHABLE_FROM_LOCATION` - The waypoint should be reachable from the location in a certain horizon.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.xroute.ReachableLocationsSearchType",
      "enum" : [ "LOCATION_REACHABLE_FROM_WAYPOINT", "WAYPOINT_REACHABLE_FROM_LOCATION" ],
      "x-ms-enum" : {
        "name" : "ReachableLocationsSearchType",
        "modelAsString" : false
      }
    },
    "ReassignmentMethod" : {
      "type" : "string",
      "description" : "Look at the field encompassing it.  \n * `DECIDE` - Assign locations at territory edges to the territory in which it probably fits best. Might cause territories to be slightly more unbalanced than specified in the request.  \n * `REDUCE` - Only conduct definite assignments to reduce the problem. Other locations are left unassigned for the next iteration.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.clusterplanningprofile.ReassignmentMethod",
      "enum" : [ "DECIDE", "REDUCE" ],
      "x-ms-enum" : {
        "name" : "ReassignmentMethod",
        "modelAsString" : false
      }
    },
    "ReferenceLocationMapping" : {
      "type" : "object",
      "required" : [ "locationId", "referenceLocation" ],
      "properties" : {
        "locationId" : {
          "type" : "string",
          "description" : "The unique identifier of a location that is part of the request. It is checked case sensitively."
        },
        "referenceLocation" : {
          "description" : "The route location that is used as a reference for the location in a distance matrix. It may be equal to the location's route location.",
          "$ref" : "#/definitions/RouteLocation"
        }
      },
      "description" : "A mapping of a location that is part of the request to a route location. The route location is used as a reference, e.g. for distance calculation.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.ReferenceLocationMapping"
    },
    "RegionDescription" : {
      "type" : "object",
      "properties" : {
        "providerName" : {
          "type" : "string",
          "description" : "The name of the data provider, e.g. TomTom or HERE."
        },
        "providerDataVersion" : {
          "type" : "string",
          "description" : "The version number of the data given by the provider. It is not equal to the version number of the PTV map."
        },
        "detailLevel" : {
          "description" : "The detail level of the country or subdivision. According to this level, some data may not be available.",
          "$ref" : "#/definitions/MapDetailLevel"
        }
      },
      "description" : "Description of a country or a subdivision.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.RegionDescription"
    },
    "RegionFeatureLayerTheme" : {
      "type" : "object",
      "properties" : {
        "themeId" : {
          "description" : "The identifier of the theme.",
          "$ref" : "#/definitions/ThemeId"
        },
        "providerName" : {
          "type" : "string",
          "description" : "The name of the data provider of this Feature Layer theme if other than the reference provider name. It is not necessary equal to the name of the data provider of the related map data. Especially traffic incidents data may have other sources than the map data provider. If a theme consists of data from more than one provider, there will be multiple instances of this object."
        },
        "referenceProviderName" : {
          "type" : "string",
          "description" : "The provider name of the map data this Feature Layer theme is based on. For best results the Feature Layer data should match the routing data of the underlying map, therefore this name usually equals the corresponding RegionDescription.providerName."
        },
        "referenceProviderDataVersion" : {
          "type" : "string",
          "description" : "The data version of the map data this Feature Layer theme is based on. For best results the Feature Layer data should match the routing data of the underlying map, therefore this version number usually equals the corresponding RegionDescription.providerDataVersion."
        }
      },
      "description" : "Represents a single Feature Layer theme reflecting the current state of the country or subdivision. Dynamic Feature Layer themes may be added, updated, or removed at any time. Theme IDs may occur more than once when the theme consists of data from more than one provider. Properties valid for the whole map can be found in FeatureLayerTheme.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.RegionFeatureLayerTheme"
    },
    "RegionFeatures" : {
      "type" : "object",
      "properties" : {
        "featureLayerThemes" : {
          "type" : "array",
          "items" : {
            "description" : "List of the available Feature Layer themes. There may be multiple instances for the same theme ID in this list when they have different data providers.",
            "$ref" : "#/definitions/RegionFeatureLayerTheme"
          }
        },
        "tollFeatures" : {
          "description" : "Detailed information about the toll features supported for the country or subdivision. Present only if toll data is available.",
          "$ref" : "#/definitions/RegionTollFeatures"
        }
      },
      "description" : "The features available for the country or a subdivision.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.RegionFeatures"
    },
    "RegionTollFeatures" : {
      "type" : "object",
      "properties" : {
        "detailLevel" : {
          "description" : "The toll detail level of the country or subdivision. According to this level, some data and toll features may not be available.",
          "$ref" : "#/definitions/TollDetailLevel"
        },
        "referenceProviderName" : {
          "type" : "string",
          "description" : "The provider name of the map data this toll data is based on. For best results the data should match the routing data of the underlying map, therefore this name usually equals the corresponding RegionDescription.providerName."
        },
        "referenceProviderDataVersion" : {
          "type" : "string",
          "description" : "The data version of the map data this toll data is based on. For best results the data should match the routing data of the underlying map, therefore this version number usually equals the corresponding RegionDescription.providerDataVersion."
        },
        "electronicTollCollectionSubscriptions" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "description" : "The electronic toll collection subscriptions that are available in the country or subdivision. These values can be set in the vehicle profile as parameter for the toll calculation."
          }
        }
      },
      "description" : "Specifies the available toll data for a region.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.RegionTollFeatures"
    },
    "RejectedRequestFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/XServerFault"
      }, {
        "type" : "object",
        "description" : "This fault is thrown if the request is rejected by the server for some reason.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.RejectedRequestFault"
      } ],
      "x-discriminator-value" : "RejectedRequestFault",
      "x-ms-discriminator-value" : "RejectedRequestFault"
    },
    "Relation" : {
      "type" : "object",
      "required" : [ "destinationLocation", "startLocation" ],
      "properties" : {
        "startLocation" : {
          "description" : "The start location.",
          "$ref" : "#/definitions/RouteLocation"
        },
        "destinationLocation" : {
          "description" : "The destination location.",
          "$ref" : "#/definitions/RouteLocation"
        }
      },
      "description" : "A relation between an start location and a destination location.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdima.Relation"
    },
    "RelativeDirection" : {
      "type" : "integer",
      "format" : "int32",
      "description" : "Defines a direction through the clockwise angle with respect to another direction in degrees \\[??\\]. E.g., at a maneuver event that says \"turn right\" the relative direction would be 90??, whereas \"turn left\" would be -90??. Range: -180 ??? value ??? 180.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.RelativeDirection"
    },
    "RemoveFixationsAction" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ChangeToursAction"
      }, {
        "type" : "object",
        "properties" : {
          "fixations" : {
            "type" : "array",
            "items" : {
              "description" : "Fixations to be removed from the current plan.",
              "$ref" : "#/definitions/Fixation"
            }
          }
        },
        "description" : "A specific action to remove fixations from the current plan. If at least one of the fixations references the ID of a nonexistent object, an exception is thrown and none of the fixations are removed. If one of the fixations is not in the current plan, no exception is thrown but the fixation is just ignored. If one of the fixations exists in the current plan multiple times, all occurences will be removed. However we do not distinguish between one or multiple occurences of a fixation.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.RemoveFixationsAction"
      } ],
      "x-discriminator-value" : "RemoveFixationsAction",
      "x-ms-discriminator-value" : "RemoveFixationsAction"
    },
    "RemoveOrdersAction" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ChangeToursAction"
      }, {
        "type" : "object",
        "properties" : {
          "orderIds" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "description" : "IDs of the orders to be removed."
            }
          }
        },
        "description" : "A specific action to remove orders from the current plan. If removing the orders leads to an empty trip with a trip start interval, the trip start interval is also removed from the input plan.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.RemoveOrdersAction"
      } ],
      "x-discriminator-value" : "RemoveOrdersAction",
      "x-ms-discriminator-value" : "RemoveOrdersAction"
    },
    "RemoveToursAction" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ChangeToursAction"
      }, {
        "type" : "object",
        "properties" : {
          "vehicleIds" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "description" : "IDs of the vehicles of the tours to be removed."
            }
          }
        },
        "description" : "A specific action to remove tours from the current plan. For each removed tour that contained a trip with a trip start interval, the trip start interval is also removed from the input plan.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.RemoveToursAction"
      } ],
      "x-discriminator-value" : "RemoveToursAction",
      "x-ms-discriminator-value" : "RemoveToursAction"
    },
    "RemoveTripStartIntervalsAction" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ChangeToursAction"
      }, {
        "type" : "object",
        "properties" : {
          "tripIds" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "description" : "TripStartIntervals to be removed from the current plan."
            }
          }
        },
        "description" : "A specific action to remove trip start intervals from the current plan. If at least one of the trip IDs references the ID of a nonexistent trip, an exception is thrown and none of the trip start intervals are removed. If for one of the trip ids no trip start interval is specified in the current plan, no exception is thrown but the trip ID is just ignored.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.RemoveTripStartIntervalsAction"
      } ],
      "x-discriminator-value" : "RemoveTripStartIntervalsAction",
      "x-ms-discriminator-value" : "RemoveTripStartIntervalsAction"
    },
    "RemoveTripsAction" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ChangeToursAction"
      }, {
        "type" : "object",
        "properties" : {
          "tripIds" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "description" : "IDs of the trips to be removed."
            }
          }
        },
        "description" : "A specific action to remove trips from the current plan. For each removed trip with a specified trip start interval, the trip start interval is also removed from the input plan.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.RemoveTripsAction"
      } ],
      "x-discriminator-value" : "RemoveTripsAction",
      "x-ms-discriminator-value" : "RemoveTripsAction"
    },
    "RenderBase" : {
      "type" : "string",
      "description" : "Defines the base values for render levels objects can be drawn relative to.  \n * `TOP` - Objects are drawn on top of the map. Nevertheless, several objects with value TOP can be ordered by choosing different renderOffset values.  \n * `TRANSPORT` - Objects are drawn relvative to the transport layer, i.e. roads, railways, etc..\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.renderingprofile.RenderBase",
      "enum" : [ "TOP", "TRANSPORT" ],
      "x-ms-enum" : {
        "name" : "RenderBase",
        "modelAsString" : false
      }
    },
    "RenderLevel" : {
      "type" : "object",
      "properties" : {
        "renderBase" : {
          "description" : "The base is a level in the basemap to which the object in question can be drawn relative to. The render base values do not overlap, e.g. TRANSPORT + x does not overlap TOP - y. It is recommended to use TRANSPORT for displaying lines and TOP for icons.",
          "$ref" : "#/definitions/RenderBase"
        },
        "renderOffset" : {
          "description" : "The render offsets of all objects having the same render base define the order in which the objects are drawn and thus may overlap each other.",
          "$ref" : "#/definitions/RenderOffset"
        }
      },
      "description" : "Defines the level on which the icon is rendered, i.e. on top or below what other objects.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.renderingprofile.RenderLevel"
    },
    "RenderOffset" : {
      "type" : "string",
      "description" : "Negative values like -1 mean that an object is drawn under the roads (if for renderBase is set TRANSPORT). Positive values like +1 mean that the object is drawn on the roads (if for renderBase is set TRANSPORT). Pattern: \\[\\\\+\\\\-\\]\\{1\\}\\\\d+|0.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.RenderOffset"
    },
    "RenderingProfile" : {
      "type" : "object",
      "properties" : {
        "countryStyles" : {
          "type" : "array",
          "items" : {
            "description" : "Defines a map style for a specific country, a set of countries, or for all countries.",
            "$ref" : "#/definitions/CountryStyle"
          }
        }
      },
      "description" : "Defines parameters for rendering features to the map.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.renderingprofile.RenderingProfile"
    },
    "RenderingResultFields" : {
      "type" : "object",
      "properties" : {
        "image" : {
          "type" : "boolean",
          "description" : "Activate the MapResponse.image as a return value."
        },
        "featureThemeIds" : {
          "type" : "array",
          "items" : {
            "description" : "The list of Feature Layer theme IDs for which features are to be returned. Every requested theme must be enabled in the Feature Layer profile.",
            "$ref" : "#/definitions/ThemeId"
          }
        },
        "iconReference" : {
          "type" : "boolean",
          "description" : "Specifies if icon references should be returned with the features."
        }
      },
      "description" : "Options to configure the result fields available in the response and in case of Feature Layer data, the individual themes for which object information should be returned.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xmap.ResultFields"
    },
    "RenderingSize" : {
      "type" : "string",
      "description" : "Defines the type for a rendering size, meaning either a relative percentage value or an explicit pixel size. Pattern: \\\\d+%|\\\\d+px.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.RenderingSize"
    },
    "RenderingStyle" : {
      "type" : "object",
      "required" : [ "displayClass" ],
      "properties" : {
        "ranges" : {
          "type" : "array",
          "items" : {
            "description" : "Defines the ranges of the display class values for which this style shall apply. Ranges must not be overlapping, that means the 'to' value of the lower range has to be smaller than the 'from' value of the higher range. For example 0-50 and 51-100. If empty, the style applies to all values. It is possible to specity both a style with a range (e.g. 0-50) and another one without a range. Values 0-50 will then apply to the style with the range, all others to the one without the range.",
            "$ref" : "#/definitions/Range"
          }
        },
        "roadTypes" : {
          "type" : "array",
          "items" : {
            "description" : "Defines the road types for which this style shall apply. If empty, the style applies to all road types..",
            "$ref" : "#/definitions/RoadType"
          }
        },
        "geometries" : {
          "type" : "array",
          "items" : {
            "description" : "Defines how to render geometries.",
            "$ref" : "#/definitions/GeometryStyle"
          }
        },
        "icons" : {
          "type" : "array",
          "items" : {
            "description" : "Defines how to render icons.",
            "$ref" : "#/definitions/IconStyle"
          }
        },
        "displayClass" : {
          "type" : "string",
          "description" : "The display class of the corresponding Feature Layer theme for which this style shall apply. The list of available display classes can be found in the documentation of the Feature Layer theme. Use '\\*' to specify the fallback style which is used if there is no style defined for a display class."
        },
        "timeRestriction" : {
          "description" : "The time restriction for which this style shall apply.",
          "$ref" : "#/definitions/TimeRestriction"
        }
      },
      "description" : "Defines the style for a class of objects of a Feature Layer theme. The class of objects is defined by specifying displayClass, ranges, timeRestriction, and roadTypes.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.renderingprofile.RenderingStyle"
    },
    "Request" : {
      "type" : "object",
      "required" : [ "calculationTime", "methodName", "requestId", "serviceName" ],
      "properties" : {
        "requestId" : {
          "type" : "string",
          "description" : "ID of this request."
        },
        "serviceName" : {
          "type" : "string",
          "description" : "The used service."
        },
        "methodName" : {
          "type" : "string",
          "description" : "The used method."
        },
        "status" : {
          "description" : "Status of this request. For example RUNNING or QUEUED.",
          "$ref" : "#/definitions/JobStatus"
        },
        "requestInformation" : {
          "type" : "array",
          "items" : {
            "description" : "Additional information. For example progress status.",
            "$ref" : "#/definitions/RequestInformation"
          }
        },
        "finished" : {
          "type" : "string",
          "format" : "date",
          "description" : "Deprecated: inaccurate type assigned, use finishedAt instead."
        },
        "finishedAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "Instant of time when the request ended."
        },
        "calculationTime" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Calculation time of the request."
        }
      },
      "description" : "Represents a single request that is currently executed or has been executed on this xserver.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.Request"
    },
    "RequestBase" : {
      "type" : "object",
      "required" : [ "$type" ],
      "discriminator" : "$type",
      "properties" : {
        "scope" : {
          "description" : "A user defined scope for persistent data like distance matrices.",
          "$ref" : "#/definitions/ScopeName"
        },
        "storedProfile" : {
          "description" : "The URL of the stored profile used by this request. The following types of URLs are supported:\r\n\r\n *  The name of the profile without its extension, e.g. `bicycle`. The corresponding file `bicycle.xml` must be available in the folder `conf/profiles`. Parent profiles must be located in the same folder. Profile names must not contain the special characters '-' and '+' and must not be called 'transport', 'labels', or 'background'.\r\n *  An http url, e.g. `http://localhost:8080/profiles/bicycle.xml` from which the profile must be available. In order to limit the access to outside servers, a whitelist can be configured in `xserver.conf` (see here). Parent profiles are not allowed for http urls.\r\n\r\nThe URL is case-sensitive, although Microsoft Windows also accepts case-insensitive file names.",
          "$ref" : "#/definitions/Url"
        },
        "requestProfile" : {
          "description" : "The profile used by this request (parameters override those from storedProfile).",
          "$ref" : "#/definitions/RequestProfile"
        },
        "coordinateFormat" : {
          "description" : "The coordinate format of all geometries in request and response. The default of EPSG:4326 represents WGS84. For more information see here.",
          "$ref" : "#/definitions/CoordinateFormat"
        },
        "geometryOptions" : {
          "description" : "The target encodings of geometries, PLAIN if empty.",
          "$ref" : "#/definitions/GeometryOptions"
        },
        "timeouts" : {
          "description" : "timeout settings",
          "$ref" : "#/definitions/Timeouts"
        },
        "userLogs" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "description" : "values to be written to the log file (note that they must not contain a semicolon)"
          }
        },
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "Base type for any xServer request type. Contains a RequestProfile.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.service.RequestBase"
    },
    "RequestDeletedFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RejectedRequestFault"
      }, {
        "type" : "object",
        "description" : "This fault is thrown if the request was deleted from the outside, for example via the status monitor.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.RequestDeletedFault"
      } ],
      "x-discriminator-value" : "RequestDeletedFault",
      "x-ms-discriminator-value" : "RequestDeletedFault"
    },
    "RequestInformation" : {
      "type" : "object",
      "required" : [ "key", "value" ],
      "properties" : {
        "key" : {
          "type" : "string",
          "description" : "The key of this information."
        },
        "value" : {
          "type" : "string",
          "description" : "the value of this information."
        }
      },
      "description" : "Represents additional request information as key value pairs. Usually this object holds progress information.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.RequestInformation"
    },
    "RequestProfile" : {
      "type" : "object",
      "properties" : {
        "vehicleProfile" : {
          "description" : "The vehicle profile.",
          "$ref" : "#/definitions/VehicleProfile"
        },
        "featureLayerProfile" : {
          "description" : "The Feature Layer profile.",
          "$ref" : "#/definitions/FeatureLayerProfile"
        },
        "routingProfile" : {
          "description" : "The routing profile.",
          "$ref" : "#/definitions/RoutingProfile"
        },
        "renderingProfile" : {
          "description" : "The rendering profile.",
          "$ref" : "#/definitions/RenderingProfile"
        },
        "clusterPlanningProfile" : {
          "description" : "The cluster planning profile.",
          "$ref" : "#/definitions/ClusterPlanningProfile"
        },
        "mapLanguage" : {
          "description" : "The language used for geographic names that are part of the map. The default x-ptv-DFT means that names are given in the language spoken in that country or region.",
          "$ref" : "#/definitions/LanguageCode"
        },
        "userLanguage" : {
          "description" : "The language of texts such as maneuver or traffic-incident descriptions. If the specified language is not supported, the following fallback languages are used: First, if subtags are present, the primary language is used. Second, English is used. As an example pt-BR ??? pt ??? en. The language of geographic names can be set by the field mapLanguage. As an example the description of a maneuver should be readable by the user but city names which can be found on local signs should be available in that language in order to be recognized.",
          "$ref" : "#/definitions/LanguageCode"
        }
      },
      "description" : "Defines the root type for request profiles. It contains all available profiles and holds global parameters like language settings.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.profile.RequestProfile"
    },
    "RequestTimedOutFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RejectedRequestFault"
      }, {
        "type" : "object",
        "description" : "This fault is thrown if the request ran into a timeout. If this happens frequently, you may have to increase the timeout values in the xServer configuration.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.RequestTimedOutFault"
      } ],
      "x-discriminator-value" : "RequestTimedOutFault",
      "x-ms-discriminator-value" : "RequestTimedOutFault"
    },
    "ResponseBase" : {
      "type" : "object",
      "required" : [ "$type" ],
      "discriminator" : "$type",
      "properties" : {
        "resultLimitations" : {
          "type" : "array",
          "items" : {
            "description" : "A list of limitations that apply to this result. If there are entries in this list, this means that while the server was able to provide a best effort to reply to the request, the limitations to the validity of this result described in this list have to be considered.",
            "$ref" : "#/definitions/ResultLimitation"
          }
        },
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "Base type for any xServer response type. Contains a list of result limitations, which indicates an alleviated quality of the result.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.service.ResponseBase"
    },
    "RestPositions" : {
      "type" : "string",
      "description" : "Indicates at which positions of a tour rests are planned.  \n * `BETWEEN_ALL_TRIPS` - Indicates that a rest is planned directly after every trip of the tour, except after the last trip.  \n * `BETWEEN_TRIPS` - Indicates that a rest may be planned after each trip of the tour if necessary, except after the last trip.  \n * `ANYWHERE` - Indicates that a rest may be scheduled anytime and anywhere necessary, even within a trip and even en route between two stops.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.tourplanning.RestPositions",
      "enum" : [ "BETWEEN_ALL_TRIPS", "BETWEEN_TRIPS", "ANYWHERE" ],
      "x-ms-enum" : {
        "name" : "RestPositions",
        "modelAsString" : false
      }
    },
    "RestrictionMode" : {
      "type" : "string",
      "description" : "Defines the restriction mode how to restrict the route calculation using a bounding box.  \n * `NONE` - No restriction by bounding box.  \n * `AUTOMATIC` - Use a bounding box automatically calculated from the route locations to restrict the search space.  \n * `CUSTOM` - Use the custom bounding box to restrict the search space.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.routing.RestrictionMode",
      "enum" : [ "NONE", "AUTOMATIC", "CUSTOM" ],
      "x-ms-enum" : {
        "name" : "RestrictionMode",
        "modelAsString" : false
      }
    },
    "ResultLimitation" : {
      "type" : "object",
      "required" : [ "$type", "message" ],
      "discriminator" : "$type",
      "properties" : {
        "message" : {
          "type" : "string",
          "description" : "Description of the limitation."
        },
        "hint" : {
          "type" : "string",
          "description" : "Hint on how to resolve this issue."
        },
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "Specific limitation to the validity of a result.\r\n\r\nSee request and response for details on when a result limitation will be returned instead of an exception.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.service.ResultLimitation"
    },
    "RoadAttributes" : {
      "type" : "object",
      "required" : [ "allowedForEmergency", "bridge", "deliveryOnly", "oneWay", "pedestrianZone", "prohibited", "ramp", "residentsOnly", "roundabout", "toll", "tunnel", "urban" ],
      "properties" : {
        "prohibited" : {
          "type" : "boolean",
          "description" : "This segment is usually prohibited for the selected vehicle."
        },
        "toll" : {
          "type" : "boolean",
          "description" : "The segment is part of a toll road. This attribute does not reflect the specific toll pricing conditions, so it is not guaranteed that the selected vehicle has to pay toll for this segment."
        },
        "urban" : {
          "type" : "boolean",
          "description" : "The segment is within an urban, i.e. built-up area. It can be avoided or prohibited during route calculation using the parameter routingprofile.SpecialAreas.urbanPenalty."
        },
        "residentsOnly" : {
          "type" : "boolean",
          "description" : "The segment is within a residents only area. It can be avoided, or prohibited during route calculation using the parameters routingprofile.SpecialAreas.residentsOnlyPenalty."
        },
        "pedestrianZone" : {
          "type" : "boolean",
          "description" : "The segment is within a pedestrian zone. To open, avoid, or block it during route calculation see attribute prohibited."
        },
        "oneWay" : {
          "type" : "boolean",
          "description" : "The segment is a one-way street."
        },
        "roundabout" : {
          "type" : "boolean",
          "description" : "The segment is part of a roundabout."
        },
        "ramp" : {
          "type" : "boolean",
          "description" : "The segment is part of a ramp. It can be avoided or prohibited during route calculation using the parameter routingprofile.Network.rampPenalty."
        },
        "bridge" : {
          "type" : "boolean",
          "description" : "The segment is a bridge."
        },
        "tunnel" : {
          "type" : "boolean",
          "description" : "The segment is a tunnel."
        },
        "deliveryOnly" : {
          "type" : "boolean",
          "description" : "The segment is in a delivery only area. It can be allowed, avoided, or prohibited during route calculation using the parameters routingprofile.SpecialAreas.deliveryOnlyPenalty and vehicleprofile.LegalCondition.isDelivery."
        },
        "allowedForEmergency" : {
          "type" : "boolean",
          "description" : "The segment is allowed for emergency vehicles (see vehicleprofile.LegalCondition.isEmergency)."
        },
        "lowEmissionZoneType" : {
          "type" : "string",
          "description" : "The low-emission zone types the selected vehicle must have to travel this segment. It can be opened, avoided, or prohibited during route calculation using the parameters routingprofile.SpecialAreas.forbiddenLowEmissionZonePenalty and vehicleprofile.Engine.lowEmissionZoneTypes. The available types can be requested through the xRuntime service, e.g. DE\\_GREEN, DE\\_YELLOW, DE\\_RED for Germany."
        }
      },
      "description" : "Legal and physical attributes which describe the road segment in detail.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.segments.RoadAttributes"
    },
    "RoadDescriptor" : {
      "type" : "object",
      "properties" : {
        "roadNumber" : {
          "type" : "string",
          "description" : "The number of a road (e.g. \"A81\"). The road number string may consist of several number entries divided by \"/\"."
        },
        "roadName" : {
          "type" : "string",
          "description" : "The name of a road. The road name string does not depend on the selected language. Instead it is presented as it could be found on local signs."
        }
      },
      "description" : "The descriptive attributes of a road\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.RoadDescriptor"
    },
    "RoadType" : {
      "type" : "string",
      "description" : "Defines the road types present in Feature Layer data..  \n * `MOTORWAY_FREEWAY` - Valid for motorways.  \n * `DUAL_CARRIAGE_HIGHWAY` - Valid for dual highways.  \n * `SINGLE_CARRIAGE_HIGHWAY` - Valid for single highways.  \n * `LOCAL_MAJOR_ROAD` - Valid for local major roads.  \n * `LOCAL_MINOR_ROAD` - Valid for local minor roads.  \n * `URBAN_ROAD` - Valid for urban roads.  \n * `PEDESTRIAN_ZONE` - Valid for pedestrian ways.  \n * `FORESTROADS_AND_WALKWAYS` - Valid for forest roads and walkways.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.renderingprofile.RoadType",
      "enum" : [ "MOTORWAY_FREEWAY", "DUAL_CARRIAGE_HIGHWAY", "SINGLE_CARRIAGE_HIGHWAY", "LOCAL_MAJOR_ROAD", "LOCAL_MINOR_ROAD", "URBAN_ROAD", "PEDESTRIAN_ZONE", "FORESTROADS_AND_WALKWAYS" ],
      "x-ms-enum" : {
        "name" : "RoadType",
        "modelAsString" : false
      }
    },
    "RouteCalculationCriteria" : {
      "type" : "string",
      "description" : "Specifies what the routing algorithm should optimize for.  \n * `ABSTRACT_COSTS` - Calculate the route according to the best abstract costs based on distance time weighting and penalties.  \n * `MONETARY_COSTS` - Calculate the route according to the best monetary costs based on the parameters in the monetary cost options and including toll costs.  \r\nIf set, it is required to specify a currency in the route options.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.routing.RouteCalculationCriteria",
      "enum" : [ "ABSTRACT_COSTS", "MONETARY_COSTS" ],
      "x-ms-enum" : {
        "name" : "RouteCalculationCriteria",
        "modelAsString" : false
      }
    },
    "RouteEvent" : {
      "type" : "object",
      "required" : [ "$type" ],
      "discriminator" : "$type",
      "properties" : {
        "eventType" : {
          "description" : "The type of the current route event.",
          "$ref" : "#/definitions/RouteEventType"
        },
        "startsAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "The point in time at which the event starts. This field is only present if a time-consideration scenario with a reference time is given in the request. The time zone is that of the reference time. Use the UTCOffsetEvent to derive the local time."
        },
        "coordinate" : {
          "description" : "The location at which the event occurs. This coordinate is not necessarily the coordinate of the related node. The event such as a traffic incident can, for example, occur in the middle of a long segment. This coordinate is designed to draw an icon on a map to mark the event.",
          "$ref" : "#/definitions/Coordinate"
        },
        "nodeIndex" : {
          "description" : "The index of the node in the RouteResponse.nodes list. As every segment starts at the node with the same index, it is also equal to the segment in the RouteResponse.segments list, if present, except for the very last index. This field is only present if the list of nodes is present.",
          "$ref" : "#/definitions/Index"
        },
        "distanceFromStart" : {
          "description" : "The distance of the route from the start up to this event.",
          "type" : "number"
        },
        "travelTimeFromStart" : {
          "description" : "The travel time for the route from the start up to this event.",
          "$ref" : "#/definitions/Duration"
        },
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "Base type for all route events which can appear in the RouteResponse. It contains information common to all event types. See the technical concept for more information.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.RouteEvent"
    },
    "RouteEventType" : {
      "type" : "string",
      "description" : "Enumeration of the different RouteEvent types returned by a routing operation.  \n * `MANEUVER_EVENT` - This event type indicates that the driver has to take an action, e.g. turn left or right.  \n * `TOUR_EVENT` - This event type indicates that a tour information is available at this position.  \n * `TOLL_EVENT` - This event type indicates that a toll road is entered, exited or a toll booth is passed.  \n * `WAYPOINT_EVENT` - This event type indicates that a waypoint is reached by the route.  \n * `ROUTE_VIOLATION_EVENT` - This event type indicates that there is a route violation starting or ending at this position.  \n * `UTC_OFFSET_EVENT` - This event type indicates that the offset to UTC changes.  \n * `COUNTRY_EVENT` - This event type indicates that a border between countries or subdivisions is crossed, i.e. the country code changes.  \n * `COMBINED_TRANSPORT_EVENT` - This event type indicates that a combined transport is entered or exited.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.xroute.RouteEventType",
      "enum" : [ "MANEUVER_EVENT", "TOUR_EVENT", "TOLL_EVENT", "WAYPOINT_EVENT", "ROUTE_VIOLATION_EVENT", "UTC_OFFSET_EVENT", "COUNTRY_EVENT", "COMBINED_TRANSPORT_EVENT" ],
      "x-ms-enum" : {
        "name" : "RouteEventType",
        "modelAsString" : false
      }
    },
    "RouteLocation" : {
      "type" : "object",
      "required" : [ "$type" ],
      "discriminator" : "$type",
      "properties" : {
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "The base type for locations which will be used in route calculation. See route locations documentation for details.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.routing.RouteLocation"
    },
    "RouteNotFoundFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ProcessingFault"
      }, {
        "type" : "object",
        "description" : "This fault is thrown if a route between the given waypoints could not be found with the current configuration and profile. This may be caused by road blockings without the possibility of a detour.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.RouteNotFoundFault"
      } ],
      "x-discriminator-value" : "RouteNotFoundFault",
      "x-ms-discriminator-value" : "RouteNotFoundFault"
    },
    "RouteOptions" : {
      "type" : "object",
      "properties" : {
        "timeConsideration" : {
          "description" : "Specifies how to evaluate data which contain time restrictions. For the use cases see time consideration. If the object is NULL, all data which have time restrictions are not considered. For some scenarios a reference time is needed to match properties with a time domain against this reference time. If for this time no time zone is defined, i.e. it represents a local time, all waypoints with their dedicated locations are checked for their time zone offsets. If a time zone cannot be determined for such a location, this location is not taken into further consideration. So, in a first step a set of locations with calculated time zones is determined. If this set contains no elements, an exception is thrown. When the time zones differ for some locations, then the time zone containing most locations is used and a result limitation is added to the result. If all locations are in the same time zone, then this time zone is used and the result is calculated as usual. Please note that the time-consideration scenarios ExactTimeConsiderationAtStart and ExactTimeConsiderationAtArrival are not applicable in combination with routing types RoutingType.HIGH\\_PERFORMANCE\\_ROUTING and RoutingType.HIGH\\_PERFORMANCE\\_ROUTING\\_WITH\\_FALLBACK\\_CONVENTIONAL and will result respectively in an exception and a result limitation.",
          "$ref" : "#/definitions/TimeConsideration"
        },
        "contentSnapshotId" : {
          "type" : "string",
          "description" : "Specifies the content snapshot to use. If no snapshot ID is set, the most recent content is used."
        },
        "highPerformanceRoutingNetworkId" : {
          "type" : "string",
          "description" : "Specifies the high-performance routing network to use. Besides, the routing type must be explicitly set to RoutingType.HIGH\\_PERFORMANCE\\_ROUTING otherwise a exceptions.ParameterConflictException is thrown. The profile and request parameters of the high-performance routing network are used for linking and routing. The stored profile of the service.RequestBase will be ignored. Throws a exceptions.DataNotAvailableException if the high-performance routing network with the given id does not exist."
        },
        "geographicRestrictions" : {
          "description" : "Specifies geographic restrictions that are considered during the route calculation.",
          "$ref" : "#/definitions/GeographicRestrictions"
        },
        "polylineOptions" : {
          "description" : "Specifies how the polyline shall be calculated.",
          "$ref" : "#/definitions/PolylineOptions"
        },
        "emissionOptions" : {
          "description" : "Specifies what emissions shall be calculated.",
          "$ref" : "#/definitions/EmissionOptions"
        },
        "effectiveFuelConsumption" : {
          "description" : "Specifies the fuel consumption values.",
          "$ref" : "#/definitions/EffectiveFuelConsumption"
        },
        "tollOptions" : {
          "description" : "Specifies how the toll shall be calculated.",
          "$ref" : "#/definitions/TollOptions"
        },
        "routingType" : {
          "description" : "Strategy to decide if high-performance routing or conventional routing is used. For further explanation see the definition of RoutingType.",
          "$ref" : "#/definitions/RoutingType"
        },
        "tourRestrictions" : {
          "description" : "Specifies how to calculate the tour information.",
          "$ref" : "#/definitions/RoutingTourRestrictions"
        },
        "calculationCriteria" : {
          "description" : "Specifies what the route calculation should optimize for. See the technical concept on route calculation for details.  \r\nIf the calculation criteria is set to MONETARY\\_COSTS, it is required to specify a currency in the route options.",
          "$ref" : "#/definitions/RouteCalculationCriteria"
        },
        "monetaryCostOptions" : {
          "description" : "Specifies how to calculate the monetary costs of a route.",
          "$ref" : "#/definitions/MonetaryCostOptions"
        },
        "binaryFeatureLayer" : {
          "description" : "Binary Feature Layer to be considered while calculating route.",
          "$ref" : "#/definitions/EncodedContent"
        },
        "etaCalculationOptions" : {
          "description" : "Specifies the options related to the calculation of the Estimated Time of Arrival (ETA).",
          "$ref" : "#/definitions/ETACalculationOptions"
        },
        "currency" : {
          "description" : "Specifies the currency for costs both in the request and the response.",
          "$ref" : "#/definitions/CurrencyCode"
        },
        "exchangeRates" : {
          "description" : "Specifies the exchange rates that should be used for the toll price conversion to the target currency.",
          "$ref" : "#/definitions/ExchangeRates"
        }
      },
      "description" : "Specifies how to calculate the route and how to fill the ResultFields which are enabled.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.RouteOptions"
    },
    "RouteReport" : {
      "type" : "object",
      "properties" : {
        "routingType" : {
          "description" : "Strategy used in the route calculation (high-performance routing or conventional routing). For further explanation see the definition of RoutingType.",
          "$ref" : "#/definitions/RoutingType"
        }
      },
      "description" : "Represents the summary of a route which has been calculated.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.RouteReport"
    },
    "RouteRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "properties" : {
          "waypoints" : {
            "type" : "array",
            "items" : {
              "description" : "List of waypoints to consider during routing.",
              "$ref" : "#/definitions/InputWaypoint"
            }
          },
          "routeOptions" : {
            "description" : "Specifies how to calculate the route and how to fill the ResultFields which are enabled.",
            "$ref" : "#/definitions/RouteOptions"
          },
          "resultFields" : {
            "description" : "Specifies which fields of the RouteResponse shall be returned.",
            "$ref" : "#/definitions/RoutingResultFields"
          }
        },
        "description" : "Specifies the route to be calculated.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.RouteRequest"
      } ],
      "x-discriminator-value" : "RouteRequest",
      "x-ms-discriminator-value" : "RouteRequest"
    },
    "RouteResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "required" : [ "distance", "travelTime", "violated" ],
        "properties" : {
          "distance" : {
            "description" : "The distance of the complete route. It is the sum of distances of all segments and hence is a whole number without decimal places (see Segment.distance). It equals the sum of distances of all legs.",
            "type" : "number"
          },
          "travelTime" : {
            "description" : "The travel time for the complete route. It is the sum of travel times of all segments and hence has up to three decimal places (see Segment.travelTime). It equals the sum of travel times of all legs.",
            "$ref" : "#/definitions/Duration"
          },
          "trafficDelay" : {
            "description" : "The total delay due to traffic incidents (traffic jams, construction sites etc.) on the route.\r\n\r\nFor each section of the route where traffic incidents are present, the delay is calculated comparing the travel time for that section with and without traffic incidents. That means the delay contains the time that it takes longer to pass the traffic jam than usually at the same time and the same day of week. As an example, driving a section on a highway between two exits usually takes 15 minutes on an average Friday afternoon at 4 pm, but due to a road works there is a traffic jam on this specific Friday afternoon at 4 pm, and driving this section takes 30 minutes. The delay will be 15 minutes.\r\n\r\nThis value will be non-zero only when Feature Layer PTV\\_TrafficIncidents is enabled and one of the time-consideration scenarios ExactTimeConsiderationAtStart and ExactTimeConsiderationAtArrival is used.",
            "$ref" : "#/definitions/Duration"
          },
          "waypoints" : {
            "type" : "array",
            "items" : {
              "description" : "The consecutive list of all waypoints along the route.\r\n\r\nThe list of waypoints is only populated if requested by ResultFields.waypoints.",
              "$ref" : "#/definitions/Waypoint"
            }
          },
          "legs" : {
            "type" : "array",
            "items" : {
              "description" : "The consecutive list of all legs of which the route consists.\r\n\r\nThe list of legs is only populated if requested by ResultFields.legs.",
              "$ref" : "#/definitions/Leg"
            }
          },
          "segments" : {
            "type" : "array",
            "items" : {
              "description" : "The consecutive list of all visited segments along the route. Besides actual segments in the underlying routing network this includes virtual segments created when linking a user-provided coordinate into the routing network.\r\n\r\nThe list of segments is only populated if requested by ResultFields.segments.",
              "$ref" : "#/definitions/Segment"
            }
          },
          "nodes" : {
            "type" : "array",
            "items" : {
              "description" : "The consecutive list of all visited nodes along the route. Besides actual nodes in the underlying routing network this includes virtual nodes created when linking a user-provided coordinate into the routing network.\r\n\r\nThe list of nodes is only populated if requested by ResultFields.nodes.",
              "$ref" : "#/definitions/Node"
            }
          },
          "events" : {
            "type" : "array",
            "items" : {
              "description" : "The consecutive list of all visited route events along the route.\r\n\r\nThe list of route events is only populated if requested by ResultFields.eventTypes.",
              "$ref" : "#/definitions/RouteEvent"
            }
          },
          "polyline" : {
            "description" : "The polyline of the complete route. This polyline consists of all coordinates representing the route and can be used to draw the route into a map.\r\n\r\nIt is only returned if requested by ResultFields.polyline. It contains elevations only if requested by PolylineOptions.elevations.\r\n\r\nIf the elevations data do not cover the complete polyline, an ElevationsNotAvailableLimitation will be available which states which parts of the polyline are not covered.",
            "$ref" : "#/definitions/EncodedGeometry"
          },
          "toll" : {
            "description" : "The toll information for the complete route.\r\n\r\nIt is only returned if requested by ResultFields.toll.",
            "$ref" : "#/definitions/TollResult"
          },
          "emissions" : {
            "description" : "The emissions along the route.",
            "$ref" : "#/definitions/Emissions"
          },
          "encodedPath" : {
            "description" : "The encoded string describing the complete path of the calculated route. Use this string as an input of another route request to calculate the same route with different parameters.",
            "$ref" : "#/definitions/EncodedContent"
          },
          "guidedNavigationRoute" : {
            "type" : "string",
            "format" : "byte",
            "description" : "A base64 encoded representation of the route that can be used for guided navigation. Calculating a guided navigation route requires maneuver events which have to be requested separately. The base64 binary has to be decoded and saved as text file and can then be imported in PTV Navigator and used for navigation."
          },
          "tourReport" : {
            "description" : "The report regarding the tour calculation.",
            "$ref" : "#/definitions/RoutingTourReport"
          },
          "violated" : {
            "type" : "boolean",
            "description" : "If set to true, indicates that this route contains a violation for the chosen vehicle."
          },
          "report" : {
            "description" : "The report regarding the route calculation.",
            "$ref" : "#/definitions/RouteReport"
          },
          "monetaryCostsReport" : {
            "description" : "The monetary costs of the route. They are only returned if requested by ResultFields.monetaryCostsReport.",
            "$ref" : "#/definitions/MonetaryCostsReport"
          },
          "etaCalculationReport" : {
            "description" : "The report regarding the calculation of the estimated time of arrival.",
            "$ref" : "#/definitions/ETACalculationReport"
          },
          "alternativeRoutes" : {
            "type" : "array",
            "items" : {
              "description" : "The alternative routes to the current route, in best to worst order.",
              "$ref" : "#/definitions/AlternativeRoute"
            }
          }
        },
        "description" : "Contains the result of a route request, i.e. the route and various result lists.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.RouteResponse"
      } ],
      "x-discriminator-value" : "RouteResponse",
      "x-ms-discriminator-value" : "RouteResponse"
    },
    "RouteViolation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TourViolation"
      }, {
        "type" : "object",
        "description" : "Specifies a violation where the route between two locations is calculated with route violations, e.g. a violation of the clearance height by the vehicle. This violation can only occur if ignore route violations is not set. This violation has the following tour violation type: ROUTE.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.tourplanning.RouteViolation"
      } ],
      "x-discriminator-value" : "RouteViolation",
      "x-ms-discriminator-value" : "RouteViolation"
    },
    "RouteViolationEvent" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RouteEvent"
      }, {
        "type" : "object",
        "properties" : {
          "violationType" : {
            "description" : "The reason of the violation.",
            "$ref" : "#/definitions/RouteViolationType"
          },
          "violatedFeature" : {
            "description" : "The feature which is violated in case of violationType FEATURE.",
            "$ref" : "#/definitions/ViolatedFeature"
          },
          "accessType" : {
            "description" : "Indicates how a range of segments with the same kind of violation is accessed.",
            "$ref" : "#/definitions/AccessType"
          },
          "relatedEventIndex" : {
            "description" : "For accessType ENTER this index points to the corresponding event with accessType EXIT and vice-versa. Not present otherwise.",
            "$ref" : "#/definitions/Index"
          }
        },
        "description" : "This event indicates the entering or exiting of an area where passing with the current vehicle is prohibited, but inevitable to find a route at all. The corresponding segments or nodes have the violated flag set. See the technical concept for more information.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.RouteViolationEvent"
      } ],
      "x-discriminator-value" : "RouteViolationEvent",
      "x-ms-discriminator-value" : "RouteViolationEvent"
    },
    "RouteViolationType" : {
      "type" : "string",
      "description" : "Indicates due to what reason a route violation occurs.  \n * `PROHIBITED` - The violated segment is prohibited in general for the current vehicle. See road attribute 'prohibited'.  \n * `DELIVERY_ONLY` - The violated segment is prohibited except for delivery reasons but delivery is disallowed for the current vehicle. See road attribute 'deliveryOnly'.  \n * `URBAN` - The violated segment is prohibited because it is flagged as urban. See road attribute 'urban'.  \n * `RESIDENTS_ONLY` - The violated segment is prohibited because it is flagged as residents only for the current vehicle. See road attribute 'residentsOnly'.  \n * `RESTRICTED_ACCESS` - A point with restricted access, e.g. a gate or a bollard was passed.  \n * `FEATURE` - The violated segment has an attribute from some enabled Feature Layer theme which prohibits to pass with the current vehicle (e.g. a weight or height restriction).  \n * `COMBINED_TRANSPORT` - The violated segment is a ferry or a piggyback prohibited for the current vehicle.  \n * `PROHIBITED_BY_INTERSECTING_POLYLINE` - The violated segment is prohibited by an intersecting polyline.  \n * `UNSPECIFIED` - Fallback value to be substituted for enumeration values which were added in an API version that is newer than the request version.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.xroute.RouteViolationType",
      "enum" : [ "PROHIBITED", "DELIVERY_ONLY", "URBAN", "RESIDENTS_ONLY", "RESTRICTED_ACCESS", "FEATURE", "COMBINED_TRANSPORT", "PROHIBITED_BY_INTERSECTING_POLYLINE", "UNSPECIFIED" ],
      "x-ms-enum" : {
        "name" : "RouteViolationType",
        "modelAsString" : false
      }
    },
    "RoutingPositionAtStop" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RoutingVehiclePosition"
      }, {
        "type" : "object",
        "required" : [ "serviceStatus", "waypointIndex" ],
        "properties" : {
          "waypointIndex" : {
            "description" : "Zero based index of the current waypoint in the route.",
            "$ref" : "#/definitions/Index"
          },
          "serviceStatus" : {
            "description" : "Specifies if service has not started yet, if service is currently being performed or if service is completed.",
            "$ref" : "#/definitions/ServiceStatus"
          }
        },
        "description" : "The vehicle is located on a waypoint. In this use case, it is required to specify the status of the service.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.PositionAtStop"
      } ],
      "x-discriminator-value" : "PositionAtStop",
      "x-ms-discriminator-value" : "PositionAtStop"
    },
    "RoutingProfile" : {
      "type" : "object",
      "properties" : {
        "linking" : {
          "description" : "Defines the behavior of linking a route location to the road network. For example, finding the road segment with the smallest distance to the route location.",
          "$ref" : "#/definitions/Linking"
        },
        "searchSpace" : {
          "description" : "Defines the behavior of heuristics for search space reduction. The search space is the part of the routing graph that is explored to answer a route request and thus has a direct impact on the routing performance and quality.",
          "$ref" : "#/definitions/SearchSpace"
        },
        "course" : {
          "description" : "Defines the parameters of the routing algorithm that control the course of the route.",
          "$ref" : "#/definitions/Course"
        }
      },
      "description" : "Defines the routing parameters.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.routingprofile.RoutingProfile"
    },
    "RoutingResultFields" : {
      "type" : "object",
      "properties" : {
        "waypoints" : {
          "type" : "boolean",
          "description" : "Specifies if the RouteResponse.waypoints shall be returned for the complete route."
        },
        "legs" : {
          "description" : "Specifies if and to what extent the RouteResponse.legs shall be returned for the complete route.",
          "$ref" : "#/definitions/LegResultFields"
        },
        "segments" : {
          "description" : "Specifies if and to what extent the RouteResponse.segments shall be returned for the complete route.",
          "$ref" : "#/definitions/SegmentResultFields"
        },
        "nodes" : {
          "type" : "boolean",
          "description" : "Specifies if the RouteResponse.nodes shall be returned for the complete route."
        },
        "eventTypes" : {
          "type" : "array",
          "items" : {
            "description" : "Specifies which RouteEvent types shall be returned for the complete route.",
            "$ref" : "#/definitions/RouteEventType"
          }
        },
        "polyline" : {
          "type" : "boolean",
          "description" : "Specifies if the RouteResponse.polyline shall be returned for the complete route. In order to return the RouteResponse.polyline for legs and segments, enable LegResultFields.polyline and SegmentResultFields.polyline. In order to obtain the elevations for the RouteResponse.polyline, enable PolylineOptions.elevations in RouteOptions."
        },
        "toll" : {
          "description" : "Specifies if and to what extent the RouteResponse.toll shall be returned for the complete route.",
          "$ref" : "#/definitions/TollResultFields"
        },
        "emissions" : {
          "type" : "boolean",
          "description" : "Specifies if the RouteResponse.emissions shall be returned for the complete route."
        },
        "report" : {
          "type" : "boolean",
          "description" : "Specifies if the RouteResponse.report shall be returned for the complete route."
        },
        "tourReport" : {
          "type" : "boolean",
          "description" : "Specifies if the RouteResponse.tourReport shall be returned for the complete route."
        },
        "encodedPath" : {
          "type" : "boolean",
          "description" : "Specifies if the RouteResponse.encodedPath shall be returned for the complete route."
        },
        "guidedNavigationRoute" : {
          "type" : "boolean",
          "description" : "Specifies if the RouteResponse.guidedNavigationRoute shall be returned for the complete route.  \r\nSetting this parameter to true requires a detailed list of maneuver events, which have to be requested separately by adding the RouteEventType MANEUVER\\_EVENT to the list of eventTypes in the result fields.  \r\nThis feature therefore may consume some additional computation time and returns a list of maneuver events in the response."
        },
        "monetaryCostsReport" : {
          "type" : "boolean",
          "description" : "Specifies if the RouteResponse.monetaryCostsReport shall be returned for the complete route.  \r\nIf requested, it is required to specify a currency in the route options."
        },
        "alternativeRoutes" : {
          "type" : "boolean",
          "description" : "Specifies if the RouteResponse.alternativeRoutes shall be returned.  \r\nIn addition to the optimal route up to three alternatives are returned. Note that sometimes no alternative routes are returned because possible alternatives are not considered as practical with regards to detour or sharing with the optimal route.  \r\nNote that this is only supported with requests with exactly two input waypoints of types OnRoadWaypoint or OffRoadWaypoint, otherwise, an exception will be thrown."
        }
      },
      "description" : "Specifies which fields of the RouteResponse shall be returned.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.ResultFields"
    },
    "RoutingTourEvent" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RouteEvent"
      }, {
        "type" : "object",
        "required" : [ "duration" ],
        "properties" : {
          "tourEventTypes" : {
            "type" : "array",
            "items" : {
              "description" : "Tour event types of this event. An event can have several types, such as WAITING and BREAK.",
              "$ref" : "#/definitions/TourEventType"
            }
          },
          "tourViolations" : {
            "type" : "array",
            "items" : {
              "description" : "Tour violations of this event.",
              "$ref" : "#/definitions/TourViolation"
            }
          },
          "duration" : {
            "description" : "Duration of this event.",
            "$ref" : "#/definitions/Duration"
          }
        },
        "description" : "This event indicates that a tour information happens at this position on the route. Basically, a tour event is related to an action which is not driving; e.g. a break period, a rest period, a service period to be performed, waiting time,...\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.TourEvent"
      } ],
      "x-discriminator-value" : "TourEvent",
      "x-ms-discriminator-value" : "TourEvent"
    },
    "RoutingTourReport" : {
      "type" : "object",
      "properties" : {
        "violated" : {
          "type" : "boolean",
          "description" : "If set to true, indicates that this tour contains a tour violation."
        },
        "startTime" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "The start date/time of the tour."
        },
        "endTime" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "The end date/time of the tour."
        },
        "serviceTime" : {
          "description" : "The total service time of the tour.",
          "$ref" : "#/definitions/Duration"
        },
        "drivingTime" : {
          "description" : "The total driving time of the tour",
          "$ref" : "#/definitions/Duration"
        },
        "waitingTime" : {
          "description" : "The total waiting time of the tour",
          "$ref" : "#/definitions/Duration"
        },
        "breakTime" : {
          "description" : "The total break time of the tour",
          "$ref" : "#/definitions/Duration"
        },
        "restTime" : {
          "description" : "The total rest time of the tour",
          "$ref" : "#/definitions/Duration"
        }
      },
      "description" : "Represents the summary of the tour which has been calculated.\r\n\r\nPlease note that the total travel time of the tour is equal to the travel time of the route (see RouteResponse.travelTime).\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.TourReport"
    },
    "RoutingTourRestrictions" : {
      "type" : "object",
      "properties" : {
        "maximumTravelTimePerTour" : {
          "description" : "Restricts the maximum allowed total travel time per tour in seconds. The travel time contains all waiting, service and driving times. Drivers' working hours may be more restrictive and enforce a lower limit. Is infinite if it is not set.",
          "$ref" : "#/definitions/Duration"
        },
        "maximumDrivingTimePerTour" : {
          "description" : "Restricts the maximum allowed total driving time per tour in seconds. Drivers' working hours may be more restrictive and enforce a lower limit. Is infinite if it is not set. Not supported for time dependent driving times.",
          "$ref" : "#/definitions/Duration"
        },
        "workingHours" : {
          "description" : "Defines the rules regarding drivers' working hours. Drivers' working hours are only active if this member is set.",
          "$ref" : "#/definitions/WorkingHours"
        },
        "workLogbookSummary" : {
          "description" : "The summary of a logbook of a driver. If such a summary is missing, it is assumed that the driver is fully rested.",
          "$ref" : "#/definitions/WorkLogbookSummary"
        }
      },
      "description" : "Specifies the all the information to take into account to calculate the tour.\r\n\r\nPlease note that if tourplanning.MultiDayWorkingHours is selected, the tourplanning.MultiDayWorkingHours.dailyRestPositions field has to be set explicitly to tourplanning.RestPositions.ANYWHERE.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.TourRestrictions"
    },
    "RoutingType" : {
      "type" : "string",
      "description" : "Represents the type of the route calculation algorithm. It can be used as input parameter or the type is reported, for instance as part of a distance matrix calculation.  \n * `CONVENTIONAL` - Route calculation based on a standard algorithm. Heuristic elements are used to improve performance. If this element is used as input it the routing is forced to use the conventional algorithm.  \n * `HIGH_PERFORMANCE_ROUTING_WITH_FALLBACK_CONVENTIONAL` - This element is used only as input. It indicates that the service tries to use a high-performance routing network, and if no adequate data is found conventional routing is used instead.  \n * `HIGH_PERFORMANCE_ROUTING` - High-performance route calculation based on pre-calculated, profile-dependent additional routing networks. If it is used as input and no such network which fits the current profile settings is available an exception is thrown.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.routing.RoutingType",
      "enum" : [ "CONVENTIONAL", "HIGH_PERFORMANCE_ROUTING_WITH_FALLBACK_CONVENTIONAL", "HIGH_PERFORMANCE_ROUTING" ],
      "x-ms-enum" : {
        "name" : "RoutingType",
        "modelAsString" : false
      }
    },
    "RoutingVehiclePosition" : {
      "type" : "object",
      "required" : [ "$type" ],
      "discriminator" : "$type",
      "properties" : {
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "Position of the vehicle.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.VehiclePosition"
    },
    "RuntimeInformation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "required" : [ "clientIsAdmin", "uptime" ],
        "properties" : {
          "serviceInformation" : {
            "type" : "array",
            "items" : {
              "description" : "Information on active services and methods.",
              "$ref" : "#/definitions/ServiceInformation"
            }
          },
          "memoryStatistics" : {
            "description" : "Statistics on server memory.",
            "$ref" : "#/definitions/MemoryStatistics"
          },
          "versionInformation" : {
            "description" : "Information about the server's versions.",
            "$ref" : "#/definitions/VersionInformation"
          },
          "environment" : {
            "description" : "Information about the server's environment (CPU, Cores, ...).",
            "$ref" : "#/definitions/Environment"
          },
          "moduleInstances" : {
            "type" : "array",
            "items" : {
              "description" : "Information on single module instances.",
              "$ref" : "#/definitions/ModuleInstance"
            }
          },
          "activeRequests" : {
            "type" : "array",
            "items" : {
              "description" : "Information about the currently running requests.",
              "$ref" : "#/definitions/Request"
            }
          },
          "uptime" : {
            "description" : "The server uptime.",
            "$ref" : "#/definitions/Nanoseconds"
          },
          "clientIsAdmin" : {
            "type" : "boolean",
            "description" : "Specifies if the current client has admin privileges."
          }
        },
        "description" : "Provides information about the server.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.RuntimeInformation"
      } ],
      "x-discriminator-value" : "RuntimeInformation",
      "x-ms-discriminator-value" : "RuntimeInformation"
    },
    "RuntimeInformationRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "properties" : {
          "resultFields" : {
            "description" : "Specifies which fields of the RuntimeInformation shall be returned.",
            "$ref" : "#/definitions/RuntimeResultFields"
          }
        },
        "description" : "Specifies the RuntimeInformation that should be returned.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.RuntimeInformationRequest"
      } ],
      "x-discriminator-value" : "RuntimeInformationRequest",
      "x-ms-discriminator-value" : "RuntimeInformationRequest"
    },
    "RuntimeResultFields" : {
      "type" : "object",
      "properties" : {
        "versionInformation" : {
          "type" : "boolean",
          "description" : "If true, version information is returned."
        },
        "serviceInformation" : {
          "type" : "boolean",
          "description" : "If true, information on active services and methods are returned."
        },
        "memoryStatistics" : {
          "type" : "boolean",
          "description" : "If true, memory statistics are included in the result."
        },
        "environment" : {
          "type" : "boolean",
          "description" : "If true, server environment information is included in the result."
        },
        "moduleInstances" : {
          "type" : "boolean",
          "description" : "If true, information on the module instances is included in the result."
        },
        "activeRequests" : {
          "type" : "boolean",
          "description" : "If true, statistics on the currently running requests are included in the result."
        }
      },
      "description" : "This type specifies what to include in the RuntimeInformation object.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.RuntimeResultFields"
    },
    "Scope" : {
      "type" : "string",
      "description" : "Defines which labels are taken into account to resolve overlapping.  \n * `ALL` - Labels of this theme shall not overlap any other label including those of the basemap, e.g. road or town names or road signs.  \n * `FEATURE_LAYER_LABELS` - Labels of this theme shall not overlap other labels of this or any other theme, but they may overlap labels of the basemap.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.renderingprofile.Scope",
      "enum" : [ "ALL", "FEATURE_LAYER_LABELS" ],
      "x-ms-enum" : {
        "name" : "Scope",
        "modelAsString" : false
      }
    },
    "ScopeName" : {
      "type" : "string",
      "description" : "The name of the scope. Pattern: \\[a-z0-9\\]+.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.ScopeName"
    },
    "SearchByAddressBulkRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/SearchLocationsBulkRequest"
      }, {
        "type" : "object",
        "properties" : {
          "addresses" : {
            "type" : "array",
            "items" : {
              "description" : "The list of addresses to search.",
              "$ref" : "#/definitions/Address"
            }
          }
        },
        "description" : "Search for locations using a list of structured address inputs.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xlocate.SearchByAddressBulkRequest"
      } ],
      "x-discriminator-value" : "SearchByAddressBulkRequest",
      "x-ms-discriminator-value" : "SearchByAddressBulkRequest"
    },
    "SearchByAddressRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/SearchLocationsRequest"
      }, {
        "type" : "object",
        "required" : [ "address" ],
        "properties" : {
          "address" : {
            "description" : "The address to search.",
            "$ref" : "#/definitions/Address"
          }
        },
        "description" : "Search for locations using structured address input.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xlocate.SearchByAddressRequest"
      } ],
      "x-discriminator-value" : "SearchByAddressRequest",
      "x-ms-discriminator-value" : "SearchByAddressRequest"
    },
    "SearchByPositionBulkRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/SearchLocationsBulkRequest"
      }, {
        "type" : "object",
        "properties" : {
          "coordinates" : {
            "type" : "array",
            "items" : {
              "description" : "The list of coordinates to search.",
              "$ref" : "#/definitions/Coordinate"
            }
          }
        },
        "description" : "Search for locations using a list of coordinate inputs.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xlocate.SearchByPositionBulkRequest"
      } ],
      "x-discriminator-value" : "SearchByPositionBulkRequest",
      "x-ms-discriminator-value" : "SearchByPositionBulkRequest"
    },
    "SearchByPositionRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/SearchLocationsRequest"
      }, {
        "type" : "object",
        "required" : [ "coordinate" ],
        "properties" : {
          "coordinate" : {
            "description" : "The input coordinate to search.",
            "$ref" : "#/definitions/Coordinate"
          }
        },
        "description" : "Search for addresses using structured coordinate input.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xlocate.SearchByPositionRequest"
      } ],
      "x-discriminator-value" : "SearchByPositionRequest",
      "x-ms-discriminator-value" : "SearchByPositionRequest"
    },
    "SearchByTextBulkRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/SearchLocationsBulkRequest"
      }, {
        "type" : "object",
        "properties" : {
          "texts" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "description" : "The list of addresses to search."
            }
          }
        },
        "description" : "Search for locations using a list of free-form text inputs.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xlocate.SearchByTextBulkRequest"
      } ],
      "x-discriminator-value" : "SearchByTextBulkRequest",
      "x-ms-discriminator-value" : "SearchByTextBulkRequest"
    },
    "SearchByTextRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/SearchLocationsRequest"
      }, {
        "type" : "object",
        "required" : [ "text" ],
        "properties" : {
          "text" : {
            "type" : "string",
            "description" : "The input address."
          }
        },
        "description" : "Search for locations using a free-form text input.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xlocate.SearchByTextRequest"
      } ],
      "x-discriminator-value" : "SearchByTextRequest",
      "x-ms-discriminator-value" : "SearchByTextRequest"
    },
    "SearchLocationsBulkRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "properties" : {
          "searchOptions" : {
            "description" : "Options for this request.",
            "$ref" : "#/definitions/SearchOptions"
          }
        },
        "description" : "Abstract base type to search for locations using a list of input objects.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xlocate.SearchLocationsBulkRequest"
      } ],
      "x-discriminator-value" : "SearchLocationsBulkRequest",
      "x-ms-discriminator-value" : "SearchLocationsBulkRequest"
    },
    "SearchLocationsRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "properties" : {
          "searchOptions" : {
            "description" : "Options for this request.",
            "$ref" : "#/definitions/SearchOptions"
          }
        },
        "description" : "Abstract base type to search for locations using different input objects.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xlocate.SearchLocationsRequest"
      } ],
      "x-discriminator-value" : "SearchLocationsRequest",
      "x-ms-discriminator-value" : "SearchLocationsRequest"
    },
    "SearchLocationsResult" : {
      "type" : "object",
      "required" : [ "location" ],
      "properties" : {
        "location" : {
          "description" : "The location that was found.",
          "$ref" : "#/definitions/GeocodingLocation"
        },
        "matchQuality" : {
          "description" : "The quality of the result relative to the search request.",
          "$ref" : "#/definitions/MatchQuality"
        },
        "type" : {
          "description" : "The type of the result, sometimes also referred to as its detail level.",
          "$ref" : "#/definitions/LocationType"
        }
      },
      "description" : "Represents one of possibly several results of a geocoding request.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xlocate.SearchLocationsResult"
    },
    "SearchOptions" : {
      "type" : "object",
      "properties" : {
        "outputCountryType" : {
          "description" : "Specifies the desired representation of the country in the response.",
          "$ref" : "#/definitions/CountryType"
        },
        "allowedCountries" : {
          "type" : "array",
          "items" : {
            "description" : "Specifies a list of country codes according to ISO 3166-1 alpha-2 or ISO 3166-2 if referring to a subdivision. The search will be restricted to these countries or subdivisions. When not specified or empty, all countries contained in the geocoding data will be included in the search. If a given subdivision code is not supported, only the respective country is considered in the search and a CountryFallbackLimitation is returned in the response.",
            "$ref" : "#/definitions/CountryCode"
          }
        }
      },
      "description" : "Options for a search request.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xlocate.SearchOptions"
    },
    "SearchSpace" : {
      "type" : "object",
      "properties" : {
        "excludeByNetworkClass" : {
          "description" : "Defines a heuristic search space reduction by network class. For more information about network classes see the type of the segment attribute network class.",
          "$ref" : "#/definitions/ExcludeByNetworkClass"
        },
        "heuristicAggressiveness" : {
          "description" : "The aggressiveness of heuristic search space optimization. The aggressiveness represents the trade-off between the quality of the solution and the performance of the route calculation. A value of 0% disables the heuristic search space optimization and guarantees a mathematically optimal route, whereas with a value of 100% the heuristic is very aggressive and the probability to get a route that is not optimal is high. Note that the search space reduction defined in ExcludeByNetworkClass is not affected by the heuristicAggressiveness.",
          "$ref" : "#/definitions/Percent"
        }
      },
      "description" : "Defines the behavior of heuristics for search space reduction. The search space is the part of the routing graph that is explored to answer a route request and thus has a direct impact on the routing performance and quality.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.routingprofile.SearchSpace"
    },
    "SearchSpaceBounds" : {
      "type" : "object",
      "properties" : {
        "restrictionMode" : {
          "description" : "The restriction mode.",
          "$ref" : "#/definitions/RestrictionMode"
        },
        "customBounds" : {
          "description" : "The minimum bounds to which the search space should be restricted, their coordinate format is specified by service.RequestBase.coordinateFormat. The effective bounds may be a bit larger due to alignment with the data source.",
          "$ref" : "#/definitions/Bounds"
        }
      },
      "description" : "The search space bounds can be used to restrict the route calculation or high-performance routing networks to a custom excerpt of the map. This is particularly useful when you know in advance the area in which your routes will take place and can help to improve the performances.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.routing.SearchSpaceBounds"
    },
    "Segment" : {
      "type" : "object",
      "required" : [ "distance", "travelSpeed", "travelTime", "type", "violated" ],
      "properties" : {
        "startNodeIndex" : {
          "description" : "The index in the list of RouteResponse.nodes of the start node of the segment. It is available only if the list of nodes is requested by ResultFields.nodes.",
          "$ref" : "#/definitions/Index"
        },
        "endNodeIndex" : {
          "description" : "The index in the list of RouteResponse.nodes of the end node of the segment. It is available only if the list of nodes is requested by ResultFields.nodes.",
          "$ref" : "#/definitions/Index"
        },
        "distance" : {
          "description" : "The travel distance for the segment. It is always a whole number and depends on the segment type as follows.\r\n\r\n *  segments.SegmentType.NETWORK\\_SEGMENT. The distance on the network segment which is actually driven on.\r\n *  segments.SegmentType.LINK\\_SEGMENT. The air-line distance between input and link node.\r\n *  segments.SegmentType.COMBINED\\_TRANSPORT. The travel distance is always 0.\r\n *  segments.SegmentType.NOT\\_DRIVING. The travel distance is always 0.",
          "type" : "number"
        },
        "travelTime" : {
          "description" : "The travel time for the segment. It has up to three decimal places and depends on the segment type as follows.\r\n\r\n *  segments.SegmentType.NETWORK\\_SEGMENT. The travel time is calculated from the segment length and the travel speed (see below).\r\n *  segments.SegmentType.LINK\\_SEGMENT. The travel time is calculated from the segment length and the travel speed (see below).\r\n *  segments.SegmentType.COMBINED\\_TRANSPORT. The travel time is taken from the data which does not necessarily equal the actual time the combined transport takes. In this case the travel time is always a whole number.\r\n *  segments.SegmentType.NOT\\_DRIVING. The travel time is only grater 0 if there is a waiting time associated.\r\n\r\nIf the segment distance is larger than 0 it is guaranteed that also the travel time is larger than 0. The travel times calculated based on travel speed are rounded to milliseconds.",
          "$ref" : "#/definitions/Duration"
        },
        "travelSpeed" : {
          "description" : "The travel speed that was used to calculate the travel time for the segment. It is always a whole number and depends on the segment type as follows.\r\n\r\n *  segments.SegmentType.NETWORK\\_SEGMENT. The travel speed is determined from the road and speed classification from the data and from the current vehicle.\r\n *  segments.SegmentType.LINK\\_SEGMENT. The travel speed is vehicle-dependent, the value from vehicleprofile.Speeds.speedForLinkDistance is used.\r\n *  segments.SegmentType.COMBINED\\_TRANSPORT. The travel speed is always 0.\r\n *  segments.SegmentType.NOT\\_DRIVING. The travel speed is always 0.\r\n\r\nDue to the rounding of travel times to milliseconds the speed that is re-calculated from segment travel time and distance can differ slightly from the travel speed returned here. For almost all segments the difference is less than 0.5km/h. Only for very small segment the difference can be higher - assuming a normal speed of at most 130km/h even for these small segments the difference does not exceed 2km/h.",
          "$ref" : "#/definitions/Speed"
        },
        "trafficDelay" : {
          "description" : "The total delay due to traffic incidents (traffic jams, construction sites etc.) on the considered segment.\r\n\r\nFor each segment of the route where traffic incidents are present, the delay is calculated comparing the travel time for that section with and without traffic incidents. That means the delay contains the time that it takes longer to pass this segment than usually at the same time and the same day of week.\r\n\r\nThis value will be non-zero only when Feature Layer PTV\\_TrafficIncidents is enabled and one of the time-consideration scenarios ExactTimeConsiderationAtStart and ExactTimeConsiderationAtArrival is used.",
          "$ref" : "#/definitions/Duration"
        },
        "emissions" : {
          "description" : "The emissions along the route.",
          "$ref" : "#/definitions/Emissions"
        },
        "violated" : {
          "type" : "boolean",
          "description" : "If set to true, indicates that this segment contains a violation for the chosen vehicle."
        },
        "eventIndices" : {
          "type" : "array",
          "items" : {
            "description" : "The list of indices in the RouteResponse.events list containing all route events which occur at the beginning of the segment. An event may be present in consecutive segments if it covers a sequence of segments. The list is only populated if route events are requested by ResultFields.eventTypes.",
            "$ref" : "#/definitions/Index"
          }
        },
        "type" : {
          "description" : "A segment may have different types, e.g. it may be a \"normal\" segment between two network nodes, a \"link segment\", or a virtual segment which represents a border crossing or a waiting time.",
          "$ref" : "#/definitions/SegmentType"
        },
        "polyline" : {
          "description" : "The polyline of the segment. This polyline consists of all coordinates representing the segment and can be used to draw the segment into a map. Not available for segments of type SegmentType.NOT\\_DRIVING.\r\n\r\nThe polyline contains elevations only if requested by xroute.PolylineOptions.elevations. If the elevations data do not cover the complete polyline, an xroute.ElevationsNotAvailableLimitation will be available which states which parts of the polyline are not covered.",
          "$ref" : "#/definitions/EncodedGeometry"
        },
        "attributes" : {
          "description" : "A set of attributes belonging to this segment such as \"is this a bridge?\" or \"road name\". Available only for segments of type SegmentType.NETWORK\\_SEGMENT.",
          "$ref" : "#/definitions/SegmentAttributes"
        },
        "combinedTransport" : {
          "description" : "Attributes which describe the combined transport this segment represents. Available only for segments of type SegmentType.COMBINED\\_TRANSPORT.",
          "$ref" : "#/definitions/CombinedTransportAttributes"
        },
        "id" : {
          "description" : "The ID of the segment.",
          "$ref" : "#/definitions/SegmentId"
        }
      },
      "description" : "A segment is defined by a start- and an end-node, which in turn will represent some geographic location. A segment may carry additional attributes and will add to the duration of a journey.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.Segment"
    },
    "SegmentAttributes" : {
      "type" : "object",
      "properties" : {
        "descriptors" : {
          "description" : "Attributes which basically describe the segment such as road name and number.",
          "$ref" : "#/definitions/SegmentDescriptors"
        },
        "roadAttributes" : {
          "description" : "Legal and physical attributes of the segment such as toll, one-way, or tunnels.",
          "$ref" : "#/definitions/RoadAttributes"
        },
        "features" : {
          "type" : "array",
          "items" : {
            "description" : "The features of all enabled Feature Layer themes related to this segment, if requested by xroute.SegmentResultFields.featureThemeIds.",
            "$ref" : "#/definitions/SegmentFeature"
          }
        }
      },
      "description" : "The attributes of the underlying segments.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.segments.SegmentAttributes"
    },
    "SegmentDescriptors" : {
      "type" : "object",
      "required" : [ "country", "networkClass" ],
      "properties" : {
        "country" : {
          "description" : "The country the segment is located in.",
          "$ref" : "#/definitions/CountryCode"
        },
        "roadName" : {
          "type" : "string",
          "description" : "The name of the road in the selected language. It remains empty, if it is not available in the data."
        },
        "roadNumber" : {
          "type" : "string",
          "description" : "The road number. The string may consist of several number entries divided by \"/\". It remains empty, if it is not available in the data."
        },
        "networkClass" : {
          "description" : "The network class of the segment.",
          "$ref" : "#/definitions/NetworkClass"
        }
      },
      "description" : "Attributes which basically describe the segment such as road name and number.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.segments.SegmentDescriptors"
    },
    "SegmentDirection" : {
      "type" : "string",
      "description" : "The direction of the segment.  \n * `POLYLINE_DIRECTION` - Describes the direction from start node to end node with respect to the digitization direction.  \n * `REVERSE_POLYLINE_DIRECTION` - Describes the direction from end node to start node with respect to the digitization direction.  \n * `BOTH` - Describes both directions.  \n * `UNSPECIFIED` - Fallback value to be substituted for enumeration values which were added in an API version that is newer than the request version. When using the current API, this value will never be returned.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.segments.SegmentDirection",
      "enum" : [ "POLYLINE_DIRECTION", "REVERSE_POLYLINE_DIRECTION", "BOTH", "UNSPECIFIED" ],
      "x-ms-enum" : {
        "name" : "SegmentDirection",
        "modelAsString" : false
      }
    },
    "SegmentFeature" : {
      "type" : "object",
      "required" : [ "themeId" ],
      "properties" : {
        "themeId" : {
          "description" : "The ID of the Feature Layer theme to which this feature belongs to.",
          "$ref" : "#/definitions/ThemeId"
        },
        "attributes" : {
          "type" : "array",
          "items" : {
            "description" : "The list of attributes of a segment. For each attribute its type (key) and value is provided via key-value pairs. See the documentation of the layer-specific attributes for more information on the type and the range of available attributes.",
            "$ref" : "#/definitions/KeyValuePair"
          }
        }
      },
      "description" : "Contains the features of a Feature Layer theme valid for the segment in question.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.segments.Feature"
    },
    "SegmentId" : {
      "type" : "string",
      "description" : "Internal representation of a map segment or a combined transport. This is a map-dependent ID which is designed to be used in a subsequent request but not to be stored in a database.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.SegmentId"
    },
    "SegmentResultFields" : {
      "type" : "object",
      "properties" : {
        "enabled" : {
          "type" : "boolean",
          "description" : "Specifies if the segments shall be returned for the complete route."
        },
        "emissions" : {
          "type" : "boolean",
          "description" : "Specifies if the emissions shall be returned for the complete route."
        },
        "polyline" : {
          "type" : "boolean",
          "description" : "Specifies if the segments shall contain the polyline."
        },
        "descriptors" : {
          "type" : "boolean",
          "description" : "Specifies if the segments shall contain the descriptors such as road name and number."
        },
        "roadAttributes" : {
          "type" : "boolean",
          "description" : "Specifies if the segments shall contain the road attributes which describe it physically and legally."
        },
        "featureThemeIds" : {
          "type" : "array",
          "items" : {
            "description" : "The list of Feature Layer theme IDs for which features are to be returned. Every requested theme must be enabled in the Feature Layer profile.",
            "$ref" : "#/definitions/ThemeId"
          }
        },
        "id" : {
          "type" : "boolean",
          "description" : "Specifies if the segments shall contain the ID of the segment."
        }
      },
      "description" : "Specifies if and to what extent the segments shall be returned for the complete route.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.SegmentResultFields"
    },
    "SegmentType" : {
      "type" : "string",
      "description" : "The type of a segment.  \n * `NETWORK_SEGMENT` - This segment is a network segment.  \n * `LINK_SEGMENT` - This segment is a virtual one, but not a network segment. It links the input coordinate to the routing network and does not have SegmentAttributes.  \n * `COMBINED_TRANSPORT` - This segment is a combined transport, i.e. the vehicle is carried by some other vehicle such as a boat or a train. The CombinedTransportAttributes are available only for segments of this type.  \n * `NOT_DRIVING` - This segment is a virtual one which denotes that the vehicle is not driving. Thus, the segment has distance and travelSpeed 0 and does not have a polyline nor SegmentAttributes.\r\n\r\n *  Border crossings which are not a combined transport. Start and end node have the same location but are in different countries. The travelTime equals 0.\r\n *  When the driver is making a break or a rest, during service and other waiting periods. For those waiting segments start and end nodes are equal.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.segments.SegmentType",
      "enum" : [ "NETWORK_SEGMENT", "LINK_SEGMENT", "COMBINED_TRANSPORT", "NOT_DRIVING" ],
      "x-ms-enum" : {
        "name" : "SegmentType",
        "modelAsString" : false
      }
    },
    "SegmentsByCoordinateRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/SegmentsRequest"
      }, {
        "type" : "object",
        "required" : [ "coordinate" ],
        "properties" : {
          "coordinate" : {
            "description" : "The coordinate that is located on the segment or nearby the segment(s).",
            "$ref" : "#/definitions/Coordinate"
          }
        },
        "description" : "Retrieve segments from the map according to a given coordinate.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.SegmentsByCoordinateRequest"
      } ],
      "x-discriminator-value" : "SegmentsByCoordinateRequest",
      "x-ms-discriminator-value" : "SegmentsByCoordinateRequest"
    },
    "SegmentsByIdRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/SegmentsRequest"
      }, {
        "type" : "object",
        "properties" : {
          "ids" : {
            "type" : "array",
            "items" : {
              "description" : "The Ids of the segment(s).",
              "$ref" : "#/definitions/SegmentId"
            }
          }
        },
        "description" : "Retrieve segments from the map according to given segment ids.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.SegmentsByIdRequest"
      } ],
      "x-discriminator-value" : "SegmentsByIdRequest",
      "x-ms-discriminator-value" : "SegmentsByIdRequest"
    },
    "SegmentsByIntersectingPolylineRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/SegmentsRequest"
      }, {
        "type" : "object",
        "required" : [ "polyline" ],
        "properties" : {
          "polyline" : {
            "description" : "The polyline that intersects the segment(s).",
            "$ref" : "#/definitions/EncodedGeometry"
          }
        },
        "description" : "Retrieve segments from the map that are intersected by a given polyline.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.SegmentsByIntersectingPolylineRequest"
      } ],
      "x-discriminator-value" : "SegmentsByIntersectingPolylineRequest",
      "x-ms-discriminator-value" : "SegmentsByIntersectingPolylineRequest"
    },
    "SegmentsBySurroundingPolygonRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/SegmentsRequest"
      }, {
        "type" : "object",
        "required" : [ "polygon" ],
        "properties" : {
          "polygon" : {
            "description" : "The polygon that surrounds the segment(s).",
            "$ref" : "#/definitions/EncodedGeometry"
          }
        },
        "description" : "Retrieve segments from the map that are surrounded by a given polygon.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.SegmentsBySurroundingPolygonRequest"
      } ],
      "x-discriminator-value" : "SegmentsBySurroundingPolygonRequest",
      "x-ms-discriminator-value" : "SegmentsBySurroundingPolygonRequest"
    },
    "SegmentsOptions" : {
      "type" : "object",
      "properties" : {
        "includedNetworkClasses" : {
          "description" : "Specifies for which network classes the segments shall be included in the result. If not specified, the segments will be included whatever their network class.",
          "$ref" : "#/definitions/IncludedNetworkClasses"
        },
        "includedSegmentTypes" : {
          "type" : "array",
          "items" : {
            "description" : "The segment types to include in the result. If the list is null or empty, all the segments will be included whatever their type. Only segments.SegmentType.NETWORK\\_SEGMENT and segments.SegmentType.COMBINED\\_TRANSPORT are supported.",
            "$ref" : "#/definitions/SegmentType"
          }
        }
      },
      "description" : "Specifies search options for segments.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.SegmentsOptions"
    },
    "SegmentsRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "properties" : {
          "resultFields" : {
            "description" : "Specifies which parts of the found segments should be included in the result.",
            "$ref" : "#/definitions/SegmentsResultFields"
          },
          "segmentsOptions" : {
            "description" : "Options to configure the result fields available in the response.",
            "$ref" : "#/definitions/SegmentsOptions"
          }
        },
        "description" : "Abstract base type to retrieve segments from the map for different kinds of selection criteria.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.SegmentsRequest"
      } ],
      "x-discriminator-value" : "SegmentsRequest",
      "x-ms-discriminator-value" : "SegmentsRequest"
    },
    "SegmentsResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "properties" : {
          "segments" : {
            "type" : "array",
            "items" : {
              "description" : "The list of selected segments according to the specified criteria from the request.",
              "$ref" : "#/definitions/MapSegment"
            }
          }
        },
        "description" : "Response of a getSegments request which contains all selected segments according to the request criteria.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.SegmentsResponse"
      } ],
      "x-discriminator-value" : "SegmentsResponse",
      "x-ms-discriminator-value" : "SegmentsResponse"
    },
    "SegmentsResultFields" : {
      "type" : "object",
      "properties" : {
        "polyline" : {
          "type" : "boolean",
          "description" : "Specifies if the segments shall contain the polyline."
        },
        "descriptors" : {
          "type" : "boolean",
          "description" : "Specifies if the segments shall contain the descriptors such as country, road name and number."
        },
        "combinedTransport" : {
          "type" : "boolean",
          "description" : "Specifies if the segments shall contain the combined transport attributes such as type and name."
        }
      },
      "description" : "Specifies to what extent segments shall be returned.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.SegmentsResultFields"
    },
    "ServerConfigurationRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "properties" : {
          "resultFields" : {
            "description" : "Specifies what should be included in the response.",
            "$ref" : "#/definitions/ConfigurationResultFields"
          }
        },
        "description" : "This request specifies which parts should be included in the ServerConfigurationResponse.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.ServerConfigurationRequest"
      } ],
      "x-discriminator-value" : "ServerConfigurationRequest",
      "x-ms-discriminator-value" : "ServerConfigurationRequest"
    },
    "ServerConfigurationResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "required" : [ "version" ],
        "properties" : {
          "version" : {
            "type" : "string",
            "description" : "The xServer version."
          },
          "profiles" : {
            "type" : "array",
            "items" : {
              "description" : "Available profiles ordered by displayName.",
              "$ref" : "#/definitions/ProfileDescription"
            }
          },
          "configFileNames" : {
            "type" : "array",
            "items" : {
              "description" : "A list of all files in the config subdirectory ordered by path. Includes also subdirectories.",
              "$ref" : "#/definitions/FileName"
            }
          },
          "used3rdPartyLibraries" : {
            "type" : "array",
            "items" : {
              "description" : "A list of all used 3rdParty libaries.",
              "$ref" : "#/definitions/Library"
            }
          },
          "internalLibraries" : {
            "type" : "array",
            "items" : {
              "description" : "A list of internal PTV components",
              "$ref" : "#/definitions/Library"
            }
          }
        },
        "description" : "This type holds information on the server configuration.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.ServerConfigurationResponse"
      } ],
      "x-discriminator-value" : "ServerConfigurationResponse",
      "x-ms-discriminator-value" : "ServerConfigurationResponse"
    },
    "ServiceCompleted" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ServiceStatus"
      }, {
        "type" : "object",
        "description" : "Service at stop is completed.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.tourplanning.ServiceCompleted"
      } ],
      "x-discriminator-value" : "ServiceCompleted",
      "x-ms-discriminator-value" : "ServiceCompleted"
    },
    "ServiceInformation" : {
      "type" : "object",
      "required" : [ "active", "async", "licensed", "name", "plugin", "version" ],
      "properties" : {
        "name" : {
          "type" : "string",
          "description" : "Name of this service."
        },
        "version" : {
          "type" : "string",
          "description" : "Version of this service."
        },
        "supportedVersions" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "description" : "Supported previous versions of this service."
          }
        },
        "async" : {
          "type" : "boolean",
          "description" : "Does this service support asynchronous methods?"
        },
        "licensed" : {
          "type" : "boolean",
          "description" : "Is the service licensed?"
        },
        "active" : {
          "type" : "boolean",
          "description" : "Is the service currently active?"
        },
        "plugin" : {
          "type" : "boolean",
          "description" : "Deprecated: is always false."
        },
        "methods" : {
          "type" : "array",
          "items" : {
            "description" : "List of supported methods.",
            "$ref" : "#/definitions/ServiceMethod"
          }
        }
      },
      "description" : "Represents a single service within this server.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.ServiceInformation"
    },
    "ServiceMethod" : {
      "type" : "object",
      "required" : [ "async", "name", "restful" ],
      "properties" : {
        "name" : {
          "type" : "string",
          "description" : "The method name."
        },
        "restful" : {
          "type" : "boolean",
          "description" : "True, if this is a rest service."
        },
        "async" : {
          "type" : "boolean",
          "description" : "True, if this service is asynchronous."
        },
        "fetcherMethodName" : {
          "type" : "string",
          "description" : "If the method is asynchronous then this is the name of the fetch method."
        }
      },
      "description" : "Represents a single service method.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.ServiceMethod"
    },
    "ServiceNotConfiguredFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RejectedRequestFault"
      }, {
        "type" : "object",
        "required" : [ "service" ],
        "properties" : {
          "service" : {
            "type" : "string",
            "description" : "The name of the service that is not configured."
          }
        },
        "description" : "This fault is thrown if a requested service is not configured in the current deployment.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.ServiceNotConfiguredFault"
      } ],
      "x-discriminator-value" : "ServiceNotConfiguredFault",
      "x-ms-discriminator-value" : "ServiceNotConfiguredFault"
    },
    "ServiceStarted" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ServiceStatus"
      }, {
        "type" : "object",
        "required" : [ "performedServiceTime" ],
        "properties" : {
          "performedServiceTime" : {
            "description" : "Already performed service time at this stop.\r\n\r\nThe remaining service time at this stop is the originally planned service time subtracted by the parameter performedServiceTime. No service needs to be performed at this stop any more if performedServiceTime is greater than or equal to the originally planned service time.",
            "$ref" : "#/definitions/Duration"
          }
        },
        "description" : "Service at stop has started and is currently being performed.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.tourplanning.ServiceStarted"
      } ],
      "x-discriminator-value" : "ServiceStarted",
      "x-ms-discriminator-value" : "ServiceStarted"
    },
    "ServiceStatus" : {
      "type" : "object",
      "required" : [ "$type" ],
      "discriminator" : "$type",
      "properties" : {
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "Status for the service at the current stop of a tour in execution.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.tourplanning.ServiceStatus"
    },
    "ServiceTimeFactor" : {
      "type" : "number",
      "format" : "double",
      "description" : "A factor by which a service time is multiplied. Range: 0.1 ??? value ??? 10.0.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.ServiceTimeFactor"
    },
    "SetupFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/XServerFault"
      }, {
        "type" : "object",
        "description" : "This fault is thrown if an error occurred during the setup of the xServer. SetupFaults are never raised by a request, they only occur on startup.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.SetupFault"
      } ],
      "x-discriminator-value" : "SetupFault",
      "x-ms-discriminator-value" : "SetupFault"
    },
    "SideOfStreetRestriction" : {
      "type" : "string",
      "description" : "Specifies how the street at which the location is located can be used.  \n * `ANY_SIDE` - No restrictions on the side of the street, both sides can be used.  \n * `SAME_SIDE_AS_LOCATION` - The street side on which the location is situated should be used.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.routing.SideOfStreetRestriction",
      "enum" : [ "ANY_SIDE", "SAME_SIDE_AS_LOCATION" ],
      "x-ms-enum" : {
        "name" : "SideOfStreetRestriction",
        "modelAsString" : false
      }
    },
    "SideOfStreetRestrictionIgnoredLimitation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResultLimitation"
      }, {
        "type" : "object",
        "description" : "This result limitation indicates that the sideOfStreetRestriction of an OffRoadRouteLocation or an OnRoadRouteLocation has been ignored. This happens when being used with calculateReachableAreas or calculateReachableLocations.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.SideOfStreetRestrictionIgnoredLimitation"
      } ],
      "x-discriminator-value" : "SideOfStreetRestrictionIgnoredLimitation",
      "x-ms-discriminator-value" : "SideOfStreetRestrictionIgnoredLimitation"
    },
    "SingleDayWorkingHours" : {
      "allOf" : [ {
        "$ref" : "#/definitions/WorkingHours"
      }, {
        "type" : "object",
        "description" : "Defines which rules regarding drivers' working hours need to be met in a single day planning scenario.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.tourplanning.SingleDayWorkingHours"
      } ],
      "x-discriminator-value" : "SingleDayWorkingHours",
      "x-ms-discriminator-value" : "SingleDayWorkingHours"
    },
    "SingleDepotPerTourRestrictionFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TourStructureFault"
      }, {
        "type" : "object",
        "required" : [ "vehicleId" ],
        "properties" : {
          "vehicleId" : {
            "type" : "string",
            "description" : "ID of the vehicle serving the input tour with invalid structure in case of a PlanToursRequest. In case of a ChangeToursRequest this parameter contains the ID of the vehicle that would serve a tour with invalid structure."
          }
        },
        "description" : "This fault is thrown if the singleDepotPerTour restriction is set but an input tour consists of multiple depots or a ChangeToursRequest would lead to multiple depots per tour.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.SingleDepotPerTourRestrictionFault"
      } ],
      "x-discriminator-value" : "SingleDepotPerTourRestrictionFault",
      "x-ms-discriminator-value" : "SingleDepotPerTourRestrictionFault"
    },
    "SingleTripPerTourRestrictionFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TourStructureFault"
      }, {
        "type" : "object",
        "required" : [ "vehicleId" ],
        "properties" : {
          "vehicleId" : {
            "type" : "string",
            "description" : "ID of the vehicle serving the input tour with invalid structure in case of a PlanToursRequest. In case of a ChangeToursRequest this parameter contains the ID of the vehicle that would serve a tour with invalid structure."
          }
        },
        "description" : "This fault is thrown if the singleTripPerTour restriction is set but an input tour consists of multiple trips or a ChangeToursRequest would lead to multiple trips per tour.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.SingleTripPerTourRestrictionFault"
      } ],
      "x-discriminator-value" : "SingleTripPerTourRestrictionFault",
      "x-ms-discriminator-value" : "SingleTripPerTourRestrictionFault"
    },
    "Site" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TourPlanningLocation"
      }, {
        "type" : "object",
        "properties" : {
          "openingIntervals" : {
            "type" : "array",
            "items" : {
              "description" : "Opening intervals for this site, specified in one of the valid interval formats. Leaving this parameter empty means that the site is always open. Service can only start within one of the opening intervals. If a planning horizon is defined for the request, all opening intervals outside of this horizon are not considered during the tour planning process. If this list of intervals contains GDF time domains, a planning horizon is required. If no planning horizon is defined, it is required that the opening intervals of all sites do not span a horizon longer than two weeks.",
              "$ref" : "#/definitions/Interval"
            }
          },
          "serviceTimePerStop" : {
            "description" : "Site dependent service time, for example to enter an area or to register at a customer. This service time will be considered for each stop that is performed at this site. If additional service time per pickup stop or additional service time per delivery stop is defined at a depot, this value is added to the stop service time. Additionally there may be an order dependent or vehicle dependent service time of the stop. See Service time calculation.",
            "$ref" : "#/definitions/Duration"
          },
          "ignoreVehicleDependentServiceTimeFactorForOrders" : {
            "type" : "boolean",
            "description" : "Indicates if vehicle dependent service time factors are relevant for this site, for example if the vehicle is unloaded by ramp staff. If this parameter is set to true, no vehicle dependent service times are taken into account for this site. See Service time calculation."
          }
        },
        "description" : "A specific location where goods can be picked up or delivered. This location is either a depot or a customer location. It is highly recommended to avoid multiple sites with the same members to improve performance and solution quality!\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.Site"
      } ],
      "x-discriminator-value" : "Site",
      "x-ms-discriminator-value" : "Site"
    },
    "SnapshotTimeConsideration" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TimeConsideration"
      }, {
        "type" : "object",
        "properties" : {
          "referenceTime" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The reference time at which all data with time restrictions will be evaluated. If no reference time is set, the current UTC time is used."
          }
        },
        "description" : "This time-consideration scenario evaluates all data which have time restrictions at the given reference time. For rendering this means that the map shows the state which is valid at that reference time. For routing this means that each segment of the route is evaluated at the same reference time in contrast to ExactTimeConsiderationAtStart and ExactTimeConsiderationAtArrival. Route calculation will be more performant than the exact scenarios.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.timeconsideration.SnapshotTimeConsideration"
      } ],
      "x-discriminator-value" : "SnapshotTimeConsideration",
      "x-ms-discriminator-value" : "SnapshotTimeConsideration"
    },
    "SpecialAreas" : {
      "type" : "object",
      "properties" : {
        "residentsOnlyPenalty" : {
          "description" : "The penalty for each segment within a residents only area. This setting affects segments which have set segments.RoadAttributes.residentsOnly.",
          "$ref" : "#/definitions/Penalty"
        },
        "urbanPenalty" : {
          "description" : "The penalty for urban segments. A segment is treated as \"urban\" if the corresponding segment attribute is set and the network class is larger than or equal to minimumUrbanNetworkClass. This setting affects segments which have set segments.RoadAttributes.urban.",
          "$ref" : "#/definitions/Penalty"
        },
        "minimumUrbanNetworkClass" : {
          "description" : "The minimum allowed urban network class",
          "$ref" : "#/definitions/NetworkClass"
        },
        "forbiddenLowEmissionZonePenalty" : {
          "description" : "The penalty for segments that are forbidden for the current vehicleprofile.Engine.lowEmissionZoneTypes of the vehicle. This setting affects segments which do not match segments.RoadAttributes.lowEmissionZoneType.",
          "$ref" : "#/definitions/Penalty"
        },
        "deliveryOnlyPenalty" : {
          "description" : "The penalty for delivery only segments that are allowed because vehicleprofile.LegalCondition.isDelivery is enabled. This setting affects segments which have set segments.RoadAttributes.deliveryOnly.",
          "$ref" : "#/definitions/Penalty"
        },
        "deliveryOnlyGateCost" : {
          "description" : "The routing cost for gates that have are allowed to pass because vehicleprofile.LegalCondition.isDelivery is enabled. In contrast to a prohibited segment a gate is located at a specific point of the road network and passing through that point is prohibited by the gate.",
          "$ref" : "#/definitions/MathematicalCost"
        }
      },
      "description" : "Defines the parameters concerning the special areas, such as urban segments, low emission zones, etc.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.routingprofile.SpecialAreas"
    },
    "Speed" : {
      "type" : "number",
      "format" : "double",
      "description" : "Defines the type used for expressing speeds in \\[km/h\\]. Range: 0.0 ??? value ??? 255.0.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.Speed"
    },
    "SpeedRangesByNetworkClass" : {
      "type" : "object",
      "properties" : {
        "maximumSpeeds" : {
          "type" : "array",
          "items" : {
            "description" : "The maximum speeds for each network class. Default: 80,65,55,45,40,30,30,30.",
            "$ref" : "#/definitions/Speed"
          }
        },
        "minimumSpeeds" : {
          "type" : "array",
          "items" : {
            "description" : "The minimum speeds for each network class. Default: 55,30,23,20,18,15,15,15.",
            "$ref" : "#/definitions/Speed"
          }
        }
      },
      "description" : "Defines the speed intervals for each network class. The road segments of a network class are classified into subtypes which are automatically assigned a speed value from the interval. If speed information from a feature layer such as PTV\\_SpeedPatterns or PTV\\_TrafficIncidents is available for a segment it overrides the speed defined here. (1)\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.vehicleprofile.SpeedRangesByNetworkClass"
    },
    "Speeds" : {
      "type" : "object",
      "properties" : {
        "speedRangesByNetworkClass" : {
          "description" : "Defines the speed intervals for each network class. The road segments of a network class are classified into subtypes which are automatically assigned a speed value from the interval. If speed information from a feature layer such as PTV\\_SpeedPatterns or PTV\\_TrafficIncidents is available for a segment it overrides the speed defined here. (1)",
          "$ref" : "#/definitions/SpeedRangesByNetworkClass"
        },
        "speedForLinkDistance" : {
          "description" : "The notional speed for the distance from a waypoint to its link point on the road network. (1)",
          "$ref" : "#/definitions/Speed"
        },
        "maximumSpeed" : {
          "description" : "The absolute maximum speed for all road segments. The speeds calculated from the interval \\[minimumSpeed, maximumSpeed\\] for each network class, will be limited to this speed value. Note: an interval \\[70,135\\] for network class 0 with a maximum speed of 120 km/h is not equal to the interval \\[70,120\\]. A maximum speed of 0 is ignored. (1)",
          "$ref" : "#/definitions/Speed"
        }
      },
      "description" : "Defines the speed values used by the routing algorithm to calculate the travel time of a road segment. All speed values given here are internally rounded to km/h.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.vehicleprofile.Speeds"
    },
    "StackingOptions" : {
      "type" : "object",
      "properties" : {
        "stackingRestrictions" : {
          "type" : "array",
          "items" : {
            "description" : "Defines all the stacking restrictions between ItemType.",
            "$ref" : "#/definitions/StackingRestrictions"
          }
        }
      },
      "description" : "Defines all stacking options to be considered during the packing algorithm.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xload.StackingOptions"
    },
    "StackingRestrictionType" : {
      "type" : "string",
      "description" : "Defines the stacking restrictions.  \n * `ALL_ALLOWED` - All ItemType can be stacked on top of the current one. Moreover, every items of the same ItemType can be stacked on top of the current one.  \n * `ALL_PROHIBITED` - All ItemType can not be stacked on top of the current one. Moreover, even items of the same ItemType can not be stacked on top of the current one.  \n * `ALLOWED` - Every listed ItemType can be stacked on top of the current one.  \n * `PROHIBITED` - Every listed ItemType can not be stacked on top of the current one.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.xload.StackingRestrictionType",
      "enum" : [ "ALL_ALLOWED", "ALL_PROHIBITED", "ALLOWED", "PROHIBITED" ],
      "x-ms-enum" : {
        "name" : "StackingRestrictionType",
        "modelAsString" : false
      }
    },
    "StackingRestrictions" : {
      "type" : "object",
      "required" : [ "itemTypeId" ],
      "properties" : {
        "itemTypeId" : {
          "type" : "string",
          "description" : "ID of the ItemType."
        },
        "restrictionType" : {
          "description" : "The type of restriction. Defines the restriction between StackingRestrictions.itemTypeId and StackingRestrictions.itemTypeIds. By default, every ItemType can be stacked on the current ItemType.",
          "$ref" : "#/definitions/StackingRestrictionType"
        },
        "itemTypeIds" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "description" : "Specifies the list of ItemType.id to which the restriction applies."
          }
        }
      },
      "description" : "Define the stacking restriction for one ItemType. Specifies which ItemType are allowed or prohibited to be stacked on the current ItemType.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xload.StackingRestrictions"
    },
    "StartDurationInterval" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Interval"
      }, {
        "type" : "object",
        "required" : [ "duration", "start" ],
        "properties" : {
          "start" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The beginning of the time interval."
          },
          "duration" : {
            "description" : "The duration of the interval.",
            "$ref" : "#/definitions/Duration"
          }
        },
        "description" : "A segment of time specified by a start time and a duration.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.time.StartDurationInterval"
      } ],
      "x-discriminator-value" : "StartDurationInterval",
      "x-ms-discriminator-value" : "StartDurationInterval"
    },
    "StartEndInterval" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Interval"
      }, {
        "type" : "object",
        "required" : [ "end", "start" ],
        "properties" : {
          "start" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The beginning of the time interval."
          },
          "end" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The end of the time interval."
          }
        },
        "description" : "A segment of time specified by two points in time - the beginning and the end of the interval.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.time.StartEndInterval"
      } ],
      "x-discriminator-value" : "StartEndInterval",
      "x-ms-discriminator-value" : "StartEndInterval"
    },
    "StopDeleteRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "required" : [ "id" ],
        "properties" : {
          "id" : {
            "type" : "string",
            "description" : "The request's ID."
          }
        },
        "description" : "Request for stopping or deleting a request.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.StopDeleteRequest"
      } ],
      "x-discriminator-value" : "StopDeleteRequest",
      "x-ms-discriminator-value" : "StopDeleteRequest"
    },
    "StopIdentifier" : {
      "type" : "object",
      "required" : [ "position", "tripId" ],
      "properties" : {
        "tripId" : {
          "type" : "string",
          "description" : "ID of the trip that contains the stop."
        },
        "position" : {
          "description" : "Position of stop within trip.",
          "$ref" : "#/definitions/Index"
        }
      },
      "description" : "Identifies a stop by a trip ID and a position.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.StopIdentifier"
    },
    "StopStructureFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TripStructureFault"
      }, {
        "type" : "object",
        "required" : [ "stopIndex" ],
        "properties" : {
          "stopIndex" : {
            "description" : "Index of the stop in stops of the trip containing the wrong structure.",
            "$ref" : "#/definitions/Index"
          }
        },
        "description" : "This fault is thrown if a stop structure is violated. For more information please have a look at the technical concept Orders, Locations, and Stops.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.StopStructureFault"
      } ],
      "x-discriminator-value" : "StopStructureFault",
      "x-ms-discriminator-value" : "StopStructureFault"
    },
    "StrokeStyle" : {
      "type" : "object",
      "properties" : {
        "arrows" : {
          "description" : "Defines how to render arrows on top of the underlying stroke. The width of the arrows is automatically adapted to the width of the stroke.",
          "$ref" : "#/definitions/ArrowsStyle"
        },
        "perpendicularOffset" : {
          "description" : "The perpendicular offset relative to the related road. This way it is possible to mark a road by drawing a line next to it.",
          "$ref" : "#/definitions/RenderingSize"
        },
        "visible" : {
          "type" : "boolean",
          "description" : "Controls the visibility of the stroke."
        },
        "width" : {
          "description" : "The width of a stroke. As an example, 150% width for a line geometry to be rendered on a road results in a line that is 50% wider than the road. Percent values can only be specified for road-based objects. For other objects, use pixel values.",
          "$ref" : "#/definitions/RenderingSize"
        },
        "color" : {
          "description" : "The color of the object.",
          "$ref" : "#/definitions/Color"
        },
        "opacity" : {
          "description" : "The opacity in \\[%\\]. 100 represents opaque, 0 represents completely transparent.",
          "$ref" : "#/definitions/Percent"
        }
      },
      "description" : "Defines how to render the stroke of a feature.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.renderingprofile.StrokeStyle"
    },
    "Subdivision" : {
      "type" : "object",
      "properties" : {
        "code" : {
          "description" : "The country code including the subdivision code.",
          "$ref" : "#/definitions/CountryCode"
        },
        "description" : {
          "description" : "Descriptive information about the subdivision.",
          "$ref" : "#/definitions/RegionDescription"
        },
        "features" : {
          "description" : "Lists the features which are available for this subdivision.",
          "$ref" : "#/definitions/RegionFeatures"
        }
      },
      "description" : "Holds additional data for a subdivision.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.Subdivision"
    },
    "SubdivisionFallbackLimitation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResultLimitation"
      }, {
        "type" : "object",
        "required" : [ "fallbackCountryCode", "requestedSubdivisionCode" ],
        "properties" : {
          "requestedSubdivisionCode" : {
            "type" : "string",
            "description" : "The country subdivision code that was requested in allowedCountries, but cannot be used."
          },
          "fallbackCountryCode" : {
            "type" : "string",
            "description" : "The enclosing country that is used as a fallback instead."
          }
        },
        "description" : "This result limitation indicates that GeographicRestrictions.allowedCountries contains a country subdivision code that cannot be used like this due to the available data, and that instead the enclosing country code was used. In such cases, routes are constrained to the country, rather than only the subdivision.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.routing.SubdivisionFallbackLimitation"
      } ],
      "x-discriminator-value" : "SubdivisionFallbackLimitation",
      "x-ms-discriminator-value" : "SubdivisionFallbackLimitation"
    },
    "SuppressedXServerException" : {
      "type" : "object",
      "required" : [ "faultInfo", "message" ],
      "properties" : {
        "message" : {
          "type" : "string",
          "description" : "The message of the suppressed exception."
        },
        "faultInfo" : {
          "description" : "The fault information of the suppressed exception.",
          "$ref" : "#/definitions/XServerFault"
        }
      },
      "description" : "This entity wraps a former exception in order to return it in a regular response, for example of a bulk or list method. This 'exception' cannot be caught but the contents can be treated as if they originate from an XServerException.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.SuppressedXServerException"
    },
    "SurfaceLoad" : {
      "type" : "number",
      "format" : "double",
      "description" : "Load on a surface in \\[kg/m??\\]. Range: 0.0 ??? value.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.SurfaceLoad"
    },
    "TaskType" : {
      "type" : "string",
      "description" : "A type of task that can be carried out at a stop.  \n * `PICKUP` - An order is picked up.  \n * `DELIVERY` - An order is delivered.  \n * `VISIT` - A customer is visited.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.xtour.TaskType",
      "enum" : [ "PICKUP", "DELIVERY", "VISIT" ],
      "x-ms-enum" : {
        "name" : "TaskType",
        "modelAsString" : false
      }
    },
    "Theme" : {
      "type" : "object",
      "required" : [ "id" ],
      "properties" : {
        "countrySpecificParameters" : {
          "type" : "array",
          "items" : {
            "description" : "Defines the parameters of countries for this theme.",
            "$ref" : "#/definitions/CountrySpecificParameter"
          }
        },
        "featureResultProperties" : {
          "type" : "array",
          "items" : {
            "description" : "Defines the contents of the features returned by the xMap and xRoute services. By default all properties are included.",
            "$ref" : "#/definitions/FeatureResultProperty"
          }
        },
        "id" : {
          "description" : "Defines the theme ID.",
          "$ref" : "#/definitions/ThemeId"
        },
        "enabled" : {
          "type" : "boolean",
          "description" : "Enables or disables the theme. Every subsequent country, rule, property and action type that is relative to this theme will be considered enabled or disabled for this theme."
        },
        "priorityLevel" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "The priority level \\[0-255\\]. 100 is the default priority level, a 101 value defines a higher priority than 100."
        },
        "featureScenarios" : {
          "type" : "array",
          "items" : {
            "description" : "The list of scenarios defined for the theme. As soon as a scenario is defined, use the \"PTV\" scenario to enable the PTV provided layers for this theme.",
            "$ref" : "#/definitions/FeatureScenario"
          }
        }
      },
      "description" : "Defines the parameters of a specific theme.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.featurelayerprofile.Theme"
    },
    "ThemeId" : {
      "type" : "string",
      "description" : "Identification of a Feature Layer theme by name, for example \"PTV\\_TruckAttributes\". The special value \"\\*\" is forbidden. Pattern: \\[^\\\\\\*\\]+.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.ThemeId"
    },
    "TileResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "required" : [ "image", "zoom" ],
        "properties" : {
          "image" : {
            "type" : "string",
            "format" : "byte",
            "description" : "The image as a byte array."
          },
          "zoom" : {
            "description" : "The zoom level of the tile image.",
            "$ref" : "#/definitions/Zoom"
          },
          "features" : {
            "type" : "array",
            "items" : {
              "description" : "The features of all enabled Feature Layer themes rendered in the tile.",
              "$ref" : "#/definitions/MapFeature"
            }
          }
        },
        "description" : "Contains the result of a tile request, which demands for additional object information besides the rendered tile image.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xmap.TileResponse"
      } ],
      "x-discriminator-value" : "TileResponse",
      "x-ms-discriminator-value" : "TileResponse"
    },
    "TimeConsideration" : {
      "type" : "object",
      "required" : [ "$type" ],
      "discriminator" : "$type",
      "properties" : {
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "The base type for all time-consideration scenarios. For the use cases see time consideration. If the object is NULL, all data which have time restrictions are not considered.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.timeconsideration.TimeConsideration"
    },
    "TimeDependencyStyle" : {
      "type" : "object",
      "properties" : {
        "iconsWithClock" : {
          "type" : "boolean",
          "description" : "If true, a small clock is added to the bottom right corner of every icon representing a time-dependent feature, i.e. a feature which is not valid 24/7 but only for a specific time period, e.g. at night or on Sundays. Use this in order to distinguish time-dependent from time-independent features within one Feature Layer theme."
        },
        "strokesDashed" : {
          "type" : "boolean",
          "description" : "If true, a stroke representing a time-dependent feature is drawn dashed instead of solid. Use this in order to distinguish time-dependent from time-independent features within one Feature Layer theme."
        },
        "irrelevantIconsGrayed" : {
          "type" : "boolean",
          "description" : "If true, the icon of a feature which is not valid for the given time-consideration scenario will be drawn in gray. E.g. when requesting time-consideration scenario 'snapshot' at 3 p.m., features valid only at night are displayed with a gray icon. Please make sure to use colored icons when using this feature. Use this to distinguish relevant features from those not relevant for the selected time-consideration scenario."
        },
        "irrelevantStrokesGrayed" : {
          "type" : "boolean",
          "description" : "If true, the stroke of a feature which is not valid for the given time-consideration scenario will be drawn in gray. Please make sure to use colored strokes when using this feature. Use this to distinguish relevant features from those not relevant for the selected time-consideration scenario."
        },
        "irrelevantPolygonsGrayed" : {
          "type" : "boolean",
          "description" : "If true, the polygon of a feature which is not valid for the given time-consideration scenario will be drawn in gray and hatched. Please make sure to use colored polygons when using this feature. Use this to distinguish relevant features from those not relevant for the selected time-consideration scenario."
        }
      },
      "description" : "Defines how to modify the style of restricted features, e.g. time-dependent features or those not relevant by time.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.renderingprofile.TimeDependencyStyle"
    },
    "TimeDependentContentIgnoredLimitation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResultLimitation"
      }, {
        "type" : "object",
        "required" : [ "contentDescription" ],
        "properties" : {
          "contentDescription" : {
            "type" : "string",
            "description" : "Description of ignored content"
          }
        },
        "description" : "This result limitation indicates that the current route traverses areas with time-dependent content which is not taken into consideration.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.timeconsideration.TimeDependentContentIgnoredLimitation"
      } ],
      "x-discriminator-value" : "TimeDependentContentIgnoredLimitation",
      "x-ms-discriminator-value" : "TimeDependentContentIgnoredLimitation"
    },
    "TimeOfDay" : {
      "type" : "string",
      "description" : "Defines a time of day (24-hour format). Pattern: (\\[01\\]?\\[0-9\\]|2\\[0-3\\]):\\[0-5\\]\\[0-9\\].\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.TimeOfDay"
    },
    "TimeRestriction" : {
      "type" : "string",
      "description" : "Defines the kinds of time restrictions present in Feature Layer data.  \n * `ALL` - All elements will be taken into account.  \n * `UNRESTRICTED` - Only elements without a restriction in validity will be taken into account.  \n * `RESTRICTED` - Only elements with a restriction in validity will be taken into account.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.renderingprofile.TimeRestriction",
      "enum" : [ "ALL", "UNRESTRICTED", "RESTRICTED" ],
      "x-ms-enum" : {
        "name" : "TimeRestriction",
        "modelAsString" : false
      }
    },
    "TimeSpanConsideration" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TimeConsideration"
      }, {
        "type" : "object",
        "properties" : {
          "referenceTime" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The reference time at which all data which have time restrictions will be evaluated. If no reference time is set, the current UTC time is used."
          },
          "timeSpan" : {
            "description" : "The length of the time span in seconds.",
            "$ref" : "#/definitions/Duration"
          }
        },
        "description" : "This time-consideration scenario evaluates all data which have time restrictions in the given time span. Only attributes which have the same state throughout the time span are considered, e.g. long-term blockings. Attributes which have different states in the time span are not considered. For rendering this means that the map shows the state which is valid for the complete time span. For routing this means that each segment of the route considers only those attributes which are valid for the complete time span. Route calculation results in better performance compared to the exact scenarios.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.timeconsideration.TimeSpanConsideration"
      } ],
      "x-discriminator-value" : "TimeSpanConsideration",
      "x-ms-discriminator-value" : "TimeSpanConsideration"
    },
    "TimeViolation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TourViolation"
      }, {
        "type" : "object",
        "properties" : {
          "exceedance" : {
            "description" : "Time by which the limit is exceeded.",
            "$ref" : "#/definitions/Duration"
          }
        },
        "description" : "Specifies a violation that involves a time limit. This violation has one of the following tour event violation types: PLANNING\\_HORIZON, OPERATING\\_INTERVAL, TOUR\\_START\\_INTERVAL, OPENING\\_INTERVAL, MAXIMUM\\_TRAVEL\\_TIME\\_PER\\_TOUR, MAXIMUM\\_DRIVING\\_TIME\\_PER\\_TOUR, MAXIMUM\\_TRAVEL\\_TIME\\_PER\\_DRIVER, MAXIMUM\\_DRIVING\\_TIME\\_PER\\_DRIVER, TRIP\\_START\\_INTERVAL.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.tourplanning.TimeViolation"
      } ],
      "x-discriminator-value" : "TimeViolation",
      "x-ms-discriminator-value" : "TimeViolation"
    },
    "TimeZone" : {
      "type" : "object",
      "required" : [ "utcOffset" ],
      "properties" : {
        "utcOffset" : {
          "description" : "The offset to UTC in minutes.",
          "$ref" : "#/definitions/UTCOffset"
        },
        "includedDaylightSavingTime" : {
          "description" : "The daylight saving time included in the above offset in minutes.",
          "$ref" : "#/definitions/Minutes"
        }
      },
      "description" : "Specifies a time zone by its offset to UTC and daylight saving time.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.types.TimeZone"
    },
    "TimeZoneRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "required" : [ "coordinate" ],
        "properties" : {
          "coordinate" : {
            "description" : "The coordinate of the location in question. The coordinate must be on a land-based area covered by the map and close to some road. The time zone cannot be determined for coordinates in the sea. In such a case a UTCOffsetNotDeterminableException is thrown. See technical concept about time zones for details.",
            "$ref" : "#/definitions/Coordinate"
          },
          "referenceDate" : {
            "type" : "string",
            "format" : "date",
            "description" : "The date to determine the daylight saving time for the given location. If not specified the time zone valid now will be returned. If daylight saving time changes at this date, the status at 12 noon will be assumed. Consequently, if daylight saving time changes from winter to summer at this date, summer will be returned."
          }
        },
        "description" : "Specifies the coordinate and an optional reference date to determine the daylight saving time.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.TimeZoneRequest"
      } ],
      "x-discriminator-value" : "TimeZoneRequest",
      "x-ms-discriminator-value" : "TimeZoneRequest"
    },
    "TimeZoneResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "properties" : {
          "timeZone" : {
            "description" : "Specifies time zone and daylight saving time.",
            "$ref" : "#/definitions/TimeZone"
          }
        },
        "description" : "The time zone of the given location\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdata.TimeZoneResponse"
      } ],
      "x-discriminator-value" : "TimeZoneResponse",
      "x-ms-discriminator-value" : "TimeZoneResponse"
    },
    "Timeouts" : {
      "type" : "object",
      "properties" : {
        "queueingTimeout" : {
          "description" : "Maximum time that this request may remain in the request queue if no module process is available to handle the request. This value overrides the value of `core.requestQueueTimeout` for synchronous and `core.jobs.jobQueueTimeout` for asynchronous requests, respectively.",
          "$ref" : "#/definitions/Milliseconds"
        },
        "computationTimeout" : {
          "description" : "Maximum time that this request may take to execute on a module process. This value overrides the value of `core.moduleTimeout` for synchronous and `core.jobs.jobModuleTimeout` for asynchronous requests, respectively. If the timeout is exceeded, the request is tried to be stopped. An intermediate result is returned together with an IntermediateResponseLimitation if it is already available. Otherwise a XServerException containing a exceptions.RequestTimedOutException is thrown.",
          "$ref" : "#/definitions/Milliseconds"
        }
      },
      "description" : "Overrides the timeouts configured in `xserver.conf` for the current request.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.service.Timeouts"
    },
    "Tolerance" : {
      "type" : "number",
      "format" : "double",
      "description" : "Defines a percent value greater than or equal 0. Range: 0.0 ??? value.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.Tolerance"
    },
    "Toll" : {
      "type" : "object",
      "properties" : {
        "tollPenalty" : {
          "description" : "The penalty for each segment for which the current vehicle has to pay toll. This penalty is applied for roads with usage-dependent payment. It is not applied for roads which require a vignette.",
          "$ref" : "#/definitions/Penalty"
        }
      },
      "description" : "Defines the parameters for toll specific segment attributes, e.g. penalty of toll segments, etc.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.routingprofile.Toll"
    },
    "TollCost" : {
      "type" : "object",
      "required" : [ "amount", "currency" ],
      "properties" : {
        "amount" : {
          "type" : "number",
          "format" : "double",
          "description" : "The amount of the costs in the specified currency."
        },
        "currency" : {
          "description" : "The currency code.",
          "$ref" : "#/definitions/CurrencyCode"
        },
        "paymentMethods" : {
          "type" : "array",
          "items" : {
            "description" : "The payment methods how the cost can be paid.",
            "$ref" : "#/definitions/PaymentMethod"
          }
        },
        "electronicTollCollectionSubscriptions" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "description" : "The required electronic toll collection subscriptions for the payment method PaymentMethod.ELECTRONIC\\_TOLL\\_COLLECTION\\_SUBSCRIPTION. It is only populated if this payment method is applicable for the cost. In the request the subscriptions of the vehicle can be specified. The available subscriptions can be requested through the xRuntime service and are returned in xruntime.TollFeatures.electronicTollCollectionSubscriptions."
          }
        },
        "convertedCost" : {
          "description" : "The amount that has to be paid converted to the requested currency. It is only returned if this currency is set in the route options of the request. It is still returned in case the requested currency and the currency in which the cost is captured in the data are the same.",
          "$ref" : "#/definitions/Cost"
        }
      },
      "description" : "Represents a single toll cost specifying the amount, currency, and optional meta information.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.TollCost"
    },
    "TollDetailLevel" : {
      "type" : "string",
      "description" : "Specifies the detail level for toll features.  \n * `BASIC` - Only basic toll summaries for a route and its legs are supported, as well as the routingprofile.Toll.tollPenalty to avoid or prefer toll roads. Not supported is the detailed toll information for a route including toll costs and toll systems, and the toll events. Rendering of toll roads is also not supported.  \n * `DETAILED` - Detailed toll information is supported: besides the toll summaries also detailed information about the toll costs, toll systems, and toll events along the route are supported. The routingprofile.Toll.tollPenalty to avoid or prefer toll roads supports vehicle dependency. Rendering of toll roads is supported as well.  \n * `MIXED` - The map is composed of countries at different detail levels. Only used for the complete map, not for a country or a subdivision.  \n * `UNSPECIFIED` - The detail level is unknown. This is probably the case when the map version is newer than the xServer version and contains unsupported data.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.xruntime.TollDetailLevel",
      "enum" : [ "BASIC", "DETAILED", "MIXED", "UNSPECIFIED" ],
      "x-ms-enum" : {
        "name" : "TollDetailLevel",
        "modelAsString" : false
      }
    },
    "TollEvent" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RouteEvent"
      }, {
        "type" : "object",
        "properties" : {
          "sectionIndex" : {
            "description" : "Index of the corresponding toll section if toll sections are requested in ResultFields.toll. Because toll sections can overlap it is not guaranteed that the display names of the toll event and the toll section match. Instead, the section indexes of a pair of ENTER and EXIT events define the range of sections between the two events.",
            "$ref" : "#/definitions/Index"
          },
          "displayName" : {
            "type" : "string",
            "description" : "The display name of the toll event. It is only populated if a name is available. For example, this name can be a toll location name defined by the toll operator."
          },
          "accessType" : {
            "description" : "The access type specifies how a toll section is accessed.",
            "$ref" : "#/definitions/AccessType"
          },
          "relatedEventIndex" : {
            "description" : "For accessType ENTER this index points to the corresponding event with accessType EXIT and vice-versa. Not present otherwise.",
            "$ref" : "#/definitions/Index"
          }
        },
        "description" : "A toll event specifies if a toll road has been entered or exited and links that event to related toll events and toll sections.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.TollEvent"
      } ],
      "x-discriminator-value" : "TollEvent",
      "x-ms-discriminator-value" : "TollEvent"
    },
    "TollFeatures" : {
      "type" : "object",
      "properties" : {
        "detailLevel" : {
          "description" : "The toll detail level of the map. According to this level, some data and toll features may not be available.",
          "$ref" : "#/definitions/TollDetailLevel"
        },
        "electronicTollCollectionSubscriptions" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "description" : "The electronic toll collection subscriptions that are available in the map. These values can be set in the vehicle profile as parameter for the toll calculation."
          }
        }
      },
      "description" : "Specifies the available toll features for a map.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.TollFeatures"
    },
    "TollOnlyTimeConsideration" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TimeConsideration"
      }, {
        "type" : "object",
        "properties" : {
          "referenceTime" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The reference time at which the toll data is to be evaluated. If no reference time is set, the current UTC time is used."
          }
        },
        "description" : "This time-consideration scenario only evaluates toll data at the given reference time.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.timeconsideration.TollOnlyTimeConsideration"
      } ],
      "x-discriminator-value" : "TollOnlyTimeConsideration",
      "x-ms-discriminator-value" : "TollOnlyTimeConsideration"
    },
    "TollOptions" : {
      "type" : "object",
      "properties" : {
        "returnZeroCosts" : {
          "type" : "boolean",
          "description" : "Set this parameter to true, if the toll summaries should contain costs with amounts of zero when no toll applies.  \r\nRequires detailed toll data to be used."
        }
      },
      "description" : "Specifies how the toll shall be calculated.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.TollOptions"
    },
    "TollResult" : {
      "type" : "object",
      "properties" : {
        "summary" : {
          "description" : "The total toll costs.",
          "$ref" : "#/definitions/TollSummary"
        },
        "sections" : {
          "type" : "array",
          "items" : {
            "description" : "The list of individual toll sections along the route. All toll section costs are always returned in the local currency. It provides also meta information that can be used to group and sum up the toll costs as needed. For example, the country in which the toll has to be paid or the toll system. The list is only populated if requested by TollResultFields.sections.",
            "$ref" : "#/definitions/TollSection"
          }
        },
        "systems" : {
          "type" : "array",
          "items" : {
            "description" : "The list of all toll systems along the route. It is only populated if requested by TollResultFields.systems.",
            "$ref" : "#/definitions/TollSystem"
          }
        }
      },
      "description" : "Specifies all the data concerning toll consisting of a toll summary and optionally more detailed information about the individual toll sections to be paid and the toll systems on the route.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.Toll"
    },
    "TollResultFields" : {
      "type" : "object",
      "properties" : {
        "enabled" : {
          "type" : "boolean",
          "description" : "Specifies if the toll shall be returned for the complete route."
        },
        "sections" : {
          "type" : "boolean",
          "description" : "Specifies if the toll shall contain detailed information about the sections."
        },
        "systems" : {
          "type" : "boolean",
          "description" : "Specifies if the toll shall contain the toll systems."
        }
      },
      "description" : "Specifies if and to what extent the toll shall be calculated and returned for the complete route.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.TollResultFields"
    },
    "TollRoadType" : {
      "type" : "string",
      "description" : "Represents reasons why toll is charged.  \n * `GENERAL` - A general toll road.  \n * `CITY` - The toll is charged because a whole city is subject to toll.  \n * `BRIDGE` - The toll is charged because of a bridge.  \n * `TUNNEL` - The toll is charged because of a tunnel.  \n * `FERRY` - The toll is charged because of a ferry.  \n * `MOUNTAIN_PASS` - The toll is charged because of a mountain pass.  \n * `UNSPECIFIED` - Fallback value to be substituted for enumeration values which were added in an API version that is newer than the request version. When using the current API, this value will never be returned.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.xroute.TollRoadType",
      "enum" : [ "GENERAL", "CITY", "BRIDGE", "TUNNEL", "FERRY", "MOUNTAIN_PASS", "UNSPECIFIED" ],
      "x-ms-enum" : {
        "name" : "TollRoadType",
        "modelAsString" : false
      }
    },
    "TollSection" : {
      "type" : "object",
      "properties" : {
        "cost" : {
          "description" : "The toll cost of the section. It is always returned in the currency in which it is captured in the data, which is usually the local currency of the country.",
          "$ref" : "#/definitions/TollCost"
        },
        "alternativeCosts" : {
          "type" : "array",
          "items" : {
            "description" : "Alternative costs for the section with different payment methods or different subscriptions. For example, consider a toll section with two alternative costs depending on the payment method, one more expensive with cash, and another less expensive which is applicable only with a subscription for an electronic toll collection system. If there is no such subscription configured for the vehicle, the section cost is the more expensive cash cost, and here the alternative and less expensive cost with the subscription is returned.",
            "$ref" : "#/definitions/TollCost"
          }
        },
        "officialDistance" : {
          "description" : "The official distance defined by the toll operator. It is only populated if the toll operator provides an official distance.",
          "type" : "number"
        },
        "tollRoadType" : {
          "description" : "The toll road type refers to the reason why toll is charged, e.g. tunnel, bridge, or mountain pass.",
          "$ref" : "#/definitions/TollRoadType"
        },
        "country" : {
          "description" : "The country in which the costs have to be paid.",
          "$ref" : "#/definitions/CountryCode"
        },
        "tollSystemIndex" : {
          "description" : "The index in the list of toll systems the toll section belongs to. The index is only populated if the toll systems are requested by TollResultFields.systems.",
          "$ref" : "#/definitions/Index"
        },
        "startNodeIndex" : {
          "description" : "The index in the list of RouteResponse.nodes where the toll section begins. It is available only if the list of nodes is requested by ResultFields.nodes.",
          "$ref" : "#/definitions/Index"
        },
        "endNodeIndex" : {
          "description" : "The index in the list of RouteResponse.nodes where the toll section ends. It is available only if the list of nodes is requested by ResultFields.nodes.",
          "$ref" : "#/definitions/Index"
        },
        "displayName" : {
          "type" : "string",
          "description" : "A name that characterizes the toll section. For example it can relate to the names of the road intersections, to the area in general or to the type of toll."
        }
      },
      "description" : "Represents one single section of the route for which the toll operator has defined toll costs. Besides the toll costs further information is optionally provided such as alternative costs with different payment methods or an official distance for the section defined by the toll operator.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.TollSection"
    },
    "TollSummary" : {
      "type" : "object",
      "properties" : {
        "costs" : {
          "type" : "array",
          "items" : {
            "description" : "The total toll costs for the part of the route the toll summary represents. If there are no tolls on this part of the route the costs array is empty.  \r\nIf a currency is specified the costs array consists of one element with the toll cost in the specified currency. Otherwise, the costs are summed up separately for each local currency that is involved.",
            "$ref" : "#/definitions/Cost"
          }
        },
        "countries" : {
          "type" : "array",
          "items" : {
            "description" : "The total toll costs aggregated by country for the part of the route the toll summary represents.  \r\nIt is only returned if detailed toll data is used.",
            "$ref" : "#/definitions/CountryCost"
          }
        }
      },
      "description" : "Specifies key data concerning toll, for example the toll cost. Depending on the object that contains the toll summary it represents the summed up toll data either for the complete route or for some part of the route.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.TollSummary"
    },
    "TollSystem" : {
      "type" : "object",
      "properties" : {
        "name" : {
          "type" : "string",
          "description" : "The name of the toll system. For example, Florida Turnpike, or TollCollect German Autobahn."
        },
        "operatorName" : {
          "type" : "string",
          "description" : "The name of the toll operator. For example, TollCollect."
        },
        "tariffVersion" : {
          "type" : "string",
          "description" : "The tariff version that has been used."
        },
        "tariffVersionValidFrom" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "The starting date of the tariff version validity. Note that this date can also be later than a specified reference time: In case there is no tariff version that is valid at a specified reference time the tariff version with the earliest valid from date is used."
        }
      },
      "description" : "Represents a toll system.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.TollSystem"
    },
    "Tour" : {
      "type" : "object",
      "required" : [ "vehicleId" ],
      "properties" : {
        "vehicleId" : {
          "type" : "string",
          "description" : "The reference to the specific vehicle that is used to conduct this tour."
        },
        "vehicleStartLocationId" : {
          "type" : "string",
          "description" : "ID of this tour's vehicle's start location. This is always identical to the start location ID of the vehicle that is used to conduct this tour."
        },
        "vehicleEndLocationId" : {
          "type" : "string",
          "description" : "ID of this tour's vehicle's end location. This is always identical to the end location ID of the vehicle that is used to conduct this tour."
        },
        "trips" : {
          "type" : "array",
          "items" : {
            "description" : "A sequence of trips along this tour.",
            "$ref" : "#/definitions/Trip"
          }
        }
      },
      "description" : "As an operation schedule for a single vehicle, a tour provides the information which tasks are carried out in which order by the specified vehicle respectively its driver. There is at most one tour per vehicle. A tour contains a sequence of trips. See Tours and Trips.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.Tour"
    },
    "TourEvent" : {
      "type" : "object",
      "required" : [ "duration", "startTime" ],
      "properties" : {
        "startTime" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "Start time of the event. The time zone is that of the planning horizon (if a planning horizon is defined) or that of a given location."
        },
        "tripId" : {
          "type" : "string",
          "description" : "ID of the trip this event is referring to, for example for a TRIP\\_START event. Not set for events that do not belong to a specific trip such as DRIVING events between depot sites of adjacent trips."
        },
        "locationId" : {
          "type" : "string",
          "description" : "ID of the location where the vehicle is stopped during this event. Not set for events that do not belong to a specific site such as DRIVING events or BREAK events that occur en route between two stops."
        },
        "orderId" : {
          "type" : "string",
          "description" : "ID of the order that is currently carried if the event is a SERVICE event. Not set for other event types."
        },
        "eventTypes" : {
          "type" : "array",
          "items" : {
            "description" : "Types of this event.",
            "$ref" : "#/definitions/TourEventType"
          }
        },
        "tourViolations" : {
          "type" : "array",
          "items" : {
            "description" : "Violations of this event.",
            "$ref" : "#/definitions/TourViolation"
          }
        },
        "duration" : {
          "description" : "Duration of this event.",
          "$ref" : "#/definitions/Duration"
        }
      },
      "description" : "Different kinds of events that can happen during execution of a tour.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.TourEvent"
    },
    "TourEventType" : {
      "type" : "string",
      "description" : "Specifies the type of a tour event. In xRoute, only the following events are returned: SERVICE, WAITING, BREAK, DAILY\\_REST. In xTour, all the events are returned.  \n * `DRIVING` - Indicates a driving period.  \n * `SERVICE` - Indicates a service period.  \n * `WAITING` - Indicates a waiting period.  \n * `BREAK` - Indicates a break period.  \n * `DAILY_REST` - Indicates a daily rest period.  \n * `TRIP_START` - Indicates the start of a trip.  \n * `TRIP_END` - Indicates the end of a trip.  \n * `TOUR_START` - Indicates the start of a tour.  \n * `TOUR_END` - Indicates the end of a tour.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.tourplanning.TourEventType",
      "enum" : [ "DRIVING", "SERVICE", "WAITING", "BREAK", "DAILY_REST", "TRIP_START", "TRIP_END", "TOUR_START", "TOUR_END" ],
      "x-ms-enum" : {
        "name" : "TourEventType",
        "modelAsString" : false
      }
    },
    "TourPlanProgress" : {
      "allOf" : [ {
        "$ref" : "#/definitions/JobProgress"
      }, {
        "type" : "object",
        "description" : "The base type for any progress that is returned from the tour planning algorithm. Currently we do not provide any kind of progress for that.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.TourPlanProgress"
      } ],
      "x-discriminator-value" : "TourPlanProgress",
      "x-ms-discriminator-value" : "TourPlanProgress"
    },
    "TourPlanningCalculationMode" : {
      "type" : "string",
      "description" : "Enumeration to define the calculation behaviour of the algorithm, i.e. if the focus of calculation is on performance, quality or both.  \n * `PERFORMANCE` - The algorithm's focus is on performance. A smaller search space for solutions is considered during the computation.  \n * `STANDARD` - The algorithm chooses a standard trade-off between quality and performance of the algorithm.  \n * `QUALITY` - The algorithm's focus is on high solution quality. A larger search space for solutions is considered during the computation.  \n * `AVOID_INTERSECTIONS` - The algorithm's focus is to avoid intersections of legs. Note that the number of planned vehicles may be higher compared to the results of the calculation modes performance, standard and quality, especially for requests with many restrictions such as disjoint opening intervals. A larger search space for solutions is considered during the computation.  \n * `CUSTOM` - The algorithm's focus is adapted to the customer's needs. It is necessary to define the custom calculation mode configuration accordingly.  \n * `EVALUATE` - The algorithm does not plan anything. A response is generated for all input tours of the request's input plan without changing these tours.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.xtour.CalculationMode",
      "enum" : [ "PERFORMANCE", "STANDARD", "QUALITY", "AVOID_INTERSECTIONS", "CUSTOM", "EVALUATE" ],
      "x-ms-enum" : {
        "name" : "TourPlanningCalculationMode",
        "modelAsString" : false
      }
    },
    "TourPlanningLocation" : {
      "type" : "object",
      "required" : [ "$type", "id", "routeLocation" ],
      "discriminator" : "$type",
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "A unique ID for this location. This ID can be used to reference the location from other elements, for example from orders or vehicles."
        },
        "routeLocation" : {
          "description" : "The exact map coordinate of this location.",
          "$ref" : "#/definitions/RouteLocation"
        },
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "The abstract base type for all kinds of locations. See Orders, Locations, and Stops.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.Location"
    },
    "TourReport" : {
      "type" : "object",
      "required" : [ "costReport", "vehicleId" ],
      "properties" : {
        "vehicleId" : {
          "type" : "string",
          "description" : "ID of vehicle of this tour."
        },
        "costReport" : {
          "description" : "Cost related values for this tour.",
          "$ref" : "#/definitions/CostReport"
        },
        "violationReport" : {
          "description" : "Summary for tour violations of this tour.",
          "$ref" : "#/definitions/TourViolationReport"
        },
        "tripReports" : {
          "type" : "array",
          "items" : {
            "description" : "Each element contains additional information about the trip with the corresponding ID.",
            "$ref" : "#/definitions/TripReport"
          }
        },
        "tourEvents" : {
          "type" : "array",
          "items" : {
            "description" : "Tour events for this tour. They are sorted by time and cover the whole period of the tour without gaps or overlaps. The time zone of the tour events is the time zone of the planning horizon (if a planning horizon is defined) or that of a given location.",
            "$ref" : "#/definitions/TourEvent"
          }
        },
        "legReports" : {
          "type" : "array",
          "items" : {
            "description" : "Contains information for the route between two successive stops of this tour.",
            "$ref" : "#/definitions/LegReport"
          }
        }
      },
      "description" : "More detailed information about a tour, containing reports for each trip, an accumulated cost report and a list of events that occur along the tour.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.TourReport"
    },
    "TourRestrictions" : {
      "type" : "object",
      "properties" : {
        "singleTripPerTour" : {
          "type" : "boolean",
          "description" : "Restricts the number of trips for each tour to one. See Tours and Trips."
        },
        "singleDepotPerTour" : {
          "type" : "boolean",
          "description" : "Restricts the number of depots of a tour to at most one. That means a tour without depots is also valid if this parameter is set to true. See Tours and Trips."
        },
        "maximumNumberOfCustomerStopsPerTour" : {
          "description" : "Restricts the maximum allowed number of customer stops, i.e. stops at customer sites, per tour. If this parameter is set, maximum number of customer stops at vehicles must not be set, otherwise an exception is thrown. Is infinite if it is not set.",
          "$ref" : "#/definitions/NonNegativeInteger"
        },
        "maximumDistancePerTour" : {
          "description" : "Restricts the maximum allowed total distance per tour in meters. If this parameter is set, maximum distance at vehicles must not be set, otherwise an exception is thrown. Is infinite if it is not set. This restriction is ignored for ToursInExecutionRequests.",
          "type" : "number"
        },
        "maximumTravelTimePerTour" : {
          "description" : "Restricts the maximum allowed total travel time per tour in seconds. The travel time contains all waiting, service and driving times. Drivers' working hours may be more restrictive and enforce a lower limit. If this parameter is set, maximum travel time at vehicles must not be set, otherwise an exception is thrown. Is infinite if it is not set. This restriction is ignored for ToursInExecutionRequests.",
          "$ref" : "#/definitions/Duration"
        },
        "maximumDrivingTimePerTour" : {
          "description" : "Restricts the maximum allowed total driving time per tour in seconds. Drivers' working hours may be more restrictive and enforce a lower limit. If this parameter is set, maximum driving time at vehicles must not be set, otherwise an exception is thrown. Is infinite if it is not set. Not supported for time-dependent driving times. This restriction is ignored for ToursInExecutionRequests.",
          "$ref" : "#/definitions/Duration"
        },
        "workingHours" : {
          "description" : "Defines the rules regarding drivers' working hours. Drivers' working hours are only active if this member is set.",
          "$ref" : "#/definitions/WorkingHours"
        },
        "mixedLoadingProhibitions" : {
          "type" : "array",
          "items" : {
            "description" : "Defines restrictions regarding which categories of orders are disallowed to be mixed on the same trip.",
            "$ref" : "#/definitions/MixedLoadingProhibition"
          }
        }
      },
      "description" : "Restrictions that can be set for a tour.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.TourRestrictions"
    },
    "TourStopOptions" : {
      "type" : "object",
      "properties" : {
        "openingIntervals" : {
          "type" : "array",
          "items" : {
            "description" : "The list of opening time windows. Opening intervals for this site, specified in one of the valid interval formats. Leaving this parameter empty means that the site is always open. Service can only start within one of the opening intervals. Moreover only time.StartDurationInterval and time.StartEndInterval are supported to define the opening intervals on a waypoint.",
            "$ref" : "#/definitions/Interval"
          }
        },
        "serviceTime" : {
          "description" : "The service time.",
          "$ref" : "#/definitions/Duration"
        }
      },
      "description" : "Describes the logistic information to apply on a waypoint ; such as the opening time windows and the service time.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.TourStopOptions"
    },
    "TourStructureFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InvalidTourRequestFault"
      }, {
        "type" : "object",
        "description" : "This fault is thrown if a tour structure is violated. For more information please have a look at the section valid tour structures of the technical concept for tours and trips.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.TourStructureFault"
      } ],
      "x-discriminator-value" : "TourStructureFault",
      "x-ms-discriminator-value" : "TourStructureFault"
    },
    "TourViolation" : {
      "type" : "object",
      "required" : [ "$type" ],
      "discriminator" : "$type",
      "properties" : {
        "causedByThisEvent" : {
          "type" : "boolean",
          "description" : "True if the violation is caused by the tour event that contains this tour violation. For violations of type VEHICLE\\_EQUIPMENT and MAXIMUM\\_QUANTITY\\_SCENARIO the order ID of the tour event references the order that caused this violation. For time violations this member is true for the first event of a specific type of time violation."
        },
        "type" : {
          "description" : "Type of the tour event violation. The documentation of the types derived from this type list the associated tour event violation types.",
          "$ref" : "#/definitions/TourViolationType"
        },
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "Base type for tour violations.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.tourplanning.TourViolation"
    },
    "TourViolationReport" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ViolationReport"
      }, {
        "type" : "object",
        "properties" : {
          "planningHorizonExceedance" : {
            "description" : "The duration by which the start or the end of the planning horizon is exceeded. Corresponds to tour events with violation type PLANNING\\_HORIZON.",
            "$ref" : "#/definitions/Duration"
          },
          "operatingIntervalExceedance" : {
            "description" : "The longest driver operating intervals exceedance. Corresponds to tour events with violation type OPERATING\\_INTERVAL.",
            "$ref" : "#/definitions/Duration"
          },
          "tourStartIntervalExceedance" : {
            "description" : "The duration by which the end of the tour start interval is exceeded. Corresponds to tour events with violation type TOUR\\_START\\_INTERVAL.",
            "$ref" : "#/definitions/Duration"
          },
          "maximumDrivingTimePerTourExceedance" : {
            "description" : "The duration by which the specified maximum driving time per tour is exceeded. (Either specified by an explicit value at maximum driving time of tour restrictions or maximum driving time of vehicle or by the drivers' working hours restriction). Corresponds to tour events with violation type MAXIMUM\\_DRIVING\\_TIME\\_PER\\_TOUR.",
            "$ref" : "#/definitions/Duration"
          },
          "maximumTravelTimePerTourExceedance" : {
            "description" : "The duration by which the the specified maximum travel time per tour is exceeded. (Either specified by an explicit value at maximum travel time of tour restrictions or maximum travel time of vehicle or by the drivers' working hours restriction). Corresponds to tour events with violation type MAXIMUM\\_TRAVEL\\_TIME\\_PER\\_TOUR.",
            "$ref" : "#/definitions/Duration"
          },
          "maximumDrivingTimePerDriverExceedance" : {
            "description" : "The duration by which the specified maximum driving time per driver is exceeded. Corresponds to tour events with violation type MAXIMUM\\_DRIVING\\_TIME\\_PER\\_DRIVER.",
            "$ref" : "#/definitions/Duration"
          },
          "maximumTravelTimePerDriverExceedance" : {
            "description" : "The duration by which the specified maximum travel time per driver is exceeded. Corresponds to tour events with violation type MAXIMUM\\_TRAVEL\\_TIME\\_PER\\_DRIVER.",
            "$ref" : "#/definitions/Duration"
          },
          "maximumTripStartIntervalExceedance" : {
            "description" : "The longest trip start interval exceedance. Corresponds to tour events with violation type TRIP\\_START\\_INTERVAL.",
            "$ref" : "#/definitions/Duration"
          },
          "maximumNumberOfCustomerStopsExceedance" : {
            "description" : "Number of stops by which the maximum number of customer stops per tour is exceeded. (Either specified by maximum number of customer stops of tour restrictions or maximum number of customer stops of vehicle) Corresponds to tour events with violation type MAXIMUM\\_NUMBER\\_OF\\_CUSTOMER\\_STOPS.",
            "$ref" : "#/definitions/PositiveInteger"
          },
          "maximumDistanceExceedance" : {
            "description" : "The distance by which the the specified maximum distance per tour is exceeded. The limit is either specified by maximum distance of tour restrictions or maximum distance of vehicle. Corresponds to tour events with violation type MAXIMUM\\_DISTANCE.",
            "type" : "number"
          }
        },
        "description" : "Violation related information describing tours. The tour violation report contains violation summaries of its parent object, which is a tour report.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.TourViolationReport"
      } ],
      "x-discriminator-value" : "TourViolationReport",
      "x-ms-discriminator-value" : "TourViolationReport"
    },
    "TourViolationType" : {
      "type" : "string",
      "description" : "Specifies the type of a tour event. In xRoute, only the following types are returned: OPENING\\_INTERVAL, MAXIMUM\\_TRAVEL\\_TIME\\_PER\\_TOUR, MAXIMUM\\_DRIVING\\_TIME\\_PER\\_TOUR. In xTour, all the types are returned.  \n * `PLANNING_HORIZON` - Indicates a violation of the planning horizon. This is caused by a tour event that begins outside the planning horizon. This violation is repeated for all subsequent events of the current tour.  \n * `OPERATING_INTERVAL` - Indicates a violation of the operating interval of the driver. This is caused by a tour event that begins outside of the operating intervals of the driver of the current tour. This violation is repeated for all subsequent events of the current trip.  \n * `TOUR_START_INTERVAL` - Indicates a violation of the tour start interval of the vehicle. This violation is only included at tour start events.  \n * `OPENING_INTERVAL` - Indicates a violation of the opening interval(s) of the current site. This is caused by service that begins after the end of the last opening interval of the current site. This violation is repeated for all subsequent events of the current stop.  \n * `MAXIMUM_TRAVEL_TIME_PER_TOUR` - Indicates a violation of the maximum allowed travel time per tour. This violation is repeated for all subsequent events of the current tour.  \n * `MAXIMUM_DRIVING_TIME_PER_TOUR` - Indicates a violation of the maximum allowed driving time per tour. This violation is repeated for all subsequent events of the current tour.  \n * `REST_POSITION` - Indicates that a daily rest for European drivers' working hours is not at the end of a trip. The expected position for a daily rest is at the end of a trip. Daily rests at other positions are only scheduled if they are absolutely necessary to conform to the European drivers' working hours. This violation is only included at tour events of the violated daily rest.  \n * `MAXIMUM_QUANTITY_SCENARIO` - Indicates a violation of the maximum quantity scenario of the used vehicle. This violation is repeated for all subsequent events for which the maximum quantity of the vehicle is exceeded.  \n * `VEHICLE_EQUIPMENT` - Indicates a violation of the vehicle equipment required for the currently loaded orders. This violation is repeated for all subsequent events for which a vehicle equipment is missing.  \n * `MAXIMUM_TRAVEL_TIME_PER_DRIVER` - Indicates a violation of the maximum allowed travel time per driver as specified by the drivers' working hours restriction. Travel time prior to tour start as specified by the work logbook summary is also considered for this check. This violation is repeated for all subsequent events of the current tour.  \n * `MAXIMUM_DRIVING_TIME_PER_DRIVER` - Indicates a violation of the maximum allowed driving time per driver as specified by the drivers' working hours restriction. Driving time prior to tour start as specified by the work logbook summary is also considered for this check. This violation is repeated for all subsequent events of the current tour.  \n * `TRIP_START_INTERVAL` - Indicates a violation of the trip start interval. This violation is only included at trip start events.  \n * `MAXIMUM_NUMBER_OF_CUSTOMER_STOPS` - Indicates a violation of the maximum allowed number of stops per tour. This violation only occurs at events of type service at customer stops and is repeated for all subsequent events.  \n * `CUSTOMER_STOP_POSITION_IN_TRIP` - Indicates a violation of the customer stop position in trip. This violation only occurs at events of type service at customer stops when a position in trip set for this site and the current customer stop is not the first/last one in the trip.  \n * `TRIP_SECTION` - Indicates a violation of the trip section numbers. This violation only occurs at events of type service at customer stops when the previous trip section number is higher than the one at this customer site.  \n * `MAXIMUM_DISTANCE` - Indicates a violation of the maximum allowed distance per tour. This violation is repeated for all subsequent events of the current tour.  \n * `MIXED_LOADING_PROHIBITION` - Indicates a violation of a mixed loading prohibition. This violation only occurs at events of type service.  \n * `ROUTE` - Indicates a violation where the route between two locations is calculated with route violations. This violation only occurs at events of type driving.  \n * `REACHABILITY` - Indicates a violation where the route between two locations was calculated by direct distance instead of the road network. This violation only occurs at events of type driving.  \n * `UNSPECIFIED` - Fallback value to be substituted for enumeration values which were added in an API version that is newer than the request version. When using the current API, this value will never be returned.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.tourplanning.TourViolationType",
      "enum" : [ "PLANNING_HORIZON", "OPERATING_INTERVAL", "TOUR_START_INTERVAL", "OPENING_INTERVAL", "MAXIMUM_TRAVEL_TIME_PER_TOUR", "MAXIMUM_DRIVING_TIME_PER_TOUR", "REST_POSITION", "MAXIMUM_QUANTITY_SCENARIO", "VEHICLE_EQUIPMENT", "MAXIMUM_TRAVEL_TIME_PER_DRIVER", "MAXIMUM_DRIVING_TIME_PER_DRIVER", "TRIP_START_INTERVAL", "MAXIMUM_NUMBER_OF_CUSTOMER_STOPS", "CUSTOMER_STOP_POSITION_IN_TRIP", "TRIP_SECTION", "MAXIMUM_DISTANCE", "MIXED_LOADING_PROHIBITION", "ROUTE", "REACHABILITY", "UNSPECIFIED" ],
      "x-ms-enum" : {
        "name" : "TourViolationType",
        "modelAsString" : false
      }
    },
    "ToursInExecutionRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "required" : [ "storedRequestId" ],
        "properties" : {
          "storedRequestId" : {
            "type" : "string",
            "description" : "ID of the stored PlanToursRequest that contains all information about the tours as input plan. Currently, the list of break intervals must be empty for all drivers in the stored request and no driver may have more than one driver operating interval specified."
          },
          "executionStates" : {
            "type" : "array",
            "items" : {
              "description" : "The current state for each tour in execution that gets recomputed by evaluteToursInExecution. Note that all specified tours are recomputed using the stored profile of the request. For vehicles with differing vehicle profiles create a separate ToursInExecutionRequest for each vehicle.",
              "$ref" : "#/definitions/ExecutionState"
            }
          }
        },
        "description" : "The request object for the service method evaluateTours.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.ToursInExecutionRequest"
      } ],
      "x-discriminator-value" : "ToursInExecutionRequest",
      "x-ms-discriminator-value" : "ToursInExecutionRequest"
    },
    "ToursResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "required" : [ "costReport" ],
        "properties" : {
          "costReport" : {
            "description" : "Cost related values accumulated over all tours.",
            "$ref" : "#/definitions/CostReport"
          },
          "tours" : {
            "type" : "array",
            "items" : {
              "description" : "A list of tours, one for each vehicle that is used in the tour plan, referenced by the corresponding vehicle ID.",
              "$ref" : "#/definitions/Tour"
            }
          },
          "tourReports" : {
            "type" : "array",
            "items" : {
              "description" : "Each element contains additional information about the tour of the referenced vehicle ID.",
              "$ref" : "#/definitions/TourReport"
            }
          },
          "orderIdsNotPlanned" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "description" : "References to orders that could not be planned in the response of a PlanToursRequest. These orders are not part of the tours.\r\n\r\nFor a ChangeToursRequest the entries depend on the use case:\r\n\r\n *  ChangeToursAction only consisting of explicit changes:\r\n    \r\n     *  Example: MoveOrdersAction with exclusively specified insertion positions of type InsertionBeforeSpecifiedPosition or InsertionAfterSpecifiedPosition\r\n     *  Unplanned orders: If the ChangeToursAction leads to violated tours, violations are added to the response. None of the orders of the ChangeToursAction is unplanned. No unplanned orders are returned.\r\n *  ChangeToursAction with (partially) unspecified insertions:\r\n    \r\n     *  Example: MoveOrdersAction with at least one unspecified insertion of type InsertionAtBestPosition\r\n     *  Unplanned orders: Each order that cannot be planned is returned as unplanned order. The target tour does not have any violations, if it was not violated before the action.\r\n *  ChangeToursAction of type RemoveOrdersAction: All removed orders are returned as unplanned orders."
            }
          },
          "orderIdsNotPlannable" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "description" : "References to orders which cannot be served by any vehicle in the fleet without a violation. These orders are part of orderIdsNotPlanned. For further information about the violation types please send a FindChangeToursProposalsRequest with an InsertionPositionsForOrdersQuery as described in the integration sample Analyzing Unscheduled Orders for each order. This field is only filled in the response of a PlanToursRequest and will be empty for the response of a ChangeToursRequest."
            }
          },
          "vehicleIdsNotPlanned" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "description" : "References to vehicle instances that are not used in the response of a PlanToursRequest or that were planned before but are no longer planned after performing a change tours action. These vehicles are not part of the tours."
            }
          },
          "vehicleIdsWithTourViolations" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "description" : "References vehicle instances of tours of the response that have at least one tour violation. If the response has no tour violations, this vector is empty."
            }
          },
          "vehicleIdsWithRouteViolations" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "description" : "References vehicle instances of tours of the response that have at least one route violation. If the response has no route violations, this vector is empty."
            }
          },
          "vehicleIdsWithDirectDistanceEstimation" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "description" : "References vehicle instances of tours of the response that have at least one leg which is estimated by direct distance. If the response has no legs estimated by direct distance, this vector is empty."
            }
          },
          "violated" : {
            "type" : "boolean",
            "description" : "True if there is any tour violation."
          },
          "routeViolated" : {
            "type" : "boolean",
            "description" : "True if there is at least one route violation at the leg."
          },
          "storedRequestId" : {
            "type" : "string",
            "description" : "Reference to the request that is stored in the session storage with this response as input plan. If there occur any problems with the session storage, an ObjectNotStoredLimitation is generated and this parameter is null even if storage was requested. In case of evaluateToursInExecution no storedRequestId is returned because the stored input plan does not change."
          }
        },
        "description" : "Contains the result of a PlanToursRequest, ChangeToursRequest or ToursInExecutionRequest. For the planTours case, all members refer to the complete plan. For the changeTours case, all members refer to the changed part of the plan. For the evaluateToursInExecution case, only the evaluated tours and their updated tour events are returned.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.ToursResponse"
      } ],
      "x-discriminator-value" : "ToursResponse",
      "x-ms-discriminator-value" : "ToursResponse"
    },
    "TrackPosition" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Position"
      }, {
        "type" : "object",
        "properties" : {
          "distanceFromPreviousPosition" : {
            "description" : "The travel distance from the previous position to this position. This value can be provided to improve the quality of the track matching.",
            "type" : "number"
          }
        },
        "description" : "Describes a position which belongs to a track by additional track related attributes.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xmatch.TrackPosition"
      } ],
      "x-discriminator-value" : "TrackPosition",
      "x-ms-discriminator-value" : "TrackPosition"
    },
    "TrackResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "required" : [ "distance" ],
        "properties" : {
          "distance" : {
            "description" : "The distance of the complete track. It is the sum of distances of all TrackResponse.matchedPaths and hence is a whole number without decimal places.",
            "type" : "number"
          },
          "matchedPaths" : {
            "type" : "array",
            "items" : {
              "description" : "The matched paths the track consists of. --",
              "$ref" : "#/definitions/MatchedPath"
            }
          },
          "geometry" : {
            "description" : "the geometry of the paths (i.e. a collection of polylines). --",
            "$ref" : "#/definitions/EncodedGeometry"
          },
          "matchedTrackPositions" : {
            "type" : "array",
            "items" : {
              "description" : "Detailed information on the matches of the input track positions --",
              "$ref" : "#/definitions/MatchedTrackPosition"
            }
          }
        },
        "description" : "Response of a matchTrack request.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xmatch.TrackResponse"
      } ],
      "x-discriminator-value" : "TrackResponse",
      "x-ms-discriminator-value" : "TrackResponse"
    },
    "TransformFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InvalidRequestFault"
      }, {
        "type" : "object",
        "properties" : {
          "wrongCoordinate" : {
            "description" : "Represents the coordinate which could not be transformed.",
            "$ref" : "#/definitions/Coordinate"
          },
          "srid" : {
            "type" : "string",
            "description" : "The SRID of the request coordinates."
          }
        },
        "description" : "This fault is thrown if an exception occured during transformation of input coordinates, geometries or bounds.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.TransformFault"
      } ],
      "x-discriminator-value" : "TransformFault",
      "x-ms-discriminator-value" : "TransformFault"
    },
    "TransportOrder" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Order"
      }, {
        "type" : "object",
        "properties" : {
          "quantities" : {
            "type" : "array",
            "items" : {
              "description" : "List of quantities of goods that should be transported from pickup site to delivery site. The maximum length of this list is 100. That is, up to 100 different quantity dimensions (e.g. number of pallets, weight, volume, etc.) can be distinguished. Transport orders can only be transported by a vehicle with a higher (or an equal) maximum quantity in every quantity dimension of at least one quantity scenario. The length of this list has to be the same for all transport orders and all maximum quantity scenarios of all vehicles. If and only if this list of quantities is empty for all transport orders, the list of maximum quantity scenarios of each vehicle must be empty.",
              "$ref" : "#/definitions/TransportQuantityUnit"
            }
          },
          "serviceTimeForPickup" : {
            "description" : "Overall service time at the site required to pick up the order. Additionally there may be a site dependent or vehicle dependent service time of the stop. See Service time calculation.",
            "$ref" : "#/definitions/Duration"
          },
          "serviceTimeForDelivery" : {
            "description" : "Overall service time at the site required to deliver the order. Additionally there may be a site dependent or vehicle dependent service time of the stop. See Service time calculation.",
            "$ref" : "#/definitions/Duration"
          }
        },
        "description" : "Order to transport goods from one depot site or customer site to another.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.TransportOrder"
      } ],
      "x-discriminator-value" : "TransportOrder",
      "x-ms-discriminator-value" : "TransportOrder"
    },
    "TransportQuantityUnit" : {
      "type" : "number",
      "format" : "double",
      "description" : "Defines a transport quantity as positive double value with 3 positions after the decimal point. Range: 0.000 ??? value ??? 1000000.000.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.TransportQuantityUnit"
    },
    "TravelTimeBasedHorizon" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Horizon"
      }, {
        "type" : "object",
        "required" : [ "travelTime" ],
        "properties" : {
          "travelTime" : {
            "description" : "A travel time that specifies the range of the horizon.",
            "$ref" : "#/definitions/Duration"
          }
        },
        "description" : "Represents a geographical horizon that is described by a travel time. Every point or road segment that is reachable from the source within the specified travel time is included in the horizon.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.routing.TravelTimeBasedHorizon"
      } ],
      "x-discriminator-value" : "TravelTimeBasedHorizon",
      "x-ms-discriminator-value" : "TravelTimeBasedHorizon"
    },
    "Trip" : {
      "type" : "object",
      "required" : [ "id" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "The reference ID of this trip. Response trips that are identical to input plan trips in stops and stop sequence have the same trip ID as the corresponding input plan trip. The ID also stays the same if the trip's position within its tour changes or if its vehicle changes. Response trips that are changed input plan trips or newly generated as result of a PlanToursRequest get a newly generated ID. Trip changes caused by a ChangeToursRequest do not change the trip ID."
        },
        "stops" : {
          "type" : "array",
          "items" : {
            "description" : "A sequence of stops along this trip. Each stop is served at a specific location, either a customer site or a depot site. The sequence of tasks within the stops is always sorted by Last In - First Out (LIFO). For more details, see Orders, Locations, and Stops.",
            "$ref" : "#/definitions/TripStop"
          }
        }
      },
      "description" : "An operation schedule for a single trip. A trip contains the sequence of stops that are served. At the beginning and end of each trip the vehicle does not carry any load. A trip starts at the vehicle start location or at a depot, and ends at the vehicle end location or at a depot. See Tours and Trips.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.Trip"
    },
    "TripDepotStructureFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TripStructureFault"
      }, {
        "type" : "object",
        "required" : [ "orderId", "taskType" ],
        "properties" : {
          "orderId" : {
            "type" : "string",
            "description" : "ID of the order that violates the trip depot structure."
          },
          "taskType" : {
            "description" : "Task type of the task that violates the trip depot structure.",
            "$ref" : "#/definitions/TaskType"
          }
        },
        "description" : "This fault is thrown if a trip structure is violated regarding depot sites.\r\n\r\nThis fault references one of the following:\r\n\r\n *  A pickup task at a depot that is not part of the consecutive pickup depot stops at the start of a trip.\r\n *  A task that is not a delivery at a depot but is executed after or in between the consecutive delivery depot stops at the end of a trip.\r\n\r\nFor more information please have a look at the technical concepts Tours and Trips and Orders, Locations and Stops.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.TripDepotStructureFault"
      } ],
      "x-discriminator-value" : "TripDepotStructureFault",
      "x-ms-discriminator-value" : "TripDepotStructureFault"
    },
    "TripReport" : {
      "type" : "object",
      "required" : [ "costReport", "tripId" ],
      "properties" : {
        "tripId" : {
          "type" : "string",
          "description" : "ID of the corresponding trip to this report."
        },
        "costReport" : {
          "description" : "Cost related values for this trip.",
          "$ref" : "#/definitions/CostReport"
        },
        "violationReport" : {
          "description" : "Summary for tour violations of this trip.",
          "$ref" : "#/definitions/TripViolationReport"
        },
        "orderGroupId" : {
          "type" : "string",
          "description" : "If there is at least one order with a groupId in the trip, the orderGroupId of a tripReport is the groupId that occurs most often among the orders of this trip. If no order of this trip has a groupId then this field is not set. If a planToursRequest has a trip in the input plan with different groupIds among the orders, first the orderGroupId of the trip is determined and then only orders of the same groupId are inserted in this trip during automatic planning. A changeToursRequest can change the orderGroupId of a trip for example by removing orders from the trip. All changeToursActions are performed even if options of the orderGroupConsideration are not fulfilled or if the orderGroupId does not match with any of the orderGroupIds of the target vehicle. For further information please have a look at the technical concept Order Groups."
        }
      },
      "description" : "More detailed information about a trip, containing an accumulated cost report.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.TripReport"
    },
    "TripStartInterval" : {
      "type" : "object",
      "required" : [ "interval", "tripId" ],
      "properties" : {
        "tripId" : {
          "type" : "string",
          "description" : "ID of the trip."
        },
        "interval" : {
          "description" : "Interval in which the trip with tripId must start. Start and end of the interval may be the same. The trip start interrupts a TourEvent of type BREAK or DAILY\\_REST.",
          "$ref" : "#/definitions/StartEndInterval"
        }
      },
      "description" : "Trip start interval in which the trip must start.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.TripStartInterval"
    },
    "TripStop" : {
      "type" : "object",
      "required" : [ "locationId" ],
      "properties" : {
        "locationId" : {
          "type" : "string",
          "description" : "The reference to the location of the site where the stop is served. This location is either a customer site or a depot site."
        },
        "customerId" : {
          "type" : "string",
          "description" : "ID corresponding to the customerId of a customer site. This parameter needs to be set if the locationId of the stop belongs to a customer site with defined customer ID. Else, the parameter must not be set."
        },
        "tasks" : {
          "type" : "array",
          "items" : {
            "description" : "A list of tasks, each being part of an order, that are carried out at the referenced site.",
            "$ref" : "#/definitions/OrderTask"
          }
        }
      },
      "description" : "A stop groups subsequent tasks of a tour that are carried out at the same site. If there is more than one task at the same customer site, tasks are grouped to one stop and scheduled in order of their type: DELIVERY tasks before VISIT tasks before PICKUP tasks. If there is more than one task at the same depot site, all DELIVERY tasks are grouped to one stop and all PICKUP tasks are grouped to another one. See Orders, Locations, and Stops.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.Stop"
    },
    "TripStructureFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TourStructureFault"
      }, {
        "type" : "object",
        "required" : [ "tripId", "vehicleId" ],
        "properties" : {
          "vehicleId" : {
            "type" : "string",
            "description" : "ID of the vehicle serving the input tour with invalid structure in case of a PlanToursRequest. In case of a ChangeToursRequest this parameter contains the ID of the vehicle that would serve a tour with invalid structure."
          },
          "tripId" : {
            "type" : "string",
            "description" : "ID of the input trip with invalid structure in case of a PlanToursRequest. In case of a ChangeToursRequest this parameter contains the ID of the trip that would have an invalid structure."
          }
        },
        "description" : "This fault is thrown if a trip structure is violated. For more information please have a look at the section valid tour structures of the technical concept for tours and trips.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.TripStructureFault"
      } ],
      "x-discriminator-value" : "TripStructureFault",
      "x-ms-discriminator-value" : "TripStructureFault"
    },
    "TripViolationReport" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ViolationReport"
      }, {
        "type" : "object",
        "properties" : {
          "tripStartIntervalExceedance" : {
            "description" : "The duration by which the end of the trip start interval is exceeded. Corresponds to tour events with violation type TRIP\\_START\\_INTERVAL.",
            "$ref" : "#/definitions/Duration"
          },
          "operatingIntervalExceedance" : {
            "description" : "The duration by which the end of the driver operating interval, in which the trip start lies, is exceeded. If the whole trip lies outside of the driver operating intervals, the exceedance is calculated by the difference to the end of the last driver operating interval. Corresponds to tour events with violation type OPERATING\\_INTERVAL.",
            "$ref" : "#/definitions/Duration"
          }
        },
        "description" : "Violation related information describing trips. The trip violation report contains violation summaries of its parent object, which is a trip report.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.TripViolationReport"
      } ],
      "x-discriminator-value" : "TripViolationReport",
      "x-ms-discriminator-value" : "TripViolationReport"
    },
    "TripsMergedFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TourStructureFault"
      }, {
        "type" : "object",
        "required" : [ "objectId", "tripIdA", "tripIdB", "vehicleId" ],
        "properties" : {
          "vehicleId" : {
            "type" : "string",
            "description" : "ID of the vehicle that would serve a tour with invalid structure."
          },
          "tripIdA" : {
            "type" : "string",
            "description" : "ID of the trip that would be merged with the trip corresponding to tripIdB."
          },
          "tripIdB" : {
            "type" : "string",
            "description" : "ID of the trip that would be merged with the trip corresponding to tripIdA."
          },
          "objectId" : {
            "type" : "string",
            "description" : "ID of the object in the ChangeToursAction that would cause the merge of two trips.\r\n\r\n *  In case of a move trips action it will be a tripId.\r\n *  In case of a move orders action it will be an orderId.\r\n *  In case of a remove orders action it will be an orderId.\r\n *  In case of a remove trips action it will be a tripId.\r\n *  In case of a move stops action it will be the position of a stop within the trip (either the position of the moved stop itself or of the stop containing the corresponding partner task)."
          }
        },
        "description" : "This fault is thrown if a ChangeToursRequest results in merging two trips.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.TripsMergedFault"
      } ],
      "x-discriminator-value" : "TripsMergedFault",
      "x-ms-discriminator-value" : "TripsMergedFault"
    },
    "TunnelRestrictionCode" : {
      "type" : "string",
      "description" : "Defines the main tunnel restriction codes according to ADR (\"European Agreement Concerning the International Carriage of Dangerous Goods by Road\"). There are some more restriction codes that are a combination of the main codes where the actual restriction code depends on other parameters of the vehicle and its load. For example, the restriction code B/D is B for tank carriage and D for other carriage.  \n * `NONE` - No restrictions for the transport of dangerous goods.  \n * `B` - Passage forbidden through tunnels of category B, C, D and E.  \n * `C` - Passage forbidden through tunnels of category C, D and E.  \n * `D` - Passage forbidden through tunnels of category D and E.  \n * `E` - Passage forbidden through tunnels of category E.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.vehicleprofile.TunnelRestrictionCode",
      "enum" : [ "NONE", "B", "C", "D", "E" ],
      "x-ms-enum" : {
        "name" : "TunnelRestrictionCode",
        "modelAsString" : false
      }
    },
    "TurnStrategy" : {
      "type" : "string",
      "description" : "Enumeration to define the turn strategy  \n * `NONE` - No additional cost is applied.  \n * `PREFER_PASSENGER_SIDE_TURNS` - Additional costs are applied on driver side turns.  \n * `CUSTOM` - Custom costs are applied.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.routingprofile.TurnStrategy",
      "enum" : [ "NONE", "PREFER_PASSENGER_SIDE_TURNS", "CUSTOM" ],
      "x-ms-enum" : {
        "name" : "TurnStrategy",
        "modelAsString" : false
      }
    },
    "TweaksToObjective" : {
      "type" : "object",
      "properties" : {
        "avoidIntersections" : {
          "type" : "boolean",
          "description" : "If this parameter is set to true, the focus is to avoid intersections of edges, where an edge is a straight line drawn between two consecutive stops in a trip. The number of tours may be higher compared to the result when this parameter is set to false. If the calculation mode is set to avoid intersections, this must be set, otherwise an exception is thrown."
        },
        "minimizeNumberOfTours" : {
          "type" : "boolean",
          "description" : "If this parameter is set to true, the algorithm plans as many orders as possible using as few vehicles as possible, even though the costs, for example driving time or distance, of the whole plan might increase. If this parameter is set to false, the algorithm plans as many orders as possible so that the total cost is minimized. Therefore it is likely that the number of tours will be higher compared to the result when this parameter is set to false."
        }
      },
      "description" : "Describes special tweaks to the objective of the algorithm.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.TweaksToObjective"
    },
    "UTCOffset" : {
      "type" : "integer",
      "format" : "int32",
      "description" : "An offset to UTC in \\[min\\]. Range: -840 ??? value ??? 840.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.UTCOffset"
    },
    "UTCOffsetAmbigiousLimitation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResultLimitation"
      }, {
        "type" : "object",
        "required" : [ "utcOffset" ],
        "properties" : {
          "utcOffset" : {
            "description" : "The UTC offset finally used.",
            "$ref" : "#/definitions/UTCOffset"
          }
        },
        "description" : "This result limitation indicates that the time zone for a given time could not be determined unambiguously. In this case the time zone was determined as described in the technical concept, and the chosen time zone is given.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.service.UTCOffsetAmbigiousLimitation"
      } ],
      "x-discriminator-value" : "UTCOffsetAmbigiousLimitation",
      "x-ms-discriminator-value" : "UTCOffsetAmbigiousLimitation"
    },
    "UTCOffsetEvent" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RouteEvent"
      }, {
        "type" : "object",
        "properties" : {
          "utcOffset" : {
            "description" : "The UTC offset valid for the segments after this event. The UTC offset will contain daylight-saving time only if a time-consideration scenario with a reference time is given in the request.",
            "$ref" : "#/definitions/UTCOffset"
          }
        },
        "description" : "This event indicates that the offset to UTC changes at this point of the route. As this object contains only the new UTC offset, consider the previous UTCOffsetEvent to obtain the previous offset. To obtain the UTC offset for which the route starts, there is always an event for the start of the route.\r\n\r\nChanging the UTC offset does not necessarily mean to change the time zone. Vice-versa changing the time zone does not necessarily mean to change the UTC offset. There are some special cases to consider.\r\n\r\n *  The UTC offset may change even within a time zone when the route takes place exactly when the daylight-saving time changes.\r\n *  The UTC offset may not change when changing the time zone. In Canada, for example, there are regions which do not use DST so that the neighboring time zone has the same UTC offset in summer.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.UTCOffsetEvent"
      } ],
      "x-discriminator-value" : "UTCOffsetEvent",
      "x-ms-discriminator-value" : "UTCOffsetEvent"
    },
    "UTCOffsetNotDeterminableFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InvalidRequestFault"
      }, {
        "type" : "object",
        "description" : "This fault is thrown if the UTC offset for a request depending on some reference time could not be determined.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.UTCOffsetNotDeterminableFault"
      } ],
      "x-discriminator-value" : "UTCOffsetNotDeterminableFault",
      "x-ms-discriminator-value" : "UTCOffsetNotDeterminableFault"
    },
    "UTCOffsetNotDeterminableLimitation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResultLimitation"
      }, {
        "type" : "object",
        "description" : "This result limitation indicates that the time zone for the given reference time could not be determined. This usually happens when requesting a map in an area where no roads with attached time-zone information are present, e.g. in uninhabited areas or in the sea. Therefore, this result limitation can usually be ignored as there will be no time-dependent information available in this area. PTV xServer assumes UTC as the time zone for this request.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.service.UTCOffsetNotDeterminableLimitation"
      } ],
      "x-discriminator-value" : "UTCOffsetNotDeterminableLimitation",
      "x-ms-discriminator-value" : "UTCOffsetNotDeterminableLimitation"
    },
    "UnloadingStop" : {
      "type" : "object",
      "properties" : {
        "itemsToUnload" : {
          "type" : "array",
          "items" : {
            "description" : "Defines the list of items to unload.",
            "$ref" : "#/definitions/ItemsToUnload"
          }
        }
      },
      "description" : "Defines the list of items to be unloaded at this point.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xload.Stop"
    },
    "UnspecifiedMapDataLimitation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResultLimitation"
      }, {
        "type" : "object",
        "required" : [ "index", "path" ],
        "properties" : {
          "index" : {
            "description" : "Index of segment with wrong map data.",
            "$ref" : "#/definitions/Index"
          },
          "path" : {
            "type" : "string",
            "description" : "XPath-like identification of the field containing wrong data."
          }
        },
        "description" : "This result limitation indicates that during the calculation of the response map data was found that does not fulfill the internal specification. Such a case should be reported to the PTV xServer support.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.UnspecifiedMapDataLimitation"
      } ],
      "x-discriminator-value" : "UnspecifiedMapDataLimitation",
      "x-ms-discriminator-value" : "UnspecifiedMapDataLimitation"
    },
    "UpdateDistanceMatrixRequest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RequestBase"
      }, {
        "type" : "object",
        "required" : [ "id" ],
        "properties" : {
          "id" : {
            "type" : "string",
            "description" : "The ID of the distance matrix to be used."
          }
        },
        "description" : "The service method updateDistanceMatrix accommodates several use-cases. This abstract type for the requests is the common denominator.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xdima.UpdateDistanceMatrixRequest"
      } ],
      "x-discriminator-value" : "UpdateDistanceMatrixRequest",
      "x-ms-discriminator-value" : "UpdateDistanceMatrixRequest"
    },
    "Url" : {
      "type" : "string",
      "description" : "Relative or absolute url. Characters disallowed for urls must be encoded using the % notation. Example: `%20` represents a whitespace.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.Url"
    },
    "UserDefinedName" : {
      "type" : "string",
      "description" : "A user-defined name with restricted length of maximal 1000 characters. Pattern: .\\{0,1000\\}.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.UserDefinedName"
    },
    "Vehicle" : {
      "type" : "object",
      "properties" : {
        "ids" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "description" : "A list of unique IDs for the vehicle(s) of this type. The IDs can be used to reference a specific vehicle, for example in a response tour."
          }
        },
        "maximumQuantityScenarios" : {
          "type" : "array",
          "items" : {
            "description" : "An ordered list of scenarios for the maximum quantities of goods of different kind that this vehicle can transport. For example at most 5 pallets and 10 boxes, or 3 pallets and 20 boxes could be transported by a vehicle. Since the quantity may not be exceeded in any dimension, an order with 4 pallets and 11 boxes would not fit on the vehicle of the example. However, an order with 4 pallets and 10 boxes would fit. The length of this list has to be the same for all vehicles and for all maximum quantity scenarios of all transport orders. If and only if the list of quantities is empty for all transport orders, the list of maximum quantity scenarios of each vehicle must be empty. The order of the scenarios matters: if multiple quantity scenarios would lead to the same number of quantity scenario changes, the quantity scenarios farther in front of the vector are chosen.",
            "$ref" : "#/definitions/MaximumQuantityScenario"
          }
        },
        "quantityScenarioChangePosition" : {
          "description" : "Position in the tour where the currently chosen quantity scenario of a vehicle may be changed.",
          "$ref" : "#/definitions/QuantityScenarioChangePosition"
        },
        "distanceMatrixId" : {
          "type" : "string",
          "description" : "Distance matrix of this vehicle if distance mode ExistingDistanceMatrixPerVehicle is specified. Empty otherwise. If not, an exception is thrown. The distance matrix is specified by its ID, which can be retrieved in the distance matrix summary of the corresponding DistanceMatrixResponse. The ID is considered case sensitively. The distance matrix has to contain every location that is necessary for the tour planning, otherwise an exception is thrown."
        },
        "startLocationId" : {
          "type" : "string",
          "description" : "ID of the vehicle's start location. May be a vehicle location or a site. Opening intervals and service times are not considered for a vehicle's start location. If no start location is specified, it is assumed that the vehicle is available at the first stop."
        },
        "endLocationId" : {
          "type" : "string",
          "description" : "ID of the vehicle's end location. May be a vehicle location or a site. Opening intervals and service times are not considered for a vehicle's end location. If no end location is specified, it is assumed that the vehicle remains at the last stop."
        },
        "serviceTimeFactorForOrders" : {
          "description" : "A factor that is multiplied with the service times of all orders' tasks carried out by this vehicle, for example if loading/unloading is more or less complicated than for other vehicles. A factor less than one means that the vehicle speeds up the service, a factor greater than one means that it slows the service down. See Service time calculation.",
          "$ref" : "#/definitions/ServiceTimeFactor"
        },
        "serviceTimePerStop" : {
          "description" : "Vehicle dependent service time, for example for maneuvering. This service time will be considered for each stop served by this vehicle. Additionally there may be a site dependent or order dependent service time of the stop. See Service time calculation.",
          "$ref" : "#/definitions/Duration"
        },
        "equipment" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "description" : "List of vehicle equipment. An order can only be served by the vehicle if this list is a superset of (or equal to) the order's required vehicle equipment."
          }
        },
        "orderGroupIds" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "description" : "List of order group IDs. If a field of the order group consideration is set to true, an order should only be served by the vehicle if a) this vector is empty, or b) this vector contains the group ID of the order. The preferences that apply to orders with the same group ID are specified in the order group consideration. See technical concept Order Groups for further details."
          }
        },
        "tourStartInterval" : {
          "description" : "Interval in which the vehicle has to start its tour. Start and end of the interval may be the same. Leaving this parameter empty means that the tour start is unrestricted. The tour start interrupts a TourEvent of type BREAK or DAILY\\_REST.",
          "$ref" : "#/definitions/StartEndInterval"
        },
        "maximumNumberOfCustomerStops" : {
          "description" : "Restricts the maximum allowed total number of customer stops, i.e. stops at customer sites, within the tour of this vehicle. If this parameter is set, maximum number of customer stops at tour restrictions must not be set, otherwise an exception is thrown. If not given the maximum number of customer stops is unlimited.",
          "$ref" : "#/definitions/NonNegativeInteger"
        },
        "maximumDistance" : {
          "description" : "Restricts the maximum allowed total distance within the tour of this vehicle. If this parameter is set, maximum distance per tour at tour restrictions must not be set, otherwise an exception is thrown. If not given the maximum distance is unlimited. This restriction is ignored for ToursInExecutionRequests.",
          "type" : "number"
        },
        "maximumTravelTime" : {
          "description" : "Restricts the maximum allowed total travel time within the tour of this vehicle. The travel time contains all waiting, service and driving times. Drivers' working hours may be more restrictive and enforce a lower limit. If this parameter is set, maximum travel time per tour at tour restrictions must not be set, otherwise an exception is thrown. If not given the maximum travel time is unlimited. This restriction is ignored for ToursInExecutionRequests.",
          "$ref" : "#/definitions/Duration"
        },
        "maximumDrivingTime" : {
          "description" : "Restricts the maximum allowed total driving time within the tour of this vehicle. Drivers' working hours may be more restrictive and enforce a lower limit. If this parameter is set, maximum driving time per tour at tour restrictions must not be set, otherwise an exception is thrown. If not given the maximum driving time is unlimited. Not supported for time-dependent driving times. This restriction is ignored for ToursInExecutionRequests.",
          "$ref" : "#/definitions/Duration"
        },
        "ignoreMixedLoadingProhibitions" : {
          "type" : "boolean",
          "description" : "Indicates whether the mixed loading prohibitions are relevant for this vehicle. If set to false, the mixed loading prohibitions -- if there are any -- must be respected on every trip of the vehicle. If set to true, the mixed loading prohibitions are ignored by the vehicle."
        }
      },
      "description" : "A vehicle that is used to transport goods or perform visits. In transport use cases, vehicles are mostly trucks, for customer visits, also cars may be used. Several IDs can be specified to simplify the use of multiple vehicles that are of the same type.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.Vehicle"
    },
    "VehicleLocation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TourPlanningLocation"
      }, {
        "type" : "object",
        "description" : "A location representing a vehicle location. This location may be the start or end location of a vehicle in a tour.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.VehicleLocation"
      } ],
      "x-discriminator-value" : "VehicleLocation",
      "x-ms-discriminator-value" : "VehicleLocation"
    },
    "VehiclePosition" : {
      "type" : "object",
      "required" : [ "$type" ],
      "discriminator" : "$type",
      "properties" : {
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "Position of the driver and his vehicle in a tour in execution.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.VehiclePosition"
    },
    "VehicleProfile" : {
      "type" : "object",
      "properties" : {
        "engine" : {
          "description" : "Defines the engine parameters of the vehicle. These parameters are only relevant if the driveType is MOTOR\\_VEHICLE.",
          "$ref" : "#/definitions/Engine"
        },
        "weight" : {
          "description" : "Defines the weight parameters of the vehicle. The actual weight of the vehicle is the sum of the empty weight and the load weight.",
          "$ref" : "#/definitions/Weight"
        },
        "dimensions" : {
          "description" : "Defines the size parameters of the vehicle, e.g. height, length, etc.",
          "$ref" : "#/definitions/Dimensions"
        },
        "axle" : {
          "description" : "Defines the number of axles of the vehicle and the axle load.",
          "$ref" : "#/definitions/Axle"
        },
        "legalCondition" : {
          "description" : "Defines a legal condition of the vehicle, e.g. whether the vehicle is delivering goods or is an emergency vehicle.",
          "$ref" : "#/definitions/LegalCondition"
        },
        "load" : {
          "description" : "Defines the current load of the vehicle",
          "$ref" : "#/definitions/Load"
        },
        "speeds" : {
          "description" : "Defines the speed values used by the routing algorithm to calculate the travel time of a road segment. All speed values given here are internally rounded to km/h.",
          "$ref" : "#/definitions/Speeds"
        },
        "driveType" : {
          "description" : "The type of the vehicle, e.g. motorized, pedestrian, etc. (1,2,3,4)",
          "$ref" : "#/definitions/DriveType"
        },
        "yearOfManufacture" : {
          "description" : "The vehicle's construction year. (3)",
          "$ref" : "#/definitions/PositiveInteger"
        },
        "numberOfPassengers" : {
          "description" : "The actual number of passengers including the driver. (2)",
          "$ref" : "#/definitions/PositiveInteger"
        },
        "numberOfTrailers" : {
          "description" : "The number of trailers. (2,3,4)",
          "$ref" : "#/definitions/NonNegativeInteger"
        },
        "preferredRouteTypes" : {
          "description" : "The road networks to be preferred by the routing algorithm as a comma-separated list (only if the feature layer PTV\\_PreferredRoutes is enabled). The available types can be requested through the xRuntime service and are documented in the manual as layer-specific properties of the feature layer PTV\\_PreferredRoutes. (5)",
          "$ref" : "#/definitions/CommaSeparatedList"
        },
        "unrestrictedRouteTypes" : {
          "description" : "The road networks without restrictions as a comma-separated list (only if the feature layer PTV\\_PreferredRoutes is enabled). The available types can be requested through the xRuntime service and are documented in the manual as layer-specific properties of the feature layer PTV\\_PreferredRoutes. (5)",
          "$ref" : "#/definitions/CommaSeparatedList"
        },
        "restrictedRouteTypes" : {
          "description" : "The road networks that should be avoided as far as possible, e.g. for convenience reasons, as a comma-separated list (only if the feature layer PTV\\_PreferredRoutes is enabled). The available types can be requested through the xRuntime service and are documented in the manual as layer-specific properties of the feature layer PTV\\_PreferredRoutes. (5)",
          "$ref" : "#/definitions/CommaSeparatedList"
        },
        "highlyRestrictedRouteTypes" : {
          "description" : "The road networks that must be avoided, e.g. due to legal limitations, as a comma-separated list (only if the feature layer PTV\\_PreferredRoutes is enabled). The available types can be requested through the xRuntime service and are documented in the manual as layer-specific properties of the feature layer PTV\\_PreferredRoutes. (5)",
          "$ref" : "#/definitions/CommaSeparatedList"
        },
        "prohibitedRouteTypes" : {
          "description" : "The road networks that are prohibited for the vehicle as a comma-separated list (only if the feature layer PTV\\_PreferredRoutes is enabled). The available types can be requested through the xRuntime service and are documented in the manual as layer-specific properties of the feature layer PTV\\_PreferredRoutes. (5)",
          "$ref" : "#/definitions/CommaSeparatedList"
        },
        "electronicTollCollectionSubscriptions" : {
          "description" : "The subscriptions for electronic toll collection systems the vehicle can use as a comma-separated list (only if toll is enabled). The available types can be requested through the xRuntime service and are returned in xruntime.TollFeatures.electronicTollCollectionSubscriptions for the map and in xruntime.TollFeatures.electronicTollCollectionSubscriptions for a country or subdivision. (2)",
          "$ref" : "#/definitions/CommaSeparatedList"
        }
      },
      "description" : "Defines the vehicle to be used which activates rules of different algorithms. Please note that all values apply to the complete vehicle including trailers. Note that the results may be incorrect because the legal definition of a vehicle type may differ from country to country and it may also differ from the technical definition. As an example, a truck with a weight of 7.5 tons is a truck by legal definition in Germany but is not a truck by definition of toll. Most parameters are used for several use cases. They are denoted with (1) for routing, (2) for toll, (3) for emission calculation, (4) for truck attributes, and (5) for preferred routes. Give as many details on the vehicle as possible in order to obtain the best result.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.vehicleprofile.VehicleProfile"
    },
    "VehiclesForTripsQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ChangeToursProposalsQuery"
      }, {
        "type" : "object",
        "properties" : {
          "tripIds" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "description" : "ID of the trips to be moved. At the moment, only one trip is supported."
            }
          },
          "targetVehicleIds" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "description" : "Option to restrict target vehicles. If empty, all vehicles of the plan are considered as target vehicles except the current vehicle of the trip. If the current vehicle ID of the trip is part of the targetVehicleIds, it will be ignored."
            }
          }
        },
        "description" : "A query to propose other vehicles for a trip, that means moving a trip to a specified position in an existing tour or to an empty vehicle. Only structurally valid positions are proposed, for details please have a look at tour structures. If violated insertion positions shall be part of the proposals, set returnViolatedTours to true. The source tour of the trip to be moved (if not empty after the move) plus the resulting tour are contained in the TourReports.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.VehiclesForTripsQuery"
      } ],
      "x-discriminator-value" : "VehiclesForTripsQuery",
      "x-ms-discriminator-value" : "VehiclesForTripsQuery"
    },
    "VersionInformation" : {
      "type" : "object",
      "required" : [ "apiVersion", "buildNumber", "releaseVersion" ],
      "properties" : {
        "releaseVersion" : {
          "type" : "string",
          "description" : "The release version."
        },
        "buildNumber" : {
          "type" : "string",
          "description" : "The build number."
        },
        "apiVersion" : {
          "type" : "string",
          "description" : "The API version."
        }
      },
      "description" : "Information about the server's versions.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xruntime.VersionInformation"
    },
    "ViolatedFeature" : {
      "type" : "object",
      "required" : [ "themeId" ],
      "properties" : {
        "themeId" : {
          "description" : "The ID of the Feature Layer theme to which this feature belongs to.",
          "$ref" : "#/definitions/ThemeId"
        },
        "attributes" : {
          "type" : "array",
          "items" : {
            "description" : "The list of attributes of a segment. For each attribute its type (key) and value is provided via key-value pairs. See the documentation of the layer-specific attributes for more information on the type and the range of available attributes.",
            "$ref" : "#/definitions/KeyValuePair"
          }
        }
      },
      "description" : "Contains the features of a Feature Layer theme valid for the segment in question.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.ViolatedFeature"
    },
    "ViolationReport" : {
      "type" : "object",
      "required" : [ "$type" ],
      "discriminator" : "$type",
      "properties" : {
        "maximumOpeningIntervalExceedance" : {
          "description" : "The longest opening interval exceedance. Corresponds to tour events with violation type OPENING\\_INTERVAL.",
          "$ref" : "#/definitions/Duration"
        },
        "maximumQuantityScenarioExceedance" : {
          "type" : "array",
          "items" : {
            "description" : "The highest maximum quantity scenario exceedance. This always refers to the first maximum quantity scenario of the vehicle. Corresponds to tour events with violation type MAXIMUM\\_QUANTITY\\_SCENARIO.",
            "$ref" : "#/definitions/TransportQuantityUnit"
          }
        },
        "vehicleEquipmentViolations" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "description" : "Contains all required vehicle equipment violations. Corresponds to tour events with violation type VEHICLE\\_EQUIPMENT."
          }
        },
        "restPositionViolated" : {
          "type" : "boolean",
          "description" : "Indicates if any daily rest is scheduled at an unexpected position according to possible rest positions that can for example be defined by multi day drivers' working hours."
        },
        "customerStopPositionInTripViolated" : {
          "type" : "boolean",
          "description" : "Indicates if any service is scheduled at an unexpected position according to the position in trip. Corresponds to tour events with violation type CUSTOMER\\_STOP\\_POSITION\\_IN\\_TRIP."
        },
        "tripSectionViolated" : {
          "type" : "boolean",
          "description" : "Indicates if any service is scheduled at an unexpected position according to the trip section number. Corresponds to tour events with violation type TRIP\\_SECTION."
        },
        "mixedLoadingProhibitionsViolations" : {
          "type" : "array",
          "items" : {
            "description" : "Contains all mixed loading prohibitions violations. Corresponds to tour events with violation type MIXED\\_LOADING\\_PROHIBITION.",
            "$ref" : "#/definitions/MixedLoadingProhibition"
          }
        },
        "routeViolated" : {
          "type" : "boolean",
          "description" : "Indicates if at least one of the routes between two locations is violated. This violation does not occur if ignore route violations is set to true. Corresponds to tour events with violation type ROUTE."
        },
        "reachabilityViolated" : {
          "type" : "boolean",
          "description" : "Indicates if at least one of the routes between two locations was calculated by direct distance instead of the road network. This violation does not occur if ignore reachability violations is set to false and if distance mode is not set to direct distance. Corresponds to tour events with violation type REACHABILITY."
        },
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "Violation related information describing tours or trips. The violation report contains violation summaries of its parent object, which is either a tour report or a trip report.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.ViolationReport"
    },
    "Violations" : {
      "type" : "object",
      "properties" : {
        "enabled" : {
          "type" : "boolean",
          "description" : "Enables violations of road blocks."
        },
        "cost" : {
          "description" : "Deprecated: This value will ignored, it is sufficient to enable violations. If this parameter is set to a value different from the default of 50000, a service.DeprecatedParameterLimitation is returned with the response.",
          "$ref" : "#/definitions/MathematicalCost"
        }
      },
      "description" : "Defines the parameters that control whether road restrictions can be violated. See the technical concept for details.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.routingprofile.Violations"
    },
    "Visit" : {
      "type" : "object",
      "required" : [ "orderId", "serviceTime", "visitDate", "visitNumber" ],
      "properties" : {
        "visitDate" : {
          "type" : "string",
          "format" : "date",
          "description" : "The date of the visit."
        },
        "serviceTime" : {
          "description" : "Service time for this visit.",
          "$ref" : "#/definitions/Duration"
        },
        "orderId" : {
          "type" : "string",
          "description" : "The unique identifier of the order associated with this visit."
        },
        "visitNumber" : {
          "description" : "The visit number (of the total visits) of the order with orderId.",
          "$ref" : "#/definitions/NonNegativeInteger"
        },
        "travelTimeToVisit" : {
          "description" : "Time taken to travel from the previous visit of the day this this one. For the first visit of the day this is the travel time from the field worker location. This value is only set if determineShortestVisitSequencePerDay is enabled.",
          "$ref" : "#/definitions/Duration"
        }
      },
      "description" : "Represents a visit of a visit day.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.Visit"
    },
    "VisitDay" : {
      "type" : "object",
      "properties" : {
        "visitDate" : {
          "type" : "string",
          "format" : "date",
          "description" : "Date of the day"
        },
        "startIndex" : {
          "description" : "Index of the first visit of the day in the accumulated list of visits. If startIndex equals endIndex the day has no visits.",
          "$ref" : "#/definitions/Index"
        },
        "endIndex" : {
          "description" : "Index after the last visit of the day in the accumulated list of visits. If startIndex equals endIndex the day has no visits.",
          "$ref" : "#/definitions/Index"
        },
        "travelTime" : {
          "description" : "If determineShortestVisitSequencePerDay is true, this is set to the total travel time for that day. Otherwise it is not set.",
          "$ref" : "#/definitions/Duration"
        },
        "serviceTime" : {
          "description" : "Total service time for that day.",
          "$ref" : "#/definitions/Duration"
        },
        "travelTimeAfterLastVisit" : {
          "description" : "Travel time from the last visit of the day to the field worker location, if no overnight stay occurs on this day. In case of an overnight stay, it is the travel time from the last visit of the day to the first visit of the next day. This value is only set if determineShortestVisitSequencePerDay is enabled.",
          "$ref" : "#/definitions/Duration"
        },
        "overnightStay" : {
          "type" : "boolean",
          "description" : "True if an overnight stay occured on this day. The overnight location always matches the location of the last visit of the day."
        },
        "hotelId" : {
          "type" : "string",
          "description" : "Set only when overnightStayOptions and workLoadOptions are active. If hotels are given, it is one of the hotel-ids. If hotels are not given, it is one of the ids of orders."
        }
      },
      "description" : "Represents a visit day of a VisitWeek. If determineShortestVisitSequencePerDay is true, the sequence of visits is optimal. Otherwise, visits are sorted by visit day but the sequence of visits within a visit day has no special meaning.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.VisitDay"
    },
    "VisitLocation" : {
      "type" : "object",
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "ID of a location given in OptimizeVisitSequenceRequest.locations."
        }
      },
      "description" : "Represents a visited location.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.VisitLocation"
    },
    "VisitOrder" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Order"
      }, {
        "type" : "object",
        "required" : [ "locationId" ],
        "properties" : {
          "locationId" : {
            "type" : "string",
            "description" : "ID of the location of the customer to be visited. This location has to be a customer site."
          },
          "serviceTime" : {
            "description" : "Overall service time at the site required for the visit. Additionally there may be a site dependent or vehicle dependent service time of the stop. See Service time calculation.",
            "$ref" : "#/definitions/Duration"
          }
        },
        "description" : "Order to visit a customer without transporting any goods.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xtour.VisitOrder"
      } ],
      "x-discriminator-value" : "VisitOrder",
      "x-ms-discriminator-value" : "VisitOrder"
    },
    "VisitPatternOptions" : {
      "type" : "object",
      "properties" : {
        "visitPatterns" : {
          "type" : "array",
          "items" : {
            "description" : "Defines the possible visit patterns for the order. If this list is empty, all possible visit patterns with VisitOrder.numberOfVisitsPerWeek are created by the algorithm.",
            "$ref" : "#/definitions/Week"
          }
        },
        "flexibleChoiceOfVisitPatterns" : {
          "type" : "boolean",
          "description" : "Defines if an arbitrary visit pattern can be chosen for each week. If this parameter is set to true, the maximumNumberOfVisitPatternDeviations is ignored."
        },
        "maximumNumberOfVisitPatternDeviations" : {
          "description" : "Defines the maximum number of weeks in which a deviation from the regular visit pattern is allowed. The upper bound for this parameter is set to half of the number of feasible visit weeks. If flexibleChoiceOfVisitPatterns is set to true, this parameter is ignored.",
          "$ref" : "#/definitions/NonNegativeInteger"
        },
        "forbiddenVisitDays" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date",
            "description" : "Defines forbidden visit days for an order, e.g. holidays."
          }
        },
        "firstVisitDay" : {
          "type" : "string",
          "format" : "date",
          "description" : "Fixes the first visit day for an order."
        }
      },
      "description" : "Represents visit pattern options for an order of the visit planning use case.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.VisitPatternOptions"
    },
    "VisitPlanning" : {
      "type" : "object",
      "properties" : {
        "overnightStay" : {
          "description" : "Contains parameter values for use cases in which the visit plan is calculated with overnight stays.",
          "$ref" : "#/definitions/OvernightStay"
        },
        "workloadBalancing" : {
          "description" : "Contains parameter values for use cases in which the daily workload in a visit plan needs to be balanced.",
          "$ref" : "#/definitions/WorkloadBalancing"
        },
        "workload" : {
          "description" : "Contains parameter values for use cases in which the daily and/or weekly workload is specified.",
          "$ref" : "#/definitions/Workload"
        },
        "compactnessLevel" : {
          "description" : "Defines the exponent with which the distances are incorporated in the model. Note that value of at most two is allowed when workload options are used.",
          "$ref" : "#/definitions/CompactnessLevel"
        },
        "dailyDistanceWeight" : {
          "description" : "Defines the importance of daily cluster compactness. If the daily cluster compactness should be more important than the weekly cluster compactness, set this value higher than the weeklyDistanceWeight.",
          "$ref" : "#/definitions/DailyDistanceWeight"
        },
        "weeklyDistanceWeight" : {
          "description" : "Defines the importance of weekly cluster compactness. If the weekly cluster compactness should be more important than the daily cluster compactness, set this value higher than the dailyDistanceWeight.",
          "$ref" : "#/definitions/WeeklyDistanceWeight"
        },
        "approximationTolerance" : {
          "description" : "Defines (in percent) how close to the optimal solution value the solver should come before exiting an iteration. For instance, compared to 10% the value of 5% means better solution at the cost of higher running time.",
          "$ref" : "#/definitions/ApproximationTolerance"
        },
        "performPreprocessingStep" : {
          "type" : "boolean",
          "description" : "Perform preprocessing to reduce the complexity of the optimization problem. For example by excluding forbidden or redundant combinations. For large problems the preprocessing itself can be very time-consuming."
        },
        "maximumNumberOfIterations" : {
          "description" : "The maximum number of iterations the solver may use to provide a solution.",
          "$ref" : "#/definitions/PositiveInteger"
        },
        "minimumRelativeImprovement" : {
          "description" : "The minimum relative solution value improvement (in percent) between iterations. If the relative improvement is less than the given value, no further iterations will be performed.",
          "$ref" : "#/definitions/MinimumRelativeImprovement"
        }
      },
      "description" : "Contains parameter values for the visit planning use cases.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.clusterplanningprofile.VisitPlanning"
    },
    "VisitPlanningOrder" : {
      "type" : "object",
      "required" : [ "id", "locationId", "numberOfVisitsPerWeek", "visitRhythmInWeeks" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "The unique identifier of this order."
        },
        "locationId" : {
          "type" : "string",
          "description" : "The unique identifier of the customer location that should be visited in this order."
        },
        "visitRhythmInWeeks" : {
          "description" : "Defines the visit rhythm of the order, i.e. the number of weeks in which the order needs to be handled (again). For example, a visitRhythmInWeeks of 2 means that the customer has to be visited every 2 weeks.",
          "$ref" : "#/definitions/PositiveInteger"
        },
        "numberOfVisitsPerWeek" : {
          "description" : "Defines the number of visits per week for this order. This parameter needs to be between one and the number of workDays per week.",
          "$ref" : "#/definitions/PositiveInteger"
        },
        "visitPatternOptions" : {
          "description" : "Defines the visit pattern options for the order.",
          "$ref" : "#/definitions/VisitPatternOptions"
        },
        "weekOfPossibleFirstVisit" : {
          "description" : "The calendar week where the first visit for this order could happen. If the parameter is omitted, the first week of the planningPeriod is assumed to be the first possible week for this visit. If the visitRhythmInWeeks is more than 1, the first visit may take place in some of the following weeks, according to the rhythm.",
          "$ref" : "#/definitions/PositiveInteger"
        },
        "weekOfPossibleLastVisit" : {
          "description" : "The week, relative to the planning period, where the last visit for this order may happen. If this parameter is omitted, visits are possible during the whole planning period.",
          "$ref" : "#/definitions/PositiveInteger"
        },
        "serviceTimes" : {
          "type" : "array",
          "items" : {
            "description" : "Defines the service time for each visit. A service time has to be specified for each visit per week.",
            "$ref" : "#/definitions/Duration"
          }
        },
        "score" : {
          "description" : "Defines the importance of the visit order if not all visits of the corresponding PlanVisitsRequest can be planned because of tight workload restrictions defined in WorkloadOptions. The higher the score, the higher is the probability that visits of the visit order will be planned. If skipping visits is not allowed (see allowSkippingVisits), either all visits of the visit order are planned or none. The score is only relevant if WorkloadOptions are defined. The score must not exceed 100,000, otherwise an exception will be thrown.",
          "$ref" : "#/definitions/PositiveInteger"
        }
      },
      "description" : "Represents an order for the visit planning use case.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.VisitOrder"
    },
    "VisitSequenceOptimizationGoal" : {
      "type" : "string",
      "description" : "Selection of possible optimization goals in a sequencing operation.  \n * `MINIMUM_TRAVEL_TIME` - Optimize for minimum travel time (VisitSequenceResponse.travelTime)  \n * `MINIMUM_DISTANCE` - Optimize for minimum traveled distance (VisitSequenceResponse.distance)\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.xcluster.VisitSequenceOptimizationGoal",
      "enum" : [ "MINIMUM_TRAVEL_TIME", "MINIMUM_DISTANCE" ],
      "x-ms-enum" : {
        "name" : "VisitSequenceOptimizationGoal",
        "modelAsString" : false
      }
    },
    "VisitSequenceResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "properties" : {
          "sequence" : {
            "type" : "array",
            "items" : {
              "description" : "Sequence in which the given locations are visited.",
              "$ref" : "#/definitions/VisitLocation"
            }
          },
          "distance" : {
            "description" : "Total distance traveled from start to end.",
            "type" : "number"
          },
          "travelTime" : {
            "description" : "Total estimated travel time from start to end.",
            "$ref" : "#/definitions/Duration"
          }
        },
        "description" : "Solution to a visit sequencing problem.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.VisitSequenceResponse"
      } ],
      "x-discriminator-value" : "VisitSequenceResponse",
      "x-ms-discriminator-value" : "VisitSequenceResponse"
    },
    "VisitSequencing" : {
      "type" : "object",
      "properties" : {
        "approximationTolerance" : {
          "description" : "Defines (in percent) how close to the optimal solution value the solver should come before exiting an iteration. For instance, compared to 10% the value of 5% means better solution at the cost of higher running time.",
          "$ref" : "#/definitions/ApproximationTolerance"
        },
        "performPreprocessingStep" : {
          "type" : "boolean",
          "description" : "Perform preprocessing to reduce the complexity of the optimization problem. For example by excluding forbidden or redundant combinations. For large problems the preprocessing itself can be very time-consuming."
        }
      },
      "description" : "Contains parameter values for simple visit sequencing use cases.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.clusterplanningprofile.VisitSequencing"
    },
    "VisitWeek" : {
      "type" : "object",
      "properties" : {
        "visitDays" : {
          "type" : "array",
          "items" : {
            "description" : "Contains one day description element for each working day of the working week. The n'th working day of the week is described by the n'th list element starting at zero.",
            "$ref" : "#/definitions/VisitDay"
          }
        },
        "visitOrderIdsSkipped" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "description" : "Lists the ids of partially planned visit orders that should be visited at least once this week according to visitRhythmInWeeks but are skipped this week because of tight workload restrictions defined in workloadOptions. Will be empty if WorkloadOptions are not set or if allowSkippingVisits is set to false. If a visit order is not planned at all, you can find its id in visitOrderIdsNotPlanned."
          }
        },
        "travelTime" : {
          "description" : "If determineShortestVisitSequencePerDay is true, this is set to the total travel time for this week. Otherwise, it is not set.",
          "$ref" : "#/definitions/Duration"
        },
        "serviceTime" : {
          "description" : "Total service time for that week.",
          "$ref" : "#/definitions/Duration"
        }
      },
      "description" : "Represents a visit week. If determineShortestVisitSequencePerDay is true, the sequence of visits is optimal. Otherwise, visits are sorted by visit day but the sequence of visits within a visit day has no special meaning.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.VisitWeek"
    },
    "VisitsResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "properties" : {
          "visits" : {
            "type" : "array",
            "items" : {
              "description" : "List of all visits of the field worker ordered by visit date. To see which visits belong to a certain visit day, see startIndex and endIndex. If determineShortestVisitSequencePerDay is set to true, visits on the same day will be ordered to achieve the shortest tour for the day.",
              "$ref" : "#/definitions/Visit"
            }
          },
          "visitWeeks" : {
            "type" : "array",
            "items" : {
              "description" : "List with a description object for each week of the planning period.",
              "$ref" : "#/definitions/VisitWeek"
            }
          },
          "visitOrderIdsNotPlanned" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "description" : "Lists the ids of visit orders that could not be planned because of tight workload restrictions defined in workloadOptions. This list only contains visit order ids that are not planned at all. Partially planned visit orders are listed in visitOrderIdsSkipped for all skipped visit weeks."
            }
          }
        },
        "description" : "Represents the result of a visit planning operation.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.VisitsResponse"
      } ],
      "x-discriminator-value" : "VisitsResponse",
      "x-ms-discriminator-value" : "VisitsResponse"
    },
    "VoidResponse" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResponseBase"
      }, {
        "type" : "object",
        "description" : "Empty response type for calls that do not return any meaningful data.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.service.VoidResponse"
      } ],
      "x-discriminator-value" : "VoidResponse",
      "x-ms-discriminator-value" : "VoidResponse"
    },
    "Volume" : {
      "type" : "number",
      "format" : "double",
      "description" : "Volume in \\[m??\\]. Range: 0.0 ??? value.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.Volume"
    },
    "WatchRequest" : {
      "type" : "object",
      "required" : [ "id" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "The job's ID."
        },
        "progressUpdatePeriod" : {
          "description" : "As long as the job is running watchJob will not return before this progressUpdatePeriod has elapsed. It will return immediately if the job terminates during that period. Use this parameter to control the frequency of progress updates or to ignore them for the given period. The range is limited to 250ms minimum and 50000ms maximum. Values less than 250ms will be set to 250ms and values greater than 50000ms will be set to 50000ms.",
          "$ref" : "#/definitions/Milliseconds"
        },
        "maximumPollingPeriod" : {
          "description" : "Specifies the maximum period after which watchJob will report the last status even if no further progress updates are available. This applies only to running jobs and if the respective service does not provide progress updates at all or at least not for a longer period.",
          "$ref" : "#/definitions/Milliseconds"
        }
      },
      "description" : "This type contains parameters to watch the progress of a job using watchJob. If the job is already finished, watchJob will return immediately. As long as the job is still running watchJob will return only after the next available progress update. See the technical concept for details.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.jobs.WatchRequest"
    },
    "Waypoint" : {
      "type" : "object",
      "required" : [ "country", "linkDistance", "linkTravelTime", "linkedCoordinate", "referenceCoordinate" ],
      "properties" : {
        "name" : {
          "type" : "string",
          "description" : "The name of the corresponding input waypoint. This user-defined name is available only if InputWaypoint.name for the corresponding input waypoint is set."
        },
        "country" : {
          "description" : "Country the waypoint is located in. This value is determined based on the Waypoint.linkedCoordinate. Note that for this reason rare situations can occur close to borders where the Waypoint.referenceCoordinate for the waypoint is not in the same country.",
          "$ref" : "#/definitions/CountryCode"
        },
        "linkedCoordinate" : {
          "description" : "The coordinate where input location was linked to the road network. This location is always on the route.",
          "$ref" : "#/definitions/Coordinate"
        },
        "referenceCoordinate" : {
          "description" : "The location of the waypoint on the route. For an OffRoadWaypoint this is the input location, for an OnRoadWaypoint this is the linked location. Use this location to mark the waypoint on the map.",
          "$ref" : "#/definitions/Coordinate"
        },
        "linkDistance" : {
          "description" : "Distance as the crow flies from the input coordinate to the linked coordinate.",
          "type" : "number"
        },
        "linkTravelTime" : {
          "description" : "Assumed travel time it takes to get from the input coordinate to the linked coordinate. The speed can be configured by vehicleprofile.Speeds.speedForLinkDistance.",
          "$ref" : "#/definitions/Duration"
        },
        "nodeIndex" : {
          "description" : "The index in the list of RouteResponse.nodes of the corresponding node. It is available only if the list of nodes is requested by ResultFields.nodes.",
          "$ref" : "#/definitions/Index"
        }
      },
      "description" : "A waypoint defines the start or destination of a route or a route leg. Every waypoint corresponds to an InputWaypoint, but not every input waypoint corresponds to a waypoint in the route. It is guaranteed that the waypoint of index *n* starts the leg of index *n*. That means that the number of waypoints equals the number of legs plus 1.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.Waypoint"
    },
    "WaypointEvent" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RouteEvent"
      }, {
        "type" : "object",
        "properties" : {
          "waypointIndex" : {
            "description" : "The index of the waypoint in the RouteResponse.waypoints list. This field is only present if the list of waypoints is present.",
            "$ref" : "#/definitions/Index"
          },
          "waypointName" : {
            "type" : "string",
            "description" : "The name of the waypoint as given in the corresponding InputWaypoint. This field is only present if its is not empty. This is useful to identify input waypoints when the waypoints list is not available in the response."
          }
        },
        "description" : "This event provides information on a Waypoint reached by the route. Note that there is no waypoint event for ManipulateRouteWaypoint and CombinedTransportViaWaypoint as they are only used to control the route.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.WaypointEvent"
      } ],
      "x-discriminator-value" : "WaypointEvent",
      "x-ms-discriminator-value" : "WaypointEvent"
    },
    "WaypointNotLinkableFault" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ProcessingFault"
      }, {
        "type" : "object",
        "properties" : {
          "waypointIndices" : {
            "type" : "array",
            "items" : {
              "description" : "The list of indices of waypoints that could not be linked. The indices refer to the array of waypoints in the request.",
              "$ref" : "#/definitions/Index"
            }
          }
        },
        "description" : "This fault is thrown if some routing waypoints could not be linked to the road network.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.WaypointNotLinkableFault"
      } ],
      "x-discriminator-value" : "WaypointNotLinkableFault",
      "x-ms-discriminator-value" : "WaypointNotLinkableFault"
    },
    "WaypointNotLinkedLimitation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/ResultLimitation"
      }, {
        "type" : "object",
        "properties" : {
          "parameter" : {
            "type" : "string",
            "description" : "Parameter which influences the linking behaviour in this case."
          },
          "waypointIndices" : {
            "type" : "array",
            "items" : {
              "description" : "The indices of the input waypoints which are affected.",
              "$ref" : "#/definitions/Index"
            }
          }
        },
        "description" : "This result limitation indicates that at least one input waypoint could not be linked to the road network in the expected way.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xroute.WaypointNotLinkedLimitation"
      } ],
      "x-discriminator-value" : "WaypointNotLinkedLimitation",
      "x-ms-discriminator-value" : "WaypointNotLinkedLimitation"
    },
    "Week" : {
      "type" : "object",
      "properties" : {
        "monday" : {
          "type" : "boolean",
          "description" : "Defines if the monday is part of the work week or visit pattern."
        },
        "tuesday" : {
          "type" : "boolean",
          "description" : "Defines if the tuesday is part of the work week or visit pattern."
        },
        "wednesday" : {
          "type" : "boolean",
          "description" : "Defines if the wednesday is part of the work week or visit pattern."
        },
        "thursday" : {
          "type" : "boolean",
          "description" : "Defines if the thursday is part of the work week or visit pattern."
        },
        "friday" : {
          "type" : "boolean",
          "description" : "Defines if the friday is part of the work week or visit pattern."
        },
        "saturday" : {
          "type" : "boolean",
          "description" : "Defines if the saturday is part of the work week or visit pattern."
        },
        "sunday" : {
          "type" : "boolean",
          "description" : "Defines if the sunday is part of the work week or visit pattern."
        }
      },
      "description" : "Represents a work week of the PlanVisitsRequest or a visit pattern.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.Week"
    },
    "WeeklyDistanceWeight" : {
      "type" : "integer",
      "format" : "int32",
      "description" : "Valid values - Range: 1 ??? value ??? 100.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.WeeklyDistanceWeight"
    },
    "WeeklyOnDutyHoursLimit_US_FMCSA_395_2013" : {
      "type" : "string",
      "description" : "Defines the possible weekly on duty limit for the US Hours Of Service regulation FMCSA 395/2013.  \n * `SEVEN_DAYS_SIXTY_HOURS_ON_DUTY` - Defines a limit of 60 on duty hours on a rolling period of 7 consecutive days.  \n * `EIGHT_DAYS_SEVENTY_HOURS_ON_DUTY` - Defines a limit of 70 on duty hours on a rolling period of 8 consecutive days.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.tourplanning.WeeklyOnDutyHoursLimit\\_US\\_FMCSA\\_395\\_2013",
      "enum" : [ "SEVEN_DAYS_SIXTY_HOURS_ON_DUTY", "EIGHT_DAYS_SEVENTY_HOURS_ON_DUTY" ],
      "x-ms-enum" : {
        "name" : "WeeklyOnDutyHoursLimit_US_FMCSA_395_2013",
        "modelAsString" : false
      }
    },
    "WeeklyOnDutyHoursLimit_US_FMCSA_395_2020" : {
      "type" : "string",
      "description" : "Defines the possible weekly on duty limit for the US Hours Of Service regulation FMCSA 395/2020.  \n * `SEVEN_DAYS_SIXTY_HOURS_ON_DUTY` - Defines a limit of 60 on duty hours on a rolling period of 7 consecutive days.  \n * `EIGHT_DAYS_SEVENTY_HOURS_ON_DUTY` - Defines a limit of 70 on duty hours on a rolling period of 8 consecutive days.\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.tourplanning.WeeklyOnDutyHoursLimit\\_US\\_FMCSA\\_395\\_2020",
      "enum" : [ "SEVEN_DAYS_SIXTY_HOURS_ON_DUTY", "EIGHT_DAYS_SEVENTY_HOURS_ON_DUTY" ],
      "x-ms-enum" : {
        "name" : "WeeklyOnDutyHoursLimit_US_FMCSA_395_2020",
        "modelAsString" : false
      }
    },
    "Weight" : {
      "type" : "object",
      "properties" : {
        "emptyWeight" : {
          "description" : "The empty weight. (3,4)",
          "$ref" : "#/definitions/Kilograms"
        },
        "loadWeight" : {
          "description" : "The weight of the vehicle's load. Note that emptyWeight + loadWeight <= totalPermittedWeight, otherwise a service.ParameterInconsistencyLimitation is returned with the response. (3,4)",
          "$ref" : "#/definitions/Kilograms"
        },
        "totalPermittedWeight" : {
          "description" : "The total permitted weight. (1,2,3,4)",
          "$ref" : "#/definitions/Kilograms"
        }
      },
      "description" : "Defines the weight parameters of the vehicle. The actual weight of the vehicle is the sum of the empty weight and the load weight.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.vehicleprofile.Weight"
    },
    "WorkLogbookSummary" : {
      "type" : "object",
      "required" : [ "lastTimeTheDriverWorked" ],
      "properties" : {
        "lastTimeTheDriverWorked" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "The last time the driver worked (driving or performing service). It is assumed that the time since then may count as break/rest, provided it has the required minimum duration. It is sometimes referred to as \"reference time\"."
        },
        "drivingTimeRegulationLogbookSummary" : {
          "description" : "The summary of a logbook corresponding to the drivingTimeRegulation.",
          "$ref" : "#/definitions/DrivingTimeRegulationLogbookSummary"
        },
        "workingTimeDirectiveLogbookSummary" : {
          "description" : "The summary of a logbook corresponding to the workingTimeDirective.",
          "$ref" : "#/definitions/WorkingTimeDirectiveLogbookSummary"
        }
      },
      "description" : "The summary of a logbook of a driver (or a mobile worker) with respect to a lastTimeTheDriverWorked. If provided as input, it is taken into account when the mandatory breaks and rests are calculated.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.tourplanning.WorkLogbookSummary"
    },
    "WorkingHours" : {
      "type" : "object",
      "required" : [ "$type" ],
      "discriminator" : "$type",
      "properties" : {
        "drivingTimeRegulation" : {
          "description" : "Defines which driving time regulation is applicable. A driving time regulation concerns drivers of heavy vehicles only.",
          "$ref" : "#/definitions/DrivingTimeRegulation"
        },
        "workingTimeDirective" : {
          "description" : "Defines which legislation regarding working time is applicable. Currently only supported for SingleDayWorkingHours. Must not be used together with drivingTimeRegulation.",
          "$ref" : "#/definitions/WorkingTimeDirective"
        },
        "drivingTimeRegulationOptions" : {
          "description" : "Defines options for the selected driving time regulation. Currently only supported in xRoute service.",
          "$ref" : "#/definitions/DrivingTimeRegulationOptions"
        },
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "Defines which rules regarding drivers' working hours need to be complied with. See Working Hours.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.tourplanning.WorkingHours"
    },
    "WorkingTimeDirective" : {
      "type" : "string",
      "description" : "Defines which legislation regarding working time is applicable.  \n * `NONE` - No restriction by working law.  \n * `EU_2002_15_EC` - Enables directive 2002/15/EC of the European Parliament and of the Council \"on the organisation of the working time of persons performing mobile road transport activities\".\n\nHint: Corresponding enum in xServer API documentation - com.ptvgroup.xserver.tourplanning.WorkingTimeDirective",
      "enum" : [ "NONE", "EU_2002_15_EC" ],
      "x-ms-enum" : {
        "name" : "WorkingTimeDirective",
        "modelAsString" : false
      }
    },
    "WorkingTimeDirectiveLogbookSummary" : {
      "type" : "object",
      "required" : [ "$type" ],
      "discriminator" : "$type",
      "properties" : {
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "The summary of a logbook of a mobile worker. If provided as input, it is taken into account when the mandatory breaks and rests are calculated.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.tourplanning.WorkingTimeDirectiveLogbookSummary"
    },
    "WorkingTimeDirectiveLogbookSummary_EU_2002_15_EC" : {
      "allOf" : [ {
        "$ref" : "#/definitions/WorkingTimeDirectiveLogbookSummary"
      }, {
        "type" : "object",
        "properties" : {
          "accumulatedWorkingTimeSinceLastBreak" : {
            "description" : "Accumulated working time since end of last working break. The working break must have at least a duration of 30 minutes. As soon as 6 hours have elapsed, the driver is no longer allowed to work or drive unless he/she takes a break. A value of more than 6 hours has the same effect as 6 hours.",
            "$ref" : "#/definitions/Duration"
          },
          "elapsedTimeSinceEndOfLastDailyRest" : {
            "description" : "Elapsed time since end of last daily rest, that is, the time between the end of the last daily rest and the reference time. As soon as 9 hours have elapsed, the driver is no longer allowed to work or drive unless he/she takes a daily rest. A value of more than 9 hours has the same effect as 9 hours. May not be smaller than accumulatedWorkingTimeSinceLastBreak, otherwise an exception is thrown.",
            "$ref" : "#/definitions/Duration"
          }
        },
        "description" : "According to Directive 2002/15/EC of the European Parliament and of the Council \"on the organisation of the working time of persons performing mobile road transport activities\".\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.tourplanning.WorkingTimeDirectiveLogbookSummary\\_EU\\_2002\\_15\\_EC"
      } ],
      "x-discriminator-value" : "WorkingTimeDirectiveLogbookSummary_EU_2002_15_EC",
      "x-ms-discriminator-value" : "WorkingTimeDirectiveLogbookSummary_EU_2002_15_EC"
    },
    "Workload" : {
      "type" : "object",
      "properties" : {
        "orderScoreWeight" : {
          "description" : "Defines the importance of prioritizing orders with higher scores if not all orders can be served because of given workload restrictions.",
          "$ref" : "#/definitions/OrderScoreWeight"
        },
        "numberOfStarts" : {
          "description" : "The number of considered start solutions based on different travel time estimation data. A higher number might lead to a better solution at the cost of higher running time.",
          "$ref" : "#/definitions/PositiveInteger"
        },
        "solverTimeLimitPerStart" : {
          "description" : "The solver time limit in seconds for calculating a feasible start solution. A higher value might lead to a better solution at the cost of higher running time. The best out of numberOfStarts start solutions will be calculated in at most (numberOfStarts \\* solverTimeLimit) seconds. In contrast to the total solverTimeLimit, this value only affects the start solution process.",
          "$ref" : "#/definitions/Duration"
        },
        "numberOfNearestNeighbors" : {
          "description" : "The number of nearest neighbors used for estimating travel times between visits.",
          "$ref" : "#/definitions/PositiveInteger"
        }
      },
      "description" : "Contains parameter values for use cases in which the visit plan is calculated with specified daily and/or weekly workload.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.clusterplanningprofile.Workload"
    },
    "WorkloadBalancing" : {
      "type" : "object",
      "properties" : {
        "approximationTolerance" : {
          "description" : "Defines (in percent) how close to the optimal solution value the solver should come before exiting an iteration. For instance, compared to 10% the value of 5% means better solution at the cost of higher running time.",
          "$ref" : "#/definitions/ApproximationTolerance"
        },
        "performPreprocessingStep" : {
          "type" : "boolean",
          "description" : "Perform preprocessing to reduce the complexity of the optimization problem. For example by excluding forbidden or redundant combinations. For large problems the preprocessing itself can be very time-consuming."
        },
        "maximumNumberOfIterations" : {
          "description" : "The maximum number of iterations the solver may use to improve the workload balance. A higher number might lead to a better solution at the cost of higher running time.",
          "$ref" : "#/definitions/PositiveInteger"
        }
      },
      "description" : "Contains parameter values for use cases in which the daily workload in a visit plan needs to be balanced.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.clusterplanningprofile.WorkloadBalancing"
    },
    "WorkloadByDay" : {
      "type" : "object",
      "required" : [ "maximumWorkload" ],
      "properties" : {
        "maximumWorkload" : {
          "description" : "Defines the maximum workload of the field worker for a specified work day. In the resulting visit tour this might be slightly exceeded as driving times are estimated during calculation.",
          "$ref" : "#/definitions/Duration"
        },
        "desiredWorkload" : {
          "description" : "Defines the desired workload of the field worker for a specified work day. It must not be greater than the maximum workload, otherwise a ParameterConflictException is thrown. The accumulated desired workloads of all work days (see WorkloadOptions.workloadsByDay) must not be greater than the maximum weekly workload, otherwise a ParameterConflictException is thrown. Desired workloads are soft constraints and might not be fully satisfied in all situations. Use the maximum workload to assure a strict workload limit. For example, the maximum workload can be set according to legal restrictions and the desired workload according to the contracted hours.",
          "$ref" : "#/definitions/Duration"
        }
      },
      "description" : "Defines the workload of the field worker for a specified work day.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.WorkloadByDay"
    },
    "WorkloadOptions" : {
      "type" : "object",
      "required" : [ "maximumWeeklyWorkload" ],
      "properties" : {
        "maximumWeeklyWorkload" : {
          "description" : "Defines the maximum allowed workload of the field worker per week. In the resulting visit tour this might be slightly exceeded as driving times are estimated during calculation. If the limit is tight with respect to the set of visit orders, some visits may remain unplanned. If skipping visits is not allowed (see allowSkippingVisits), either all visits of a visit order are planned or none. Set scores to define priorities of visit orders.",
          "$ref" : "#/definitions/Duration"
        },
        "workloadsByDay" : {
          "type" : "array",
          "items" : {
            "description" : "Defines the workload of the field worker for each work day. The number of elements must be equal to the number of work days, otherwise a ParameterConflictException is thrown. The n'th working day of the week is described by the n'th list element starting at zero.",
            "$ref" : "#/definitions/WorkloadByDay"
          }
        },
        "allowSkippingVisits" : {
          "type" : "boolean",
          "description" : "If set to true, orders may be partially planned, i.e. visits of a visit order can be skipped for one or multiple weeks.  \r\nIf a week is skipped for a visit order, all visits of this week (according to numberOfVisitsPerWeek will be skipped for this visit order.  \r\nIf a visit order is partially planned, it will be referenced in visitOrderIdsSkipped for all skipped weeks.  \r\nIf set to false, either all visits of a visit order are planned or none.  \r\nIf an order is not planned at all, it will be referenced in visitOrderIdsNotPlanned."
        }
      },
      "description" : "Options influencing the field worker's workload in visit planning. When using this feature, some visits may remain unplanned due to working time limits. If skipping visits is not allowed (see allowSkippingVisits), either all visits of a visit order are planned or none. When using WorkloadOptions, workload is balanced implicitly and balancing parameters such as daily and weekly imbalance tolerance will be ignored. See Plan Visits with Workload Options for details. This feature is only available for the Gurobi solver type.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.WorkloadOptions"
    },
    "XServerError" : {
      "type" : "object",
      "properties" : {
        "message" : {
          "type" : "string",
          "description" : "The detailed message."
        },
        "faultInfo" : {
          "description" : "Contains detailed information on this exception.",
          "$ref" : "#/definitions/XServerFault"
        }
      },
      "description" : "This is the exception which is thrown by all xServer operations. See the included XServerFault and its subtypes for details. The http status code that is returned when an exception is thrown depends on the type of XServerFault that is included in the exception.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.XServerException"
    },
    "XServerFault" : {
      "type" : "object",
      "required" : [ "$type" ],
      "discriminator" : "$type",
      "properties" : {
        "hint" : {
          "type" : "string",
          "description" : "A free-text hint what to do to fix the problem."
        },
        "$type" : {
          "type" : "string"
        }
      },
      "description" : "The base type for all types of fault info that can be included in an XServerException.\nHint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.exceptions.XServerFault"
    },
    "Zoom" : {
      "type" : "number",
      "format" : "double",
      "description" : "The geographical resolution at which to display the map, where zoom 0 corresponds to a map of the Earth fully zoomed out, and larger zoom levels zoom in at a higher resolution. Offering a map of the entire Earth as a single image would either require an immense map, or a small map with very low resolution. As a result, map images are broken up into map 'tiles' and 'zoom levels'. At low zoom levels, a small set of map tiles covers a wide area; at higher zoom levels, the tiles are of higher resolution and cover a smaller area. Fractional values are allowed. The zoom is currently restricted to the range 0..22. Range: 0 ??? value.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.Zoom"
    },
    "ZoomLevel" : {
      "type" : "integer",
      "format" : "int32",
      "description" : "Every map tile belongs to a zoom level z=0, 1, 2, ??? . These levels are related to each other by a factor of two in scale. The zoom level also determines how many tiles are needed to display the entire world. At z=0 the entire world is displayed in a single tile. At z=1, 2x2=4 tiles are needed to display the entire world, and so on. Fractional values are not possible. The zoom level is currently restricted to the range 0..22. Range: 0 ??? value ??? 22.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.ZoomLevel"
    },
    "ZoomLevelRange" : {
      "type" : "string",
      "description" : "Defines a range of values between 0 and 24, describing a Google zoom level. Special values are NEVER or ALWAYS. The upper bound can be omitted, indicating a range with maximal Google zoom level, which can be rendered. Pattern: ALWAYS|NEVER|(\\[0-9\\]|1\\[0-9\\]|2\\[0-4\\])-(\\[0-9\\]|1\\[0-9\\]|2\\[0-4\\])\\{0,1\\}.\nHint: Corresponding unittype in xServer API documentation - com.ptvgroup.xserver.ZoomLevelRange"
    }
  },
  "x-ms-paths" : {
    "/services/rest/XMap/2.26/tile/{zoomLevel}/{x}/{y}?contentType=JSON" : {
      "get" : {
        "tags" : [ "xMap" ],
        "description" : "Render a single map tile according the concept of the Map Tile API. By means of different frameworks a map image can be composed of multiple tiles. These tiles can be cached and reused for drawing of similar sections of a map. Optionally it is possible to return textual information on drawn Feature Layer data. Therefore, this operation can return either an image directly or a structured response which contains the image and additional information on drawn Feature Layer data such as their positions and names.",
        "operationId" : "tile",
        "parameters" : [ {
          "name" : "zoomLevel",
          "in" : "path",
          "description" : "Zoom level. Details about zoom levels are documented in the Map Tile API.",
          "required" : true,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "x",
          "in" : "path",
          "description" : "Horizontal tile index.",
          "required" : true,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "y",
          "in" : "path",
          "description" : "Vertical tile index.",
          "required" : true,
          "type" : "integer",
          "format" : "int32"
        }, {
          "name" : "storedProfile",
          "in" : "query",
          "description" : "The name of the stored profile to use without its extension, e.g. `silkysand`. The corresponding file `silkysand.xml` must be available in the folder `conf/profiles`. Parent profiles must be located in the same folder.",
          "required" : false,
          "type" : "string",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "layers",
          "in" : "query",
          "description" : "A comma-separated list of layers which will be displayed on the map. If this parameter is specified, layers enabled in the stored profile are ignored. These layers can be the base layers `labels`, `transport`, and `background`, or any of the supported Feature Layer themes such as `PTV_TruckAttributes`. If this parameter is not present, the layers defined by the stored profile are displayed. For more information see Integration of custom data and Displaying Feature Layer PTV\\_TruckAttributes.",
          "required" : false,
          "type" : "string",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "contentType",
          "in" : "query",
          "description" : "Content type of the response which can be either `IMAGE` for retrieving a tile image directly or `JSON` to obtain a structured response in JSON format. In case of `JSON` content type, the incorporated image has a format provided by the following parameter.",
          "required" : true,
          "type" : "string",
          "enum" : [ "JSON" ],
          "x-ms-enum" : {
            "name" : "ContentTypeConstant",
            "modelAsString" : true
          }
        }, {
          "name" : "imageFormat",
          "in" : "query",
          "description" : "Image format of the rendered tile. This can be `PNG` or `JPG`. In case of `JPG`, the backgrounds (like oceans and forests) must be part of the image content, because they guarantee an image without any transparent pixels. This is important, because for `JPG` semi-transparent pixels would be drawn in black erroneously. Therefore a ParameterConflictException is thrown in such a case.",
          "required" : false,
          "type" : "string",
          "enum" : [ "PNG", "JPG" ],
          "x-ms-parameter-grouping" : { },
          "x-ms-enum" : {
            "name" : "ImageFormat",
            "modelAsString" : false
          }
        }, {
          "name" : "size",
          "in" : "query",
          "description" : "Width and height of the tile in pixels. The maximum allowed value is 8192.",
          "required" : false,
          "type" : "integer",
          "format" : "int32",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "timeConsideration",
          "in" : "query",
          "description" : "Specifies how to evaluate Feature Layer attributes which contain time restrictions. For time consideration scenario `NONE` the parameters for reference time and timespan are not evaluated. For `SNAPSHOT` and `TIME_SPAN` the reference time is required. The time span is needed for the `TIME_SPAN` scenarios. For detailed information about time consideration scenarios see time consideration.",
          "required" : false,
          "type" : "string",
          "enum" : [ "NONE", "SNAPSHOT", "TIME_SPAN", "EXACT_TIME_AT_START", "EXACT_TIME_AT_ARRIVAL", "OPTIMISTIC" ],
          "x-ms-parameter-grouping" : { },
          "x-ms-enum" : {
            "name" : "TimeConsiderationScenario",
            "modelAsString" : false
          }
        }, {
          "name" : "referenceTime",
          "in" : "query",
          "description" : "The reference time at which Feature Layer attributes with time restrictions will be evaluated. The time format either has to conform to the notation of xs:dateTime such as 2015-12-24T12:00:00+01:00, or it has to be a datetime sequence without any delimiters nor time-zone specification such as 20151224T120000. If the time-zone offset is missing, the corresponding service tries to detect it by means of information available in the calling context. A detailed description of this behavior can be found in the technical concept time zones. It is recommended to always specify the time zone. If no reference time is set, the current UTC time is used.",
          "required" : false,
          "type" : "string",
          "format" : "date-time",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "timeSpan",
          "in" : "query",
          "description" : "The duration of time (in combination with reference time as start) at which Feature Layer attributes with time restrictions will be evaluated, defined in \\[s\\]. The value is rounded to whole seconds.",
          "required" : false,
          "type" : "number",
          "format" : "double",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "showOnlyRelevantByTime",
          "in" : "query",
          "description" : "Specifies if the map shows all attributes regardless of relevance for time consideration (default), or only the attributes which are relevant for this time consideration scenario. For further details, see Relevance of Feature Layer attributes.",
          "required" : false,
          "type" : "boolean",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "showCopyright",
          "in" : "query",
          "description" : "If true it shows the copyright text in the lower right corner of the image. If not defined the default value is false and no copyright text is shown.",
          "required" : false,
          "type" : "boolean",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "preferredRouteTypes",
          "in" : "query",
          "description" : "The road networks to be preferred by the routing algorithm as a comma-separated list (only if the Feature Layer PTV\\_PreferredRoutes is enabled). The available types can be requested through the xRuntime service and are documented in the manual as layer-specific properties of the Feature Layer PTV\\_PreferredRoutes. If this parameter is not present, all types of PTV\\_PreferredRoutes are displayed.",
          "required" : false,
          "type" : "string",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "userLanguage",
          "in" : "query",
          "description" : "The language of texts such as traffic-incident descriptions which are returned for *contentType = JSON*.",
          "required" : false,
          "type" : "string",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "contentSnapshotId",
          "in" : "query",
          "description" : "Specifies the content snapshot to use. If no snapshot ID is set, the most recent content is used.",
          "required" : false,
          "type" : "string",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "mapLanguage",
          "in" : "query",
          "description" : "The language used for geographic names that are part of the map. The default x-ptv-DFT means that names are given in the language spoken in that country or region.",
          "required" : false,
          "type" : "string",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "scope",
          "in" : "query",
          "description" : "A user defined scope for persistent data like Feature Layers.",
          "required" : false,
          "type" : "string",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "drawIcons",
          "in" : "query",
          "description" : "Specifies if the Feature Layer icons have to be drawn on the map.",
          "required" : false,
          "type" : "boolean",
          "x-ms-parameter-grouping" : { }
        }, {
          "name" : "iconReference",
          "in" : "query",
          "description" : "Specifies if icon references should be returned with the features.",
          "required" : false,
          "type" : "boolean",
          "x-ms-parameter-grouping" : { }
        } ],
        "responses" : {
          "200" : {
            "description" : "Response on success.",
            "schema" : {
              "$ref" : "#/definitions/TileResponse"
            }
          },
          "default" : {
            "description" : "Response on failure.",
            "schema" : {
              "$ref" : "#/definitions/XServerError"
            }
          }
        }
      }
    }
  }
}