<?php
/**
 * PlanVisitsOptions
 *
 * PHP version 5
 *
 * @category Class
 * @package  ithings\ptvxserver
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * xServer
 *
 * PTV xServer 2.26.1 - 2.26 API document
 *
 * OpenAPI spec version: 2.26
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.34
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace ithings\ptvxserver\model;

use \ArrayAccess;
use \ithings\ptvxserver\ObjectSerializer;

/**
 * PlanVisitsOptions Class Doc Comment
 *
 * @category Class
 * @description Input parameters for the visit planning algorithm. Hint: Corresponding type in xServer API documentation - com.ptvgroup.xserver.xcluster.PlanVisitsOptions
 * @package  ithings\ptvxserver
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class PlanVisitsOptions implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'PlanVisitsOptions';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'planning_period' => '\ithings\ptvxserver\model\PlanningPeriod',
'work_days' => '\ithings\ptvxserver\model\Week',
'ignore_weekly_imbalance_tolerance' => 'bool',
'weekly_imbalance_tolerance' => '\ithings\ptvxserver\model\Tolerance',
'ignore_daily_imbalance_tolerance' => 'bool',
'daily_imbalance_tolerance' => '\ithings\ptvxserver\model\Tolerance',
'determine_shortest_visit_sequence_per_day' => 'bool',
'improve_daily_workload_balance' => 'bool',
'overnight_stay_options' => '\ithings\ptvxserver\model\OvernightStayOptions',
'workload_options' => '\ithings\ptvxserver\model\WorkloadOptions'    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'planning_period' => null,
'work_days' => null,
'ignore_weekly_imbalance_tolerance' => null,
'weekly_imbalance_tolerance' => null,
'ignore_daily_imbalance_tolerance' => null,
'daily_imbalance_tolerance' => null,
'determine_shortest_visit_sequence_per_day' => null,
'improve_daily_workload_balance' => null,
'overnight_stay_options' => null,
'workload_options' => null    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'planning_period' => 'planningPeriod',
'work_days' => 'workDays',
'ignore_weekly_imbalance_tolerance' => 'ignoreWeeklyImbalanceTolerance',
'weekly_imbalance_tolerance' => 'weeklyImbalanceTolerance',
'ignore_daily_imbalance_tolerance' => 'ignoreDailyImbalanceTolerance',
'daily_imbalance_tolerance' => 'dailyImbalanceTolerance',
'determine_shortest_visit_sequence_per_day' => 'determineShortestVisitSequencePerDay',
'improve_daily_workload_balance' => 'improveDailyWorkloadBalance',
'overnight_stay_options' => 'overnightStayOptions',
'workload_options' => 'workloadOptions'    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'planning_period' => 'setPlanningPeriod',
'work_days' => 'setWorkDays',
'ignore_weekly_imbalance_tolerance' => 'setIgnoreWeeklyImbalanceTolerance',
'weekly_imbalance_tolerance' => 'setWeeklyImbalanceTolerance',
'ignore_daily_imbalance_tolerance' => 'setIgnoreDailyImbalanceTolerance',
'daily_imbalance_tolerance' => 'setDailyImbalanceTolerance',
'determine_shortest_visit_sequence_per_day' => 'setDetermineShortestVisitSequencePerDay',
'improve_daily_workload_balance' => 'setImproveDailyWorkloadBalance',
'overnight_stay_options' => 'setOvernightStayOptions',
'workload_options' => 'setWorkloadOptions'    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'planning_period' => 'getPlanningPeriod',
'work_days' => 'getWorkDays',
'ignore_weekly_imbalance_tolerance' => 'getIgnoreWeeklyImbalanceTolerance',
'weekly_imbalance_tolerance' => 'getWeeklyImbalanceTolerance',
'ignore_daily_imbalance_tolerance' => 'getIgnoreDailyImbalanceTolerance',
'daily_imbalance_tolerance' => 'getDailyImbalanceTolerance',
'determine_shortest_visit_sequence_per_day' => 'getDetermineShortestVisitSequencePerDay',
'improve_daily_workload_balance' => 'getImproveDailyWorkloadBalance',
'overnight_stay_options' => 'getOvernightStayOptions',
'workload_options' => 'getWorkloadOptions'    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['planning_period'] = isset($data['planning_period']) ? $data['planning_period'] : null;
        $this->container['work_days'] = isset($data['work_days']) ? $data['work_days'] : null;
        $this->container['ignore_weekly_imbalance_tolerance'] = isset($data['ignore_weekly_imbalance_tolerance']) ? $data['ignore_weekly_imbalance_tolerance'] : null;
        $this->container['weekly_imbalance_tolerance'] = isset($data['weekly_imbalance_tolerance']) ? $data['weekly_imbalance_tolerance'] : null;
        $this->container['ignore_daily_imbalance_tolerance'] = isset($data['ignore_daily_imbalance_tolerance']) ? $data['ignore_daily_imbalance_tolerance'] : null;
        $this->container['daily_imbalance_tolerance'] = isset($data['daily_imbalance_tolerance']) ? $data['daily_imbalance_tolerance'] : null;
        $this->container['determine_shortest_visit_sequence_per_day'] = isset($data['determine_shortest_visit_sequence_per_day']) ? $data['determine_shortest_visit_sequence_per_day'] : null;
        $this->container['improve_daily_workload_balance'] = isset($data['improve_daily_workload_balance']) ? $data['improve_daily_workload_balance'] : null;
        $this->container['overnight_stay_options'] = isset($data['overnight_stay_options']) ? $data['overnight_stay_options'] : null;
        $this->container['workload_options'] = isset($data['workload_options']) ? $data['workload_options'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['planning_period'] === null) {
            $invalidProperties[] = "'planning_period' can't be null";
        }
        if ($this->container['work_days'] === null) {
            $invalidProperties[] = "'work_days' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets planning_period
     *
     * @return \ithings\ptvxserver\model\PlanningPeriod
     */
    public function getPlanningPeriod()
    {
        return $this->container['planning_period'];
    }

    /**
     * Sets planning_period
     *
     * @param \ithings\ptvxserver\model\PlanningPeriod $planning_period planning_period
     *
     * @return $this
     */
    public function setPlanningPeriod($planning_period)
    {
        $this->container['planning_period'] = $planning_period;

        return $this;
    }

    /**
     * Gets work_days
     *
     * @return \ithings\ptvxserver\model\Week
     */
    public function getWorkDays()
    {
        return $this->container['work_days'];
    }

    /**
     * Sets work_days
     *
     * @param \ithings\ptvxserver\model\Week $work_days work_days
     *
     * @return $this
     */
    public function setWorkDays($work_days)
    {
        $this->container['work_days'] = $work_days;

        return $this;
    }

    /**
     * Gets ignore_weekly_imbalance_tolerance
     *
     * @return bool
     */
    public function getIgnoreWeeklyImbalanceTolerance()
    {
        return $this->container['ignore_weekly_imbalance_tolerance'];
    }

    /**
     * Sets ignore_weekly_imbalance_tolerance
     *
     * @param bool $ignore_weekly_imbalance_tolerance If false, the weeklyImbalanceTolerance parameter will be considered by the planning algorithm. If true, the weeklyImbalanceTolerance will be ignored and a probably imbalanced solution is returned. This parameter is ignored if workLoadOptions are used.
     *
     * @return $this
     */
    public function setIgnoreWeeklyImbalanceTolerance($ignore_weekly_imbalance_tolerance)
    {
        $this->container['ignore_weekly_imbalance_tolerance'] = $ignore_weekly_imbalance_tolerance;

        return $this;
    }

    /**
     * Gets weekly_imbalance_tolerance
     *
     * @return \ithings\ptvxserver\model\Tolerance
     */
    public function getWeeklyImbalanceTolerance()
    {
        return $this->container['weekly_imbalance_tolerance'];
    }

    /**
     * Sets weekly_imbalance_tolerance
     *
     * @param \ithings\ptvxserver\model\Tolerance $weekly_imbalance_tolerance weekly_imbalance_tolerance
     *
     * @return $this
     */
    public function setWeeklyImbalanceTolerance($weekly_imbalance_tolerance)
    {
        $this->container['weekly_imbalance_tolerance'] = $weekly_imbalance_tolerance;

        return $this;
    }

    /**
     * Gets ignore_daily_imbalance_tolerance
     *
     * @return bool
     */
    public function getIgnoreDailyImbalanceTolerance()
    {
        return $this->container['ignore_daily_imbalance_tolerance'];
    }

    /**
     * Sets ignore_daily_imbalance_tolerance
     *
     * @param bool $ignore_daily_imbalance_tolerance If false, the dailyImbalanceTolerance parameter will be considered by the planning algorithm. If true, the dailyImbalanceTolerance will be ignored and a probably imbalanced solution is returned. This parameter is ignored if workLoadOptions are used.
     *
     * @return $this
     */
    public function setIgnoreDailyImbalanceTolerance($ignore_daily_imbalance_tolerance)
    {
        $this->container['ignore_daily_imbalance_tolerance'] = $ignore_daily_imbalance_tolerance;

        return $this;
    }

    /**
     * Gets daily_imbalance_tolerance
     *
     * @return \ithings\ptvxserver\model\Tolerance
     */
    public function getDailyImbalanceTolerance()
    {
        return $this->container['daily_imbalance_tolerance'];
    }

    /**
     * Sets daily_imbalance_tolerance
     *
     * @param \ithings\ptvxserver\model\Tolerance $daily_imbalance_tolerance daily_imbalance_tolerance
     *
     * @return $this
     */
    public function setDailyImbalanceTolerance($daily_imbalance_tolerance)
    {
        $this->container['daily_imbalance_tolerance'] = $daily_imbalance_tolerance;

        return $this;
    }

    /**
     * Gets determine_shortest_visit_sequence_per_day
     *
     * @return bool
     */
    public function getDetermineShortestVisitSequencePerDay()
    {
        return $this->container['determine_shortest_visit_sequence_per_day'];
    }

    /**
     * Sets determine_shortest_visit_sequence_per_day
     *
     * @param bool $determine_shortest_visit_sequence_per_day If true, the visits are returned in an optimal sequence that leads to a shortest tour with respect to travel time for each visit day. The calculation of these shortest tours is allowed to take up to 100 seconds of calculation time on top of the configured solverTimeLimit per day in the result but is usually much quicker. If the parameter is false, visits are sorted by visit day but the sequence of visits within a visit day has no special meaning.
     *
     * @return $this
     */
    public function setDetermineShortestVisitSequencePerDay($determine_shortest_visit_sequence_per_day)
    {
        $this->container['determine_shortest_visit_sequence_per_day'] = $determine_shortest_visit_sequence_per_day;

        return $this;
    }

    /**
     * Gets improve_daily_workload_balance
     *
     * @return bool
     */
    public function getImproveDailyWorkloadBalance()
    {
        return $this->container['improve_daily_workload_balance'];
    }

    /**
     * Sets improve_daily_workload_balance
     *
     * @param bool $improve_daily_workload_balance This feature is only available for the Gurobi solver type. If true, xcluster attempts to further minimize workload imbalances between days. In contrast to the dailyImbalanceTolerance this option considers the workload to not only consist of service time, but also of the travel time between customers on the day. This additional improvement may take up to solverTimeLimit of additional processing time. As the daily workload is calculated based on the shortest visit sequence for the day, determineShortestVisitSequencePerDay is implied to be true. If improveDailyWorkloadBalance is false, balancing will only be performed based on service time according to the given tolerances. This parameter is ignored if workLoadOptions are used.
     *
     * @return $this
     */
    public function setImproveDailyWorkloadBalance($improve_daily_workload_balance)
    {
        $this->container['improve_daily_workload_balance'] = $improve_daily_workload_balance;

        return $this;
    }

    /**
     * Gets overnight_stay_options
     *
     * @return \ithings\ptvxserver\model\OvernightStayOptions
     */
    public function getOvernightStayOptions()
    {
        return $this->container['overnight_stay_options'];
    }

    /**
     * Sets overnight_stay_options
     *
     * @param \ithings\ptvxserver\model\OvernightStayOptions $overnight_stay_options overnight_stay_options
     *
     * @return $this
     */
    public function setOvernightStayOptions($overnight_stay_options)
    {
        $this->container['overnight_stay_options'] = $overnight_stay_options;

        return $this;
    }

    /**
     * Gets workload_options
     *
     * @return \ithings\ptvxserver\model\WorkloadOptions
     */
    public function getWorkloadOptions()
    {
        return $this->container['workload_options'];
    }

    /**
     * Sets workload_options
     *
     * @param \ithings\ptvxserver\model\WorkloadOptions $workload_options workload_options
     *
     * @return $this
     */
    public function setWorkloadOptions($workload_options)
    {
        $this->container['workload_options'] = $workload_options;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}
