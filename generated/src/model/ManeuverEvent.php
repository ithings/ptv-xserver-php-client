<?php
/**
 * ManeuverEvent
 *
 * PHP version 5
 *
 * @category Class
 * @package  ithings\ptvxserver
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * xServer
 *
 * PTV xServer 2.26.1 - 2.26 API document
 *
 * OpenAPI spec version: 2.26
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.34
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace ithings\ptvxserver\model;
use \ithings\ptvxserver\ObjectSerializer;

/**
 * ManeuverEvent Class Doc Comment
 *
 * @category Class
 * @package  ithings\ptvxserver
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ManeuverEvent extends RouteEvent 
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'ManeuverEvent';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'maneuver_type' => '\ithings\ptvxserver\model\ManeuverType',
'relative_direction' => '\ithings\ptvxserver\model\RelativeDirection',
'absolute_direction' => '\ithings\ptvxserver\model\AbsoluteDirectionInteger',
'direction_description' => 'string',
'direction_description_language' => '\ithings\ptvxserver\model\LanguageCode',
'road_ahead' => '\ithings\ptvxserver\model\RoadDescriptor',
'direction_sign_text' => 'string',
'exit_number' => 'string',
'exit_name' => 'string',
'roundabout_exit' => '\ithings\ptvxserver\model\PositiveInteger',
'combined_transport_name' => 'string',
'combined_transport_type' => '\ithings\ptvxserver\model\CombinedTransportType',
'crossing_road_name' => 'string'    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'maneuver_type' => null,
'relative_direction' => null,
'absolute_direction' => null,
'direction_description' => null,
'direction_description_language' => null,
'road_ahead' => null,
'direction_sign_text' => null,
'exit_number' => null,
'exit_name' => null,
'roundabout_exit' => null,
'combined_transport_name' => null,
'combined_transport_type' => null,
'crossing_road_name' => null    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes + parent::swaggerTypes();
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats + parent::swaggerFormats();
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'maneuver_type' => 'maneuverType',
'relative_direction' => 'relativeDirection',
'absolute_direction' => 'absoluteDirection',
'direction_description' => 'directionDescription',
'direction_description_language' => 'directionDescriptionLanguage',
'road_ahead' => 'roadAhead',
'direction_sign_text' => 'directionSignText',
'exit_number' => 'exitNumber',
'exit_name' => 'exitName',
'roundabout_exit' => 'roundaboutExit',
'combined_transport_name' => 'combinedTransportName',
'combined_transport_type' => 'combinedTransportType',
'crossing_road_name' => 'crossingRoadName'    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'maneuver_type' => 'setManeuverType',
'relative_direction' => 'setRelativeDirection',
'absolute_direction' => 'setAbsoluteDirection',
'direction_description' => 'setDirectionDescription',
'direction_description_language' => 'setDirectionDescriptionLanguage',
'road_ahead' => 'setRoadAhead',
'direction_sign_text' => 'setDirectionSignText',
'exit_number' => 'setExitNumber',
'exit_name' => 'setExitName',
'roundabout_exit' => 'setRoundaboutExit',
'combined_transport_name' => 'setCombinedTransportName',
'combined_transport_type' => 'setCombinedTransportType',
'crossing_road_name' => 'setCrossingRoadName'    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'maneuver_type' => 'getManeuverType',
'relative_direction' => 'getRelativeDirection',
'absolute_direction' => 'getAbsoluteDirection',
'direction_description' => 'getDirectionDescription',
'direction_description_language' => 'getDirectionDescriptionLanguage',
'road_ahead' => 'getRoadAhead',
'direction_sign_text' => 'getDirectionSignText',
'exit_number' => 'getExitNumber',
'exit_name' => 'getExitName',
'roundabout_exit' => 'getRoundaboutExit',
'combined_transport_name' => 'getCombinedTransportName',
'combined_transport_type' => 'getCombinedTransportType',
'crossing_road_name' => 'getCrossingRoadName'    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return parent::attributeMap() + self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return parent::setters() + self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return parent::getters() + self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    


    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        parent::__construct($data);

        $this->container['maneuver_type'] = isset($data['maneuver_type']) ? $data['maneuver_type'] : null;
        $this->container['relative_direction'] = isset($data['relative_direction']) ? $data['relative_direction'] : null;
        $this->container['absolute_direction'] = isset($data['absolute_direction']) ? $data['absolute_direction'] : null;
        $this->container['direction_description'] = isset($data['direction_description']) ? $data['direction_description'] : null;
        $this->container['direction_description_language'] = isset($data['direction_description_language']) ? $data['direction_description_language'] : null;
        $this->container['road_ahead'] = isset($data['road_ahead']) ? $data['road_ahead'] : null;
        $this->container['direction_sign_text'] = isset($data['direction_sign_text']) ? $data['direction_sign_text'] : null;
        $this->container['exit_number'] = isset($data['exit_number']) ? $data['exit_number'] : null;
        $this->container['exit_name'] = isset($data['exit_name']) ? $data['exit_name'] : null;
        $this->container['roundabout_exit'] = isset($data['roundabout_exit']) ? $data['roundabout_exit'] : null;
        $this->container['combined_transport_name'] = isset($data['combined_transport_name']) ? $data['combined_transport_name'] : null;
        $this->container['combined_transport_type'] = isset($data['combined_transport_type']) ? $data['combined_transport_type'] : null;
        $this->container['crossing_road_name'] = isset($data['crossing_road_name']) ? $data['crossing_road_name'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = parent::listInvalidProperties();

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets maneuver_type
     *
     * @return \ithings\ptvxserver\model\ManeuverType
     */
    public function getManeuverType()
    {
        return $this->container['maneuver_type'];
    }

    /**
     * Sets maneuver_type
     *
     * @param \ithings\ptvxserver\model\ManeuverType $maneuver_type maneuver_type
     *
     * @return $this
     */
    public function setManeuverType($maneuver_type)
    {
        $this->container['maneuver_type'] = $maneuver_type;

        return $this;
    }

    /**
     * Gets relative_direction
     *
     * @return \ithings\ptvxserver\model\RelativeDirection
     */
    public function getRelativeDirection()
    {
        return $this->container['relative_direction'];
    }

    /**
     * Sets relative_direction
     *
     * @param \ithings\ptvxserver\model\RelativeDirection $relative_direction relative_direction
     *
     * @return $this
     */
    public function setRelativeDirection($relative_direction)
    {
        $this->container['relative_direction'] = $relative_direction;

        return $this;
    }

    /**
     * Gets absolute_direction
     *
     * @return \ithings\ptvxserver\model\AbsoluteDirectionInteger
     */
    public function getAbsoluteDirection()
    {
        return $this->container['absolute_direction'];
    }

    /**
     * Sets absolute_direction
     *
     * @param \ithings\ptvxserver\model\AbsoluteDirectionInteger $absolute_direction absolute_direction
     *
     * @return $this
     */
    public function setAbsoluteDirection($absolute_direction)
    {
        $this->container['absolute_direction'] = $absolute_direction;

        return $this;
    }

    /**
     * Gets direction_description
     *
     * @return string
     */
    public function getDirectionDescription()
    {
        return $this->container['direction_description'];
    }

    /**
     * Sets direction_description
     *
     * @param string $direction_description A descriptive text for the current maneuver. The language can be specified by profile.RequestProfile.userLanguage. The profile.RequestProfile.mapLanguage will not be considered, geographical names such as road names are always given in the local language.
     *
     * @return $this
     */
    public function setDirectionDescription($direction_description)
    {
        $this->container['direction_description'] = $direction_description;

        return $this;
    }

    /**
     * Gets direction_description_language
     *
     * @return \ithings\ptvxserver\model\LanguageCode
     */
    public function getDirectionDescriptionLanguage()
    {
        return $this->container['direction_description_language'];
    }

    /**
     * Sets direction_description_language
     *
     * @param \ithings\ptvxserver\model\LanguageCode $direction_description_language direction_description_language
     *
     * @return $this
     */
    public function setDirectionDescriptionLanguage($direction_description_language)
    {
        $this->container['direction_description_language'] = $direction_description_language;

        return $this;
    }

    /**
     * Gets road_ahead
     *
     * @return \ithings\ptvxserver\model\RoadDescriptor
     */
    public function getRoadAhead()
    {
        return $this->container['road_ahead'];
    }

    /**
     * Sets road_ahead
     *
     * @param \ithings\ptvxserver\model\RoadDescriptor $road_ahead road_ahead
     *
     * @return $this
     */
    public function setRoadAhead($road_ahead)
    {
        $this->container['road_ahead'] = $road_ahead;

        return $this;
    }

    /**
     * Gets direction_sign_text
     *
     * @return string
     */
    public function getDirectionSignText()
    {
        return $this->container['direction_sign_text'];
    }

    /**
     * Sets direction_sign_text
     *
     * @param string $direction_sign_text The city names and road numbers on a signpost at the current location to follow for the current maneuver. Empty if no signpost is present or the data is not available.
     *
     * @return $this
     */
    public function setDirectionSignText($direction_sign_text)
    {
        $this->container['direction_sign_text'] = $direction_sign_text;

        return $this;
    }

    /**
     * Gets exit_number
     *
     * @return string
     */
    public function getExitNumber()
    {
        return $this->container['exit_number'];
    }

    /**
     * Sets exit_number
     *
     * @param string $exit_number The number of an exit or interchange of a highway or a freeway-like road. Only present if the maneuver type is CHANGE or EXIT. Empty if the data does not contain an exit number.
     *
     * @return $this
     */
    public function setExitNumber($exit_number)
    {
        $this->container['exit_number'] = $exit_number;

        return $this;
    }

    /**
     * Gets exit_name
     *
     * @return string
     */
    public function getExitName()
    {
        return $this->container['exit_name'];
    }

    /**
     * Sets exit_name
     *
     * @param string $exit_name The name of an exit or interchange of a highway or a freeway-like road. Only present if the maneuver type is CHANGE or EXIT. Empty if the data does not contain an exit name.
     *
     * @return $this
     */
    public function setExitName($exit_name)
    {
        $this->container['exit_name'] = $exit_name;

        return $this;
    }

    /**
     * Gets roundabout_exit
     *
     * @return \ithings\ptvxserver\model\PositiveInteger
     */
    public function getRoundaboutExit()
    {
        return $this->container['roundabout_exit'];
    }

    /**
     * Sets roundabout_exit
     *
     * @param \ithings\ptvxserver\model\PositiveInteger $roundabout_exit roundabout_exit
     *
     * @return $this
     */
    public function setRoundaboutExit($roundabout_exit)
    {
        $this->container['roundabout_exit'] = $roundabout_exit;

        return $this;
    }

    /**
     * Gets combined_transport_name
     *
     * @return string
     */
    public function getCombinedTransportName()
    {
        return $this->container['combined_transport_name'];
    }

    /**
     * Sets combined_transport_name
     *
     * @param string $combined_transport_name The name of the combined transport to take a the current location. Only present if the maneuver type is TAKE\\_COMBINED\\_TRANSPORT.
     *
     * @return $this
     */
    public function setCombinedTransportName($combined_transport_name)
    {
        $this->container['combined_transport_name'] = $combined_transport_name;

        return $this;
    }

    /**
     * Gets combined_transport_type
     *
     * @return \ithings\ptvxserver\model\CombinedTransportType
     */
    public function getCombinedTransportType()
    {
        return $this->container['combined_transport_type'];
    }

    /**
     * Sets combined_transport_type
     *
     * @param \ithings\ptvxserver\model\CombinedTransportType $combined_transport_type combined_transport_type
     *
     * @return $this
     */
    public function setCombinedTransportType($combined_transport_type)
    {
        $this->container['combined_transport_type'] = $combined_transport_type;

        return $this;
    }

    /**
     * Gets crossing_road_name
     *
     * @return string
     */
    public function getCrossingRoadName()
    {
        return $this->container['crossing_road_name'];
    }

    /**
     * Sets crossing_road_name
     *
     * @param string $crossing_road_name The name of the crossing road at which a U-turn has to be made. Only present if the maneuver type is MAKE\\_U\\_TURN and if the U-turn takes place at a crossing.
     *
     * @return $this
     */
    public function setCrossingRoadName($crossing_road_name)
    {
        $this->container['crossing_road_name'] = $crossing_road_name;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}
